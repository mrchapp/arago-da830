From 2552a27a6d16614e94e3b4f0fd75d5c320fba3ad Mon Sep 17 00:00:00 2001
From: Sanjay Kumar Champati <csanjay@mistralsolutions.com>
Date: Fri, 10 Dec 2010 10:21:47 -0800
Subject: [PATCH 4/5] Supported AFE for UART1 on AM1808 platform

This patch contain following modifications:
1. Pinmuxing of UART1 RTS/CTS lines on UART1 only
if McASP is not selected

2. Since AR7 port type is better match for DaVinci UARTs,
patch forces DA8xx UART's to AR7 port type which enables
AFE capability on the ports.

3.The AFE was being enabled if hardware fifo size is >= bytes.
Modify it to check for 16 bytes to support AR7 ports which
has 16 byte hardware fifo.

4. Disables modem status interrupts (flow control interrupts)
on the davinci da850 based SoM. Because change in CTS line
status does not assert interrupt to ARM.

5. Modifies the RX fifo threshold from 1 to 8 bytes.
This increases throughput by 2Kbps at 4Mbps baudrate.
Modifying the AR7 ports Rx fifo threshold as a temporary
workaround until we find better solution.

Signed-off-by: Sanjay Kumar Champati <csanjay@mistralsolutions.com>
---
 arch/arm/mach-davinci/Kconfig           |    8 ++++++++
 arch/arm/mach-davinci/board-da850-evm.c |   18 +++++++++++++++++-
 arch/arm/mach-davinci/da850.c           |    8 ++++++++
 arch/arm/mach-davinci/devices-da8xx.c   |    9 ++++++---
 drivers/serial/8250.c                   |    9 +++++++--
 5 files changed, 46 insertions(+), 6 deletions(-)

diff --git a/arch/arm/mach-davinci/Kconfig b/arch/arm/mach-davinci/Kconfig
index e9fd1b1..749a61f 100644
--- a/arch/arm/mach-davinci/Kconfig
+++ b/arch/arm/mach-davinci/Kconfig
@@ -58,6 +58,14 @@ config DA8XX_MAX_SPEED_456
 	bool "456 MHz"
 endchoice
 
+config DAVINCI_UART1_AFE
+	bool "Enable UART1 flow control"
+	depends on SERIAL_8250=y && ARCH_DAVINCI_DA850=y
+	help
+	Say Y here if you want to enable flow control on UART1. This flag
+	is necessary to detect pinmux clash between UART1 RTS/CTS lines with
+	MCASP.
+
 config ARCH_DAVINCI_DA8XX
 	bool
 
diff --git a/arch/arm/mach-davinci/board-da850-evm.c b/arch/arm/mach-davinci/board-da850-evm.c
index edad3eb..51eb8bb 100755
--- a/arch/arm/mach-davinci/board-da850-evm.c
+++ b/arch/arm/mach-davinci/board-da850-evm.c
@@ -1039,6 +1039,12 @@ static struct vpif_display_config da850_vpif_display_config = {
 #define HAS_VPIF_CAPTURE 0
 #endif
 
+#if defined(CONFIG_DAVINCI_UART1_AFE)
+#define HAS_UART1_AFE 1
+#else
+#define HAS_UART1_AFE 0
+#endif
+
 static da8xx_ocic_handler_t da850_evm_usb_ocic_handler;
 
 static int da850_evm_usb_set_power(unsigned port, int on)
@@ -1191,6 +1197,12 @@ static __init void da850_evm_init(void)
 		pr_warning("da830_evm_init: watchdog registration failed: %d\n",
 				ret);
 
+	/* Support for UART 1 */
+	ret = da8xx_pinmux_setup(da850_uart1_pins);
+	if (ret)
+		pr_warning("da850_evm_init: UART 1 mux setup failed:"
+							" %d\n", ret);
+
 	if (HAS_MMC) {
 		int i;
 		ret = davinci_cfg_reg(DA850_GPIO0_11);
@@ -1257,7 +1269,6 @@ static __init void da850_evm_init(void)
 	 * accessing them causes endless "too much work in irq53" messages
 	 * with arago fs
 	 */
-	__raw_writel(0, IO_ADDRESS(DA8XX_UART1_BASE) + 0x30);
 	__raw_writel(0, IO_ADDRESS(DA8XX_UART0_BASE) + 0x30);
 
 	if (HAS_MCBSP0) {
@@ -1296,6 +1307,11 @@ static __init void da850_evm_init(void)
 					"but they share pins.\n"
 					"\tDisable one of them.\n");
 
+	if (HAS_UART1_AFE)
+		pr_warning("WARNING: both McASP and UART1_AFE are "
+					"enabled, but they share pins.\n"
+					"\tDisable one of them.\n");
+
 		ret = da8xx_pinmux_setup(da850_mcasp_pins);
 		if (ret)
 			pr_warning("da850_evm_init: mcasp mux setup failed:"
diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index bea825e..fade851 100755
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -467,6 +467,8 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850, UART0_RXD,	3,	16,	15,	2,	false)
 	MUX_CFG(DA850, UART0_TXD,	3,	20,	15,	2,	false)
 	/* UART1 function */
+	MUX_CFG(DA850, NUART1_CTS,	0,	20,	15,	4,	false)
+	MUX_CFG(DA850, NUART1_RTS,	0,	16,	15,	4,	false)
 	MUX_CFG(DA850, UART1_RXD,	4,	24,	15,	2,	false)
 	MUX_CFG(DA850, UART1_TXD,	4,	28,	15,	2,	false)
 	MUX_CFG(DA850, GPIO0_15,	0,	0,	15,	8,	false)
@@ -709,6 +711,12 @@ const short da850_uart0_pins[] __initdata = {
 
 const short da850_uart1_pins[] __initdata = {
 	DA850_UART1_RXD, DA850_UART1_TXD,
+#ifdef CONFIG_DAVINCI_UART1_AFE
+	DA850_NUART1_CTS, DA850_NUART1_RTS,
+#endif
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+	DA850_GPIO0_15,
+#endif
 	-1
 };
 
diff --git a/arch/arm/mach-davinci/devices-da8xx.c b/arch/arm/mach-davinci/devices-da8xx.c
index c8d7a35..65ea108 100755
--- a/arch/arm/mach-davinci/devices-da8xx.c
+++ b/arch/arm/mach-davinci/devices-da8xx.c
@@ -58,7 +58,8 @@ static struct plat_serial8250_port da8xx_serial_pdata[] = {
 		.mapbase	= DA8XX_UART0_BASE,
 		.irq		= IRQ_DA8XX_UARTINT0,
 		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
-					UPF_IOREMAP,
+					UPF_IOREMAP | UPF_FIXED_TYPE,
+		.type		= PORT_AR7,
 		.iotype		= UPIO_MEM,
 		.regshift	= 2,
 	},
@@ -66,7 +67,8 @@ static struct plat_serial8250_port da8xx_serial_pdata[] = {
 		.mapbase	= DA8XX_UART1_BASE,
 		.irq		= IRQ_DA8XX_UARTINT1,
 		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
-					UPF_IOREMAP,
+					UPF_IOREMAP | UPF_FIXED_TYPE,
+		.type		= PORT_AR7,
 		.iotype		= UPIO_MEM,
 		.regshift	= 2,
 	},
@@ -74,7 +76,8 @@ static struct plat_serial8250_port da8xx_serial_pdata[] = {
 		.mapbase	= DA8XX_UART2_BASE,
 		.irq		= IRQ_DA8XX_UARTINT2,
 		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
-					UPF_IOREMAP,
+					UPF_IOREMAP | UPF_FIXED_TYPE,
+		.type		= PORT_AR7,
 		.iotype		= UPIO_MEM,
 		.regshift	= 2,
 	},
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index a64d1de..0ea2542 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -41,6 +41,8 @@
 #include <linux/cpufreq.h>
 #include <linux/clk.h>
 
+#include <mach/cputype.h>
+
 #include <asm/io.h>
 #include <asm/irq.h>
 
@@ -299,7 +301,7 @@ static const struct serial8250_config uart_config[] = {
 		.name		= "AR7",
 		.fifo_size	= 16,
 		.tx_loadsz	= 16,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_00,
+		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
 		.flags		= UART_CAP_FIFO | UART_CAP_AFE,
 	},
 };
@@ -2304,7 +2306,7 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 	 * have sufficient FIFO entries for the latency of the remote
 	 * UART to respond.  IOW, at least 32 bytes of FIFO.
 	 */
-	if (up->capabilities & UART_CAP_AFE && up->port.fifosize >= 32) {
+	if (up->capabilities & UART_CAP_AFE && up->port.fifosize >= 16) {
 		up->mcr &= ~UART_MCR_AFE;
 		if (termios->c_cflag & CRTSCTS)
 			up->mcr |= UART_MCR_AFE;
@@ -2573,6 +2575,9 @@ static void serial8250_config_port(struct uart_port *port, int flags)
 	int probeflags = PROBE_ANY;
 	int ret;
 
+	if (cpu_is_davinci_da850())
+		up->bugs |= UART_BUG_NOMSR;
+
 	/*
 	 * Find the region that we can probe for.  This in turn
 	 * tells us whether we can probe for the type of port.
-- 
1.7.0.4

