From 1b8d7867d955a1a3e08b4307da88aed5c9179263 Mon Sep 17 00:00:00 2001
From: Vaibhav Hiremath <hvaibhav@ti.com>
Date: Fri, 9 Jan 2009 19:22:28 +0530
Subject: [PATCH 172/364] V4L2 driver added
 Features -
 	- Rotation support
 	- Scaling support

---
 arch/arm/mach-omap2/board-omap3evm.c       |   22 +-
 arch/arm/plat-omap/dss/dispc.c             |  270 +++-
 arch/arm/plat-omap/dss/display.c           |   19 +-
 arch/arm/plat-omap/dss/dss.c               |    3 +
 arch/arm/plat-omap/dss/dss.h               |    6 +-
 arch/arm/plat-omap/include/mach/display.h  |   11 +-
 arch/arm/plat-omap/include/mach/omap34xx.h |   13 +
 drivers/media/video/Kconfig                |   21 +
 drivers/media/video/Makefile               |    4 +
 drivers/media/video/omap/Kconfig           |   12 +
 drivers/media/video/omap/Makefile          |    3 +
 drivers/media/video/omap/omap_vout.c       | 2503 ++++++++++++++++++++++++++++
 drivers/media/video/omap/omap_voutdef.h    |  174 ++
 drivers/media/video/omap/omap_voutlib.c    |  281 ++++
 drivers/media/video/omap/omap_voutlib.h    |   34 +
 drivers/media/video/v4l2-ioctl.c           |   19 +
 include/linux/videodev2.h                  |   21 +-
 include/media/v4l2-ioctl.h                 |    4 +
 18 files changed, 3344 insertions(+), 76 deletions(-)
 create mode 100644 drivers/media/video/omap/Kconfig
 create mode 100644 drivers/media/video/omap/Makefile
 create mode 100644 drivers/media/video/omap/omap_vout.c
 create mode 100644 drivers/media/video/omap/omap_voutdef.h
 create mode 100644 drivers/media/video/omap/omap_voutlib.c
 create mode 100644 drivers/media/video/omap/omap_voutlib.h

diff --git a/arch/arm/mach-omap2/board-omap3evm.c b/arch/arm/mach-omap2/board-omap3evm.c
index dd6539e..5ab55cd 100644
--- a/arch/arm/mach-omap2/board-omap3evm.c
+++ b/arch/arm/mach-omap2/board-omap3evm.c
@@ -42,7 +42,6 @@
 #include "twl4030-generic-scripts.h"
 #include "mmc-twl4030.h"
 
-
 static struct resource omap3evm_smc911x_resources[] = {
 	[0] =	{
 		.start  = OMAP3EVM_ETHR_START,
@@ -63,6 +62,25 @@ static struct platform_device omap3evm_smc911x_device = {
 	.resource	= &omap3evm_smc911x_resources [0],
 };
 
+static struct resource omap3evm_vout_resource[] = {
+	[0] =	{
+		.start  = OMAP34XX_VRFB_CTX4,
+		.end    = (OMAP34XX_VRFB_CTX4 + OMAP34XX_VRFB_CTX_SIZE - 1),
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] =	{
+		.start  = OMAP34XX_VRFB_CTX8,
+		.end    = (OMAP34XX_VRFB_CTX8 + OMAP34XX_VRFB_CTX_SIZE - 1),
+		.flags  = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device omap3evm_vout_device = {
+	.name			= "omap_vout",
+	.num_resources	= ARRAY_SIZE(omap3evm_vout_resource),
+	.resource 		= &omap3evm_vout_resource[0],
+	.id		= -1,
+};
 static inline void __init omap3evm_init_smc911x(void)
 {
 	int eth_cs;
@@ -419,6 +437,8 @@ static struct omap_board_config_kernel omap3_evm_config[] __initdata = {
 static struct platform_device *omap3_evm_devices[] __initdata = {
 	&omap3_evm_dss_device,
 	&omap3evm_smc911x_device,
+	&omap3evm_vout_device,
+
 };
 
 static struct twl4030_hsmmc_info mmc[] __initdata = {
diff --git a/arch/arm/plat-omap/dss/dispc.c b/arch/arm/plat-omap/dss/dispc.c
index 20caa48..84b4256 100644
--- a/arch/arm/plat-omap/dss/dispc.c
+++ b/arch/arm/plat-omap/dss/dispc.c
@@ -120,7 +120,6 @@ struct dispc_reg { u16 idx; };
 
 #define DISPC_VID_PRELOAD(n)		DISPC_REG(0x230 + (n)*0x04)
 
-
 #define DISPC_IRQ_MASK_ERROR            (DISPC_IRQ_GFX_FIFO_UNDERFLOW | \
 					 DISPC_IRQ_OCP_ERR | \
 					 DISPC_IRQ_VID1_FIFO_UNDERFLOW | \
@@ -521,7 +520,6 @@ static void _dispc_write_firhv_reg(enum omap_plane plane, int reg, u32 value)
 	dispc_write_reg(DISPC_VID_FIR_COEF_HV(plane-1, reg), value);
 }
 
-
 static void _dispc_set_scale_coef(enum omap_plane plane, int hscaleup,
 		int vscaleup)
 {
@@ -649,7 +647,6 @@ static void _dispc_setup_color_conv_coef(void)
 	REG_FLD_MOD(DISPC_VID_ATTRIBUTES(1), ct->full_range, 11, 11);
 }
 
-
 static void _dispc_set_plane_ba0(enum omap_plane plane, u32 paddr)
 {
 	const struct dispc_reg ba0_reg[] = { DISPC_GFX_BA0,
@@ -926,7 +923,6 @@ static void _dispc_set_vid_accu1(enum omap_plane plane, int haccu, int vaccu)
 	dispc_write_reg(ac1_reg[plane-1], val);
 }
 
-
 static void _dispc_set_scaling(enum omap_plane plane,
 			       int orig_width, int orig_height,
 			       int out_width, int out_height,
@@ -945,18 +941,27 @@ static void _dispc_set_scaling(enum omap_plane plane,
 	hscaleup = orig_width <= out_width;
 	vscaleup = orig_height <= out_height;
 
+	//printk("orig_width = %d orig_height = %d out_width = %d out_height = %d\n",
+	//orig_width, orig_height, out_width, out_height);
+
 	_dispc_set_scale_coef(plane, hscaleup, vscaleup);
 
-	if (!orig_width || orig_width == out_width)
+	if (!orig_width || orig_width == out_width) {
+		//printk("%s %d\n", __func__, __LINE__);
 		fir_hinc = 0;
-	else
+	}
+	else {
 		fir_hinc = 1024 * orig_width / out_width;
-
-	if (!orig_height || orig_height == out_height)
+		//printk("%s %d\n", __func__, __LINE__);
+	}
+	if (!orig_height || orig_height == out_height) {
+		//printk("%s %d\n", __func__, __LINE__);
 		fir_vinc = 0;
-	else
+	}
+	else {
+		//printk("%s %d\n", __func__, __LINE__);
 		fir_vinc = 1024 * orig_height / out_height;
-
+	}
 	_dispc_set_fir(plane, fir_hinc, fir_vinc);
 
 	l = dispc_read_reg(dispc_reg_att[plane]);
@@ -971,15 +976,27 @@ static void _dispc_set_scaling(enum omap_plane plane,
 	dispc_write_reg(dispc_reg_att[plane], l);
 
 	if (ilace) {
+		//printk("%s %d\n", __func__, __LINE__);
 		if (fieldmode) {
 			accu0 = fir_vinc / 2;
 			accu1 = 0;
+			//printk("%s %d\n", __func__, __LINE__);
 		} else {
+#if 0
+			accu0 = 0;
+			accu1 = /*fir_vinc / 2*/0;
+			//if (accu1 >= 1024/2) {
+			//	accu0 = 1024/2;
+			//	accu1 -= accu0;
+			//	printk("%s %d\n", __func__, __LINE__);
+#else
 			accu0 = 0;
 			accu1 = fir_vinc / 2;
 			if (accu1 >= 1024/2) {
 				accu0 = 1024/2;
 				accu1 -= accu0;
+				//printk("%s %d\n", __func__, __LINE__);
+#endif
 			}
 		}
 	}
@@ -988,28 +1005,139 @@ static void _dispc_set_scaling(enum omap_plane plane,
 	_dispc_set_vid_accu1(plane, 0, accu1);
 }
 
+static int _dispc_set_rotation_mirroring(enum omap_plane plane,
+	int rotation, int mirroring, enum omap_color_mode color_mode)
+{
+	u32 attr_value;
+	if (rotation == -1)
+		return 0;
+	if (color_mode == OMAP_DSS_COLOR_YUV2 ||
+		color_mode == OMAP_DSS_COLOR_UYVY) {
+		if (mirroring == 1) {
+
+			if (rotation == 90)
+				REG_FLD_MOD(dispc_reg_att[plane], 0x3, 13, 12);
+			else if (rotation == 270)
+				REG_FLD_MOD(dispc_reg_att[plane], 0x1, 13, 12);
+			else if (rotation == 0)
+				REG_FLD_MOD(dispc_reg_att[plane], 0x2, 13, 12);
+			else if (rotation == 180)
+				REG_FLD_MOD(dispc_reg_att[plane], 0x0, 13, 12);
+		} else {
+			if (rotation == 90)
+				REG_FLD_MOD(dispc_reg_att[plane], 0x3, 13, 12);
+			else if (rotation == 270)
+				REG_FLD_MOD(dispc_reg_att[plane], 0x01, 13, 12);
+			else if (rotation == 180)
+				REG_FLD_MOD(dispc_reg_att[plane], 0x2, 13, 12);
+			else if (rotation == 0)
+				REG_FLD_MOD(dispc_reg_att[plane], 0x0, 13, 12);
+			}
+		}
+		if (rotation == 90 || rotation == 270)
+			REG_FLD_MOD(dispc_reg_att[plane], 0x1, 18, 18);
+		else
+			REG_FLD_MOD(dispc_reg_att[plane], 0x0, 18, 18);
+	attr_value = dispc_read_reg(DISPC_VID_ATTRIBUTES(0));
+	return 0;
+}
+
+#define MAX_PIXELS_PER_LINE     2048
+#define MAX_LINES               2048
+
+static void _dispc_calc_and_set_row_inc(enum omap_plane plane,
+	int screen_width, int cropwidth,
+	int cleft, enum omap_color_mode color_mode, int rotation, int mirror,
+	int fieldmode)
+{
+	int ps = 2, vr_ps = 1;
+	int row_inc_value = 0, pixel_inc_value = 0;
+	int temp;
+
+	switch (color_mode) {
+	case OMAP_DSS_COLOR_YUV2:
+	case OMAP_DSS_COLOR_UYVY:
+		if (mirror == 1 || rotation >= 0) {
+			/*
+			 * ps      - In VRFB space the pixel size for YUYV/UYVY
+			 * is 4 bytes
+			 * vr_ps - Actual pixel size for YUYV/UYVY  is 2 bytes
+			 */
+			ps = 4;
+			vr_ps = 2;
+		}
+		break;
+	case OMAP_DSS_COLOR_RGB24P:
+		ps = 3;		/* pixel size is 3 bytes */
+		break;
+
+	case OMAP_DSS_COLOR_RGB24U:
+		ps = 4;		/* pixel size is 4 bytes */
+		break;
+
+	case OMAP_DSS_COLOR_RGB16:
+	default:
+		ps = 2;		/* pixel size is 2 bytes */
+		break;
+	}
+	if (rotation == 90 || rotation == 270) {
+		row_inc_value = 1 + (MAX_PIXELS_PER_LINE - screen_width +
+			 (screen_width - cropwidth - cleft) + cleft) * ps;
+
+	} else if (rotation == 180 || rotation == 0) {
+		if (color_mode == OMAP_DSS_COLOR_YUV2
+			|| color_mode == OMAP_DSS_COLOR_UYVY) {
+			temp = MAX_PIXELS_PER_LINE - (screen_width / vr_ps);
+			temp += (screen_width - cropwidth - cleft) / vr_ps;
+			row_inc_value = ((temp + (cleft/vr_ps)) * ps);
+			row_inc_value++;
+
+		} else
+			row_inc_value = 1 + (MAX_PIXELS_PER_LINE -
+				screen_width + (screen_width - cropwidth -
+				cleft) + cleft) * ps;
+	} else {
+		row_inc_value = 1 + (screen_width * ps) - cropwidth * ps;
+	}
+	pixel_inc_value = 1;
+
+	if (fieldmode) {
+		if (rotation >= 0)
+			row_inc_value = row_inc_value +
+				MAX_PIXELS_PER_LINE * ps;
+		else
+			row_inc_value = row_inc_value + screen_width * ps;
+	}
+	_dispc_set_row_inc(plane, row_inc_value);
+	//printk("Rowinc = %d\n", row_inc_value);
+
+}
+
 static int _dispc_setup_plane(enum omap_plane plane,
 		enum omap_channel channel_out,
-		u32 paddr, int screen_width,
+		u32 paddr, int tv_field1_offset, int screen_width,
 		int pos_x, int pos_y,
 		int width, int height,
 		int out_width, int out_height,
 		enum omap_color_mode color_mode,
-		int ilace)
+		int ilace, int rotation, int mirror)
 {
 	int fieldmode = 0;
 	int bpp;
 	int cconv;
 	int scaling = 0;
+	u32 attr_value;
 
+	//printk("Rotation = %d and mirror = %d\n", rotation, mirror);
 	if (plane == OMAP_DSS_GFX) {
 		if (width != out_width || height != out_height)
 			return -EINVAL;
 	} else {
 		/* video plane */
-		if (width != out_width || height != out_height)
+		if (width != out_width || height != out_height) {
+			//printk("Scaling = 1\n\n\n");
 			scaling = 1;
-
+		}
 		if (out_width < width/2 ||
 		   out_width > width*8)
 			return -EINVAL;
@@ -1019,7 +1147,6 @@ static int _dispc_setup_plane(enum omap_plane plane,
 			return -EINVAL;
 	}
 
-
 	switch (color_mode) {
 	case OMAP_DSS_COLOR_RGB16:
 		bpp = 16;
@@ -1066,6 +1193,13 @@ static int _dispc_setup_plane(enum omap_plane plane,
 
 	/* attributes */
 	_dispc_set_channel_out(plane, channel_out);
+
+	if (rotation >= 0) {
+		/* Set rotation and mirroring attributes */
+		_dispc_set_rotation_mirroring(plane, rotation,
+				mirror, color_mode);
+	}
+
 	_dispc_set_color_mode(plane, color_mode);
 	if (plane != OMAP_DSS_GFX)
 		_dispc_set_vid_color_conv(plane, cconv);
@@ -1074,24 +1208,32 @@ static int _dispc_setup_plane(enum omap_plane plane,
 
 	_dispc_set_plane_ba0(plane, paddr);
 
-	if (fieldmode)
-		_dispc_set_plane_ba1(plane, paddr + screen_width * bpp/8);
+	if (fieldmode) {
+		//printk("FIELDMODE = ON\n");
+		_dispc_set_plane_ba1(plane, paddr + tv_field1_offset);
+		//printk("Position pos_x = %d pos_y = %d\n", pos_x, pos_y );
+	}
+
 	else
 		_dispc_set_plane_ba1(plane, paddr);
 
-
 	_dispc_set_plane_pos(plane, pos_x, pos_y);
 
 	_dispc_set_pic_size(plane, width, height);
+	 //printk("Pic size height = %d width = %d\n", height, width );
 
 	if (plane != OMAP_DSS_GFX)
 		_dispc_set_vid_size(plane, out_width, out_height);
 
-	_dispc_set_row_inc(plane,
-			   (screen_width - width) * bpp / 8 +
-			   (fieldmode ? screen_width * bpp / 8 : 0) +
-			   1);
+	//printk("Vid size height = %d width = %d\n", out_height, out_width );
+	_dispc_calc_and_set_row_inc(plane, screen_width, width, 0,
+			color_mode, rotation, mirror, fieldmode);
 
+	attr_value = dispc_read_reg(DISPC_VID_ATTRIBUTES(0));
+	//printk("Attributes = %x\n", attr_value);
+	//dispc_write_reg(DISPC_VID_ATTRIBUTES(0), 0x18172);
+	//attr_value = dispc_read_reg(DISPC_VID_ATTRIBUTES(0));
+	//printk("Attributes = %x\n", attr_value);
 	return 0;
 }
 
@@ -1100,7 +1242,6 @@ static void _dispc_enable_plane(enum omap_plane plane, int enable)
 	REG_FLD_MOD(dispc_reg_att[plane], enable ? 1 : 0, 0, 0);
 }
 
-
 void dispc_enable_lcd_out(int enable)
 {
 	enable_clocks(1);
@@ -1143,7 +1284,6 @@ void dispc_enable_fifohandcheck(int enable)
 	enable_clocks(0);
 }
 
-
 void dispc_set_lcd_display_type(enum omap_lcd_display_type type)
 {
 	int mode;
@@ -1174,7 +1314,6 @@ void dispc_set_loadmode(enum omap_dss_load_mode mode)
 	enable_clocks(0);
 }
 
-
 void omap_dispc_set_default_color(enum omap_channel channel, u32 color)
 {
 	const struct dispc_reg def_reg[] = { DISPC_DEFAULT_COLOR0,
@@ -1362,6 +1501,7 @@ unsigned long dispc_fclk_rate(void)
 #else
 	BUG();
 #endif
+	printk("RATE = %d\n\n\n\n\n\n", r);
 	return r;
 }
 
@@ -1378,6 +1518,7 @@ unsigned long dispc_pclk_rate(void)
 
 	r = dispc_fclk_rate();
 
+	printk("RATE = %d\n\n\n\n\n",r);
 	return r / lcd / pcd;
 }
 
@@ -1613,7 +1754,7 @@ int dispc_set_clock_div(struct dispc_clock_info *cinfo)
 	return 0;
 }
 
-int omap_dispc_register_isr(omap_dispc_isr_t isr, void *arg, u32 mask)
+void *omap_dispc_register_isr(omap_dispc_isr_t isr, void *arg, u32 mask)
 {
 	int i;
 	int ret = -EBUSY;
@@ -1621,16 +1762,16 @@ int omap_dispc_register_isr(omap_dispc_isr_t isr, void *arg, u32 mask)
 	u32 new_mask = 0;
 
 	if (isr == NULL)
-		return -EINVAL;
+		return NULL;
 
 	spin_lock_irqsave(&dispc.irq_lock, flags);
 
 	for (i = 0; i < DISPC_MAX_NR_ISRS; i++) {
-		if (registered_isr[i].isr == isr) {
-			ret = -EINVAL;
-			break;
-		}
-
+		//if (registered_isr[i].isr == isr) {
+		//	ret = -EINVAL;
+		//	break;
+		//}
+		printk("%d\n", __LINE__);
 		if (registered_isr[i].isr != NULL)
 			continue;
 
@@ -1638,9 +1779,11 @@ int omap_dispc_register_isr(omap_dispc_isr_t isr, void *arg, u32 mask)
 		registered_isr[i].arg = arg;
 		registered_isr[i].mask = mask;
 
+		printk("Registered ISR at index %d\n", i);
 		enable_clocks(1);
 		new_mask = dispc_read_reg(DISPC_IRQENABLE);
 		new_mask |= mask;
+		dispc_write_reg(DISPC_IRQSTATUS, mask);
 		dispc_write_reg(DISPC_IRQENABLE, new_mask);
 		enable_clocks(0);
 
@@ -1648,42 +1791,49 @@ int omap_dispc_register_isr(omap_dispc_isr_t isr, void *arg, u32 mask)
 		break;
 	}
 
-	spin_unlock_irqrestore(&dispc.irq_lock, flags);
+	if (!ret)
+		return (void *)&registered_isr[i];
+	else
+		return (void *)NULL;
 
-	return ret;
+	spin_unlock_irqrestore(&dispc.irq_lock, flags);
 }
 EXPORT_SYMBOL(omap_dispc_register_isr);
 
-int omap_dispc_unregister_isr(omap_dispc_isr_t isr)
+int omap_dispc_unregister_isr(void * handle)
 {
 	int i, j;
 	unsigned long flags;
 	u32 new_mask = DISPC_IRQ_MASK_ERROR;
 	int ret = -EINVAL;
+	struct registered_isr *isr;
+
 
 	spin_lock_irqsave(&dispc.irq_lock, flags);
 
-	for (i = 0; i < DISPC_MAX_NR_ISRS; i++) {
-		if (registered_isr[i].isr != isr)
-			continue;
+	isr = (struct registered_isr *)handle;
 
-		registered_isr[i].isr = NULL;
-		registered_isr[i].arg = NULL;
-		registered_isr[i].mask = 0;
+	if(isr == NULL)
+		return -EINVAL;
 
-		for (j = 0; j < DISPC_MAX_NR_ISRS; j++)
-			new_mask |= registered_isr[j].mask;
+	for(i = 0; i < DISPC_MAX_NR_ISRS; i++ ) {
+		if(isr == (struct registered_isr *)&(registered_isr[i].isr)) {
 
-		enable_clocks(1);
-		dispc_write_reg(DISPC_IRQENABLE, new_mask);
-		enable_clocks(0);
+			registered_isr[i].isr = NULL;
+			registered_isr[i].arg = NULL;
+			registered_isr[i].mask = 0;
 
-		ret = 0;
-		break;
-	}
+			for (j = 0; j < DISPC_MAX_NR_ISRS; j++)
+				new_mask |= registered_isr[j].mask;
 
+			enable_clocks(1);
+			dispc_write_reg(DISPC_IRQENABLE, new_mask);
+			enable_clocks(0);
+			ret = 0;
+			break;
+		}
+	}
 	spin_unlock_irqrestore(&dispc.irq_lock, flags);
-
 	return ret;
 }
 EXPORT_SYMBOL(omap_dispc_unregister_isr);
@@ -1730,12 +1880,18 @@ void dispc_irq_handler(void)
 	 * off */
 	dispc_write_reg(DISPC_IRQSTATUS, irqstatus);
 
+	//printk("irqstatus %d\n irqstatus", irqstatus);
+
 	for (i = 0; i < DISPC_MAX_NR_ISRS; i++) {
 		if (!registered_isr[i].isr)
 			continue;
+		//printk("%x %x %x %x\n",registered_isr[i].mask,
+//			irqstatus, registered_isr[i].mask & irqstatus, irqstatus & 0x3 );
 		if (registered_isr[i].mask & irqstatus) {
+			//printk("irqstatus %d\n ", irqstatus);
 			registered_isr[i].isr(registered_isr[i].arg,
 					      irqstatus);
+
 			handledirqs |= registered_isr[i].mask;
 		}
 	}
@@ -1865,12 +2021,12 @@ int dispc_enable_plane(enum omap_plane plane, int enable)
 }
 
 int dispc_setup_plane(enum omap_plane plane, enum omap_channel channel_out,
-		       u32 paddr, int screen_width,
+		       u32 paddr, int tv_field1_offset, int screen_width,
 		       int pos_x, int pos_y,
 		       int width, int height,
 		       int out_width, int out_height,
 		       enum omap_color_mode color_mode,
-		       int ilace)
+		       int ilace, int rotation, int mirror)
 {
 	int r = 0;
 
@@ -1880,15 +2036,14 @@ int dispc_setup_plane(enum omap_plane plane, enum omap_channel channel_out,
 	       width, height,
 	       out_width, out_height,
 	       ilace);
-
 	enable_clocks(1);
 
 	r = _dispc_setup_plane(plane, channel_out,
-			   paddr, screen_width,
+			   paddr, tv_field1_offset, screen_width,
 			   pos_x, pos_y,
 			   width, height,
 			   out_width, out_height,
-			   color_mode, ilace);
+			   color_mode, ilace, rotation, mirror);
 
 	enable_clocks(0);
 
@@ -1941,7 +2096,6 @@ void dispc_setup_partial_planes(struct omap_display *display,
 	DSSDBG("dispc_setup_partial_planes %d,%d %dx%d\n",
 		*xi, *yi, *wi, *hi);
 
-
 	mgr = display->manager;
 
 	if (!mgr) {
@@ -2095,11 +2249,11 @@ void dispc_setup_partial_planes(struct omap_display *display,
 				ovl->id, pa, psw, px, py, pw, ph, pow, poh);
 
 		dispc_setup_plane(ovl->id, mgr->id,
-				pa, psw,
+				pa, pi->tv_field1_offset, psw,
 				px, py,
 				pw, ph,
 				pow, poh,
-				pi->color_mode, 0);
+				pi->color_mode, 0, 0, 0);
 
 		dispc_enable_plane(ovl->id, 1);
 	}
diff --git a/arch/arm/plat-omap/dss/display.c b/arch/arm/plat-omap/dss/display.c
index e3ff778..c312cb2 100644
--- a/arch/arm/plat-omap/dss/display.c
+++ b/arch/arm/plat-omap/dss/display.c
@@ -245,9 +245,9 @@ static int omap_dss_unset_display(struct omap_overlay_manager *mgr)
 }
 
 static int omap_dss_setup_overlay_input(struct omap_overlay *ovl,
-		u32 paddr, void *vaddr, int screen_width,
+		u32 paddr, void *vaddr, int tv_field1_offset, int screen_width,
 		int width, int height,
-		enum omap_color_mode color_mode)
+		enum omap_color_mode color_mode, int rotation, int mirror)
 {
 	int r;
 	struct omap_overlay_info old_info;
@@ -262,7 +262,9 @@ static int omap_dss_setup_overlay_input(struct omap_overlay *ovl,
 	ovl->info.paddr = paddr;
 	ovl->info.vaddr = vaddr;
 	ovl->info.screen_width = screen_width;
-
+	ovl->info.rotation = rotation;
+	ovl->info.mirror = mirror;
+	ovl->info.tv_field1_offset = tv_field1_offset;
 	ovl->info.width = width;
 	ovl->info.height = height;
 	ovl->info.color_mode = color_mode;
@@ -381,6 +383,7 @@ static int omap_dss_mgr_apply(struct omap_overlay_manager *mgr)
 
 		r = dispc_setup_plane(ovl->id, ovl->manager->id,
 				ovl->info.paddr,
+				ovl->info.tv_field1_offset,
 				ovl->info.screen_width,
 				ovl->info.pos_x,
 				ovl->info.pos_y,
@@ -389,13 +392,14 @@ static int omap_dss_mgr_apply(struct omap_overlay_manager *mgr)
 				outw,
 				outh,
 				ovl->info.color_mode,
-				ilace);
+				ilace,
+				ovl->info.rotation,
+				ovl->info.mirror);
 
 		if (r) {
 			DSSERR("dispc_setup_plane failed\n");
 			goto exit;
 		}
-
 		dispc_enable_plane(ovl->id, 1);
 	}
 
@@ -599,7 +603,10 @@ void initialize_overlays(const char *def_disp_name)
 		for (i = 0; i < 3; i++) {
 			struct omap_overlay *ovl;
 			ovl = omap_dss_get_overlay(i);
-			omap_dss_set_manager(ovl, def_mgr);
+			if (i == 1)
+				omap_dss_set_manager(ovl, lcd_mgr);
+			else
+				omap_dss_set_manager(ovl, tv_mgr);
 		}
 	}
 
diff --git a/arch/arm/plat-omap/dss/dss.c b/arch/arm/plat-omap/dss/dss.c
index b9f35d8..bf4175f 100644
--- a/arch/arm/plat-omap/dss/dss.c
+++ b/arch/arm/plat-omap/dss/dss.c
@@ -480,6 +480,9 @@ static irqreturn_t dss_irq_handler_omap3(int irq, void *arg)
 		dsi_irq_handler();
 #endif
 
+	/* Workaround suggested by Tony  for spurious interrupt warning */
+	irqstatus = dss_read_reg(DSS_IRQSTATUS);
+
 	return IRQ_HANDLED;
 }
 
diff --git a/arch/arm/plat-omap/dss/dss.h b/arch/arm/plat-omap/dss/dss.h
index da628a7..c77412b 100644
--- a/arch/arm/plat-omap/dss/dss.h
+++ b/arch/arm/plat-omap/dss/dss.h
@@ -161,7 +161,6 @@ int sdi_init(void);
 void sdi_exit(void);
 void sdi_init_display(struct omap_display *display);
 
-
 /* DSI */
 int dsi_init(void);
 void dsi_exit(void);
@@ -213,12 +212,12 @@ void dispc_set_plane_size(enum omap_plane plane, int width, int height);
 void dispc_set_row_inc(enum omap_plane plane, int inc);
 
 int dispc_setup_plane(enum omap_plane plane, enum omap_channel channel_out,
-		      u32 paddr, int screen_width,
+		      u32 paddr, int tv_field1_offset, int screen_width,
 		      int pos_x, int pos_y,
 		      int width, int height,
 		      int out_width, int out_height,
 		      enum omap_color_mode color_mode,
-		      int ilace);
+		      int ilace, int rotation, int mirror);
 
 void dispc_go(enum omap_channel channel);
 void dispc_enable_lcd_out(int enable);
@@ -251,7 +250,6 @@ void dispc_setup_partial_planes(struct omap_display *display,
 				int *x, int *y, int *w, int *h);
 void dispc_draw_partial_planes(struct omap_display *display);
 
-
 ssize_t dispc_print_clocks(char *buf, ssize_t size);
 
 /* VENC */
diff --git a/arch/arm/plat-omap/include/mach/display.h b/arch/arm/plat-omap/include/mach/display.h
index 49ab00a..48af269 100644
--- a/arch/arm/plat-omap/include/mach/display.h
+++ b/arch/arm/plat-omap/include/mach/display.h
@@ -320,6 +320,7 @@ struct omap_overlay_info {
 	int enabled;
 	u32 paddr;
 	void *vaddr;
+	int tv_field1_offset;
 	int screen_width;
 	int pos_x;
 	int pos_y;
@@ -327,6 +328,8 @@ struct omap_overlay_info {
 	int height;
 	int out_width;	/* if 0, out_width == width */
 	int out_height;	/* if 0, out_height == height */
+	int rotation;
+	int mirror;
 	enum omap_color_mode color_mode;
 };
 
@@ -349,9 +352,11 @@ struct omap_overlay {
 
 	int (*setup_input)(struct omap_overlay *ovl,
 			u32 paddr, void *vaddr,
+			int tv_field1_offset,
 			int screen_width,
 			int width, int height,
-			enum omap_color_mode color_mode);
+			enum omap_color_mode color_mode, int rotation,
+			int mirror);
 	int (*setup_output)(struct omap_overlay *ovl,
 			int pos_x, int pos_y,
 			int out_width, int out_height);
@@ -456,7 +461,7 @@ int omap_dss_get_num_overlays(void);
 struct omap_overlay *omap_dss_get_overlay(int num);
 
 typedef void (*omap_dispc_isr_t) (void *arg, u32 mask);
-int omap_dispc_register_isr(omap_dispc_isr_t isr, void *arg, u32 mask);
-int omap_dispc_unregister_isr(omap_dispc_isr_t isr);
+void *omap_dispc_register_isr(omap_dispc_isr_t isr, void *arg, u32 mask);
+int omap_dispc_unregister_isr(void* handle);
 
 #endif
diff --git a/arch/arm/plat-omap/include/mach/omap34xx.h b/arch/arm/plat-omap/include/mach/omap34xx.h
index 382e741..666fb7f 100644
--- a/arch/arm/plat-omap/include/mach/omap34xx.h
+++ b/arch/arm/plat-omap/include/mach/omap34xx.h
@@ -59,6 +59,19 @@
 #define OMAP34XX_CAMERA_BASE		(L4_34XX_BASE + 0xBC000)
 #define OMAP34XX_MAILBOX_BASE		(L4_34XX_BASE + 0x94000)
 
+#define OMAP34XX_VRFB_CTX0	0x70000000
+#define OMAP34XX_VRFB_CTX1	0x74000000
+#define OMAP34XX_VRFB_CTX2	0x78000000
+#define OMAP34XX_VRFB_CTX3	0x7C000000
+#define OMAP34XX_VRFB_CTX4	0xE0000000
+#define OMAP34XX_VRFB_CTX5	0xE4000000
+#define OMAP34XX_VRFB_CTX6	0xE8000000
+#define OMAP34XX_VRFB_CTX7	0xEC000000
+#define OMAP34XX_VRFB_CTX8	0xF0000000
+#define OMAP34XX_VRFB_CTX9	0xF4000000
+#define OMAP34XX_VRFB_CTX10	0xF8000000
+#define OMAP34XX_VRFB_CTX11	0xFC000000
+#define OMAP34XX_VRFB_CTX_SIZE	0x4000000
 
 #if defined(CONFIG_ARCH_OMAP3430)
 
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 19cf3b8..a1fd6d4 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -711,6 +711,27 @@ config VIDEO_CAFE_CCIC
 	  CMOS camera controller.  This is the controller found on first-
 	  generation OLPC systems.
 
+source "drivers/media/video/isp/Kconfig"
+
+#config VIDEO_OMAP3
+#        tristate "OMAP 3 Camera support"
+#	select VIDEOBUF_GEN
+#	select VIDEOBUF_DMA_SG
+#	depends on VIDEO_V4L2 && ARCH_OMAP34XX
+#	---help---
+#	  Driver for an OMAP 3 camera controller.
+
+config VIDEO_OMAP3
+	bool "OMAP2/OMAP3 Camera and V4L2-DSS drivers"
+	select VIDEOBUF_GEN
+	select VIDEOBUF_DMA_SG
+	depends on VIDEO_DEV && (ARCH_OMAP24XX || ARCH_OMAP34XX)
+	default y
+	---help---
+        V4L2 DSS and Camera driver support for OMAP2/3 based boards.
+
+source "drivers/media/video/omap/Kconfig"
+
 config SOC_CAMERA
 	tristate "SoC camera support"
 	depends on VIDEO_V4L2 && HAS_DMA
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 72f6d03..95dbad4 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -107,6 +107,10 @@ obj-$(CONFIG_VIDEO_CAFE_CCIC) += cafe_ccic.o
 obj-$(CONFIG_VIDEO_OV7670) 	+= ov7670.o
 
 obj-$(CONFIG_VIDEO_TCM825X) += tcm825x.o
+obj-$(CONFIG_VIDEO_MT9P012)	+= mt9p012.o
+obj-$(CONFIG_VIDEO_DW9710) += dw9710.o
+
+obj-$(CONFIG_VIDEO_OMAP3) += omap34xxcam.o isp/ omap/
 
 obj-$(CONFIG_USB_DABUSB)        += dabusb.o
 obj-$(CONFIG_USB_OV511)         += ov511.o
diff --git a/drivers/media/video/omap/Kconfig b/drivers/media/video/omap/Kconfig
new file mode 100644
index 0000000..ac81f4c
--- /dev/null
+++ b/drivers/media/video/omap/Kconfig
@@ -0,0 +1,12 @@
+config VIDEO_OMAP_VIDEOLIB
+	tristate "OMAP Video out library"
+	depends on VIDEO_OMAP3
+	default VIDEO_OMAP3
+
+config VIDEO_OMAP_VIDEOOUT
+	tristate "OMAP Video out driver"
+	select VIDEOBUF_DMA_SG
+	select VIDEOBUF_GEN
+	depends on VIDEO_OMAP3
+	default VIDEO_OMAP3
+
diff --git a/drivers/media/video/omap/Makefile b/drivers/media/video/omap/Makefile
new file mode 100644
index 0000000..75e01d3
--- /dev/null
+++ b/drivers/media/video/omap/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_VIDEO_OMAP_VIDEOLIB) += omap_voutlib.o
+obj-$(CONFIG_VIDEO_OMAP_VIDEOOUT) += omap_vout.o
+
diff --git a/drivers/media/video/omap/omap_vout.c b/drivers/media/video/omap/omap_vout.c
new file mode 100644
index 0000000..33df3f6
--- /dev/null
+++ b/drivers/media/video/omap/omap_vout.c
@@ -0,0 +1,2503 @@
+/*
+ * drivers/media/video/omap/omap_vout.c
+ *
+ * Copyright (C) 2005-2006 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ * Leveraged code from the OMAP2 camera driver
+ * Video-for-Linux (Version 2) camera capture driver for
+ * the OMAP24xx camera controller.
+ *
+ * Author: Andy Lowe (source@mvista.com)
+ *
+ * Copyright (C) 2004 MontaVista Software, Inc.
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * History:
+ * 20-APR-2006	Khasim		Modified VRFB based Rotation,
+ *				The image data is always read from 0 degree
+ *				view and written
+ *				to the virtual space of desired rotation angle
+ * 4-DEC-2006 Jian		Changed to support better memory management
+ *
+ * 17-Nov-2008 Hardik		Changed to used the new DSS paches by Tomi
+ *				Changed driver to use video_ioctl2
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/interrupt.h>
+#include <linux/kdev_t.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/videodev2.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <media/videobuf-dma-sg.h>
+#include <linux/input.h>
+#include <linux/dma-mapping.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-ioctl.h>
+#ifdef CONFIG_PM
+#include <linux/notifier.h>
+#include <linux/pm.h>
+#endif
+#ifdef CONFIG_DPM
+#include <linux/dpm.h>
+#endif
+
+#include <mach/display.h>
+
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/semaphore.h>
+#include <asm/processor.h>
+#include <mach/dma.h>
+
+#include "omap_voutlib.h"
+
+/*
+ * Un-comment this to use Debug Write call
+ */
+/* #define DEBUG_ALLOW_WRITE */
+
+#include "omap_voutdef.h"
+
+unsigned long timeout;
+
+#define OMAP_VIDEO1 0
+#define OMAP_VIDEO2 1
+
+/*
+ * Uncomment this if debugging support needs to be enabled
+ */
+
+/* #define DEBUG */
+
+#undef DEBUG
+#ifdef DEBUG
+#define DPRINTK(ARGS...)  (printk(KERN_DEBUG "<%s>: ", __func__); \
+				printk(KERN_DEBUG ARGS))
+#else
+#define DPRINTK(x...)
+#endif
+
+static int rotation_support = -1;
+
+#define FIND_ROTATION_ANGLE(rot) (rot == 90) ? (270 / 90) :\
+				(rot == 270) ? (90 / 90) :\
+				(rot == 180) ? (0 / 90) : (180 / 90);
+
+struct omap_display *def_display;
+
+/* configuration macros */
+#define VOUT_NAME		"omap_vout"
+
+#define QQVGA_WIDTH		160
+#define QQVGA_HEIGHT		120
+
+#define NUM_OF_VIDEO_CHANNELS	2
+
+#define VID_MAX_WIDTH		1280	/* Largest width */
+#define VID_MAX_HEIGHT		720/* Largest height */
+
+#define VID_MIN_WIDTH		0
+#define VID_MIN_HEIGHT		0
+
+/* 2048 x 2048 is max res supported by OMAP display controller */
+#define VRFB_MAX_PIXELS_PER_LINE     2048
+#define VRFB_MAX_LINES               2048
+#define VRFB_SIZE                (VRFB_MAX_PIXELS_PER_LINE * VRFB_MAX_LINES * 4)
+#define DMA_CHAN_ALLOTED        1
+#define DMA_CHAN_NOT_ALLOTED    0
+
+#define OMAP_VOUT_MAX_BUF_SIZE (VID_MAX_WIDTH*VID_MAX_HEIGHT*4)
+
+static struct omap_vout_device *saved_v1out, *saved_v2out;
+
+#define STREAMING_IS_ON()	((saved_v1out && saved_v1out->streaming) || \
+				(saved_v2out && saved_v2out->streaming))
+
+static struct videobuf_queue_ops video_vbq_ops;
+
+static u32 video1_numbuffers = 3;
+static u32 video2_numbuffers = 3;
+static u32 video1_bufsize = OMAP_VOUT_MAX_BUF_SIZE;
+static u32 video2_bufsize = OMAP_VOUT_MAX_BUF_SIZE;
+module_param(video1_numbuffers, uint, S_IRUGO);
+module_param(video2_numbuffers, uint, S_IRUGO);
+module_param(video1_bufsize, uint, S_IRUGO);
+module_param(video2_bufsize, uint, S_IRUGO);
+
+static int omap_vout_create_video_devices(struct platform_device *pdev);
+static int omapvid_apply_changes(struct omap_vout_device *vout, u32 addr,
+		int init);
+static int omapvid_setup_overlay(struct omap_vout_device *vout,
+		struct omap_overlay *ovl, int posx, int posy,
+		int outw, int outh, u32 addr, int tv_field1_offset);
+static enum omap_color_mode video_mode_to_dss_mode(struct v4l2_pix_format *pix);
+static void omap_vout_isr(void *arg, unsigned int irqstatus);
+static void omap_vout_cleanup_device(struct omap_vout_device *vout);
+/* module parameters */
+
+/*
+ * Maximum amount of memory to use for rendering buffers.
+ * Default is enough to four (RGB24) VGA buffers.
+ */
+#define MAX_ALLOWED_VIDBUFFERS            4
+
+static struct v4l2_queryctrl omap_vout_qctrl[] = {
+	{
+		.id            = V4L2_CID_ROTATION,
+		.name          = "Rotation",
+		.minimum       = 0,
+		.maximum       = 270,
+		.step          = 90,
+		.default_value = -1,
+		.flags         = 0,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+	}
+};
+
+/* list of image formats supported by OMAP2 video pipelines */
+const static struct v4l2_fmtdesc omap_formats[] = {
+	{
+	 /* Note:  V4L2 defines RGB565 as:
+	  *
+	  *      Byte 0                    Byte 1
+	  *      g2 g1 g0 r4 r3 r2 r1 r0   b4 b3 b2 b1 b0 g5 g4 g3
+	  *
+	  * We interpret RGB565 as:
+	  *
+	  *      Byte 0                    Byte 1
+	  *      g2 g1 g0 b4 b3 b2 b1 b0   r4 r3 r2 r1 r0 g5 g4 g3
+	  */
+	 .description = "RGB565, le",
+	 .pixelformat = V4L2_PIX_FMT_RGB565,
+	 },
+	{
+	 /* Note:  V4L2 defines RGB565X as:
+	  *
+	  *      Byte 0                    Byte 1
+	  *      b4 b3 b2 b1 b0 g5 g4 g3   g2 g1 g0 r4 r3 r2 r1 r0
+	  *
+	  * We interpret RGB565X as:
+	  *
+	  *      Byte 0                    Byte 1
+	  *      r4 r3 r2 r1 r0 g5 g4 g3   g2 g1 g0 b4 b3 b2 b1 b0
+	  */
+	 .description = "RGB565, be",
+	 .pixelformat = V4L2_PIX_FMT_RGB565X,
+	 },
+	{
+	 /* Note:  V4L2 defines RGB32 as: RGB-8-8-8-8  we use
+	  *  this for RGB24 unpack mode, the last 8 bits are ignored
+	  * */
+	 .description = "RGB32, le",
+	 .pixelformat = V4L2_PIX_FMT_RGB32,
+	 },
+	{
+	 /* Note:  V4L2 defines RGB24 as: RGB-8-8-8  we use
+	  *        this for RGB24 packed mode
+	  *
+	  */
+	 .description = "RGB24, le",
+	 .pixelformat = V4L2_PIX_FMT_RGB24,
+	 },
+	{
+	 .description = "YUYV (YUV 4:2:2), packed",
+	 .pixelformat = V4L2_PIX_FMT_YUYV,
+	 },
+	{
+	 .description = "UYVY, packed",
+	 .pixelformat = V4L2_PIX_FMT_UYVY,
+	 },
+};
+
+#define NUM_OUTPUT_FORMATS (sizeof(omap_formats)/sizeof(omap_formats[0]))
+
+struct omap_vout_std_id_name {
+	v4l2_std_id id;
+	char name[25];
+};
+
+static unsigned long
+omap_vout_alloc_buffer(u32 buf_size, u32 *phys_addr)
+{
+	unsigned long virt_addr, addr;
+	u32 order, size;
+	size = PAGE_ALIGN(buf_size);
+	order = get_order(size);
+	virt_addr = __get_free_pages(GFP_KERNEL | GFP_DMA, order);
+	addr = virt_addr;
+	if (virt_addr) {
+		while (size > 0) {
+			SetPageReserved(virt_to_page(addr));
+			addr += PAGE_SIZE;
+			size -= PAGE_SIZE;
+		}
+	}
+	*phys_addr = (u32) virt_to_phys((void *) virt_addr);
+	return virt_addr;
+}
+
+static void
+omap_vout_free_buffer(unsigned long virtaddr, u32 phys_addr,
+			 u32 buf_size)
+{
+	unsigned long addr = virtaddr;
+	u32 order, size;
+	size = PAGE_ALIGN(buf_size);
+	order = get_order(size);
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(addr));
+		addr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages((unsigned long) virtaddr, order);
+}
+
+static int omap_vout_try_format(struct v4l2_pix_format *pix,
+				struct v4l2_pix_format *def_pix)
+{
+	int ifmt, bpp = 0;
+
+	if (pix->width > VID_MAX_WIDTH)
+		pix->width = VID_MAX_WIDTH;
+	if (pix->height > VID_MAX_HEIGHT)
+		pix->height = VID_MAX_HEIGHT;
+
+	if (pix->width <= VID_MIN_WIDTH)
+		pix->width = def_pix->width;
+	if (pix->height <= VID_MIN_HEIGHT)
+		pix->height = def_pix->height;
+
+	for (ifmt = 0; ifmt < NUM_OUTPUT_FORMATS; ifmt++) {
+		if (pix->pixelformat == omap_formats[ifmt].pixelformat)
+			break;
+	}
+
+	if (ifmt == NUM_OUTPUT_FORMATS)
+		ifmt = 0;
+
+	pix->pixelformat = omap_formats[ifmt].pixelformat;
+	pix->field = V4L2_FIELD_ANY;
+	pix->priv = 0;
+
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+	default:
+		pix->colorspace = V4L2_COLORSPACE_JPEG;
+		bpp = YUYV_BPP;
+		break;
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_RGB565X:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		bpp = RGB565_BPP;
+		break;
+	case V4L2_PIX_FMT_RGB24:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		bpp = RGB24_BPP;
+		break;
+	case V4L2_PIX_FMT_RGB32:
+	case V4L2_PIX_FMT_BGR32:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		bpp = RGB32_BPP;
+		break;
+	}
+	pix->bytesperline = pix->width * bpp;
+	pix->sizeimage = pix->bytesperline * pix->height;
+	return bpp;
+}
+
+/*
+ * omap_vout_uservirt_to_phys: This inline function is used to convert user
+ * space virtual address to physical address.
+ */
+	static inline u32 omap_vout_uservirt_to_phys(u32 virtp)
+{
+	unsigned long physp = 0;
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+
+	vma = find_vma(mm, virtp);
+	/* For kernel direct-mapped memory, take the easy way */
+	if (virtp >= PAGE_OFFSET) {
+		physp = virt_to_phys((void *) virtp);
+	} else if ((vma) && (vma->vm_flags & VM_IO)
+		   && (vma->vm_pgoff)) {
+		/* this will catch, kernel-allocated,
+		   mmaped-to-usermode addresses */
+		physp = (vma->vm_pgoff << PAGE_SHIFT) + (virtp - vma->vm_start);
+	} else {
+		/* otherwise, use get_user_pages() for general userland pages */
+		int res, nr_pages = 1;
+		struct page *pages;
+		down_read(&current->mm->mmap_sem);
+
+		res = get_user_pages(current, current->mm, virtp, nr_pages,
+				1, 0, &pages, NULL);
+		up_read(&current->mm->mmap_sem);
+
+		if (res == nr_pages) {
+			physp =  __pa(page_address(&pages[0]) +
+					(virtp & ~PAGE_MASK));
+		} else {
+			printk(KERN_WARNING "omap_vout_uservirt_to_phys:\
+					get_user_pages failed\n");
+			return 0;
+		}
+	}
+
+	return physp;
+}
+
+/* This functions wakes up the application once
+ * the DMA transfer to VRFB space is completed. */
+static void omap_vout_vrfb_dma_tx_callback(int lch, u16 ch_status, void *data)
+{
+	struct vid_vrfb_dma *t = (struct vid_vrfb_dma *) data;
+	t->tx_status = 1;
+	wake_up_interruptible(&t->wait);
+}
+
+/* SDRAM page size parameters used for VRFB settings */
+#define PAGE_WIDTH_EXP          5       /* page width = 1 << PAGE_WIDTH_EXP */
+#define PAGE_HEIGHT_EXP         5       /* page height = 1 << PAGE_HEIGHT_EXP */
+
+/* Function used to find the VRFB Alignement */
+static inline u32 pages_per_side(u32 img_side, u32 page_exp)
+{
+	/*  page_side = 2 ^ page_exp
+	 * (page_side - 1) is added for rounding up
+	 */
+	return (u32) (img_side + (1 << page_exp) - 1) >> page_exp;
+}
+
+/* Sets the SMS settings for rotation using the VRFB.
+ */
+int omap_vout_set_vrfb(int context, u32 phy_addr,
+		u32 width, u32 height, u32 bytes_per_pixel)
+{
+	int page_width_exp, page_height_exp, pixel_size_exp;
+	void __iomem *context_phy_address;
+	void __iomem *context_virt_address;
+	static void __iomem *reg_address;
+
+	/* Get the base address of the context from the sms base address */
+	context_phy_address = (void __iomem *)SMS_CONTEXT_BASE(context);
+
+	/* Get the virtual address from the physical address */
+	context_virt_address = ioremap_nocache(
+			(unsigned long)context_phy_address, SZ_1K);
+
+	if (bytes_per_pixel > 4)
+		return -EINVAL;
+
+	page_width_exp = PAGE_WIDTH_EXP;
+	page_height_exp = PAGE_HEIGHT_EXP;
+	pixel_size_exp = bytes_per_pixel >> 1;
+
+	width = ((1 << page_width_exp) *
+			(pages_per_side(width * bytes_per_pixel,
+			page_width_exp))) >> pixel_size_exp;
+
+	height = (1 << page_height_exp) *
+		(pages_per_side(height, page_height_exp));
+
+	/* Program the context physical address register with the
+	 * physical address of the buffer */
+	reg_address = SMS_ROT0_PHYSICAL_BA(context_virt_address);
+	__raw_writel(phy_addr, reg_address);
+
+	/* program the image size and image height */
+	reg_address = SMS_ROT0_SIZE(context_virt_address);
+	__raw_writel(0, reg_address);
+	__raw_writel((width << SMS_IMAGEWIDTH_OFFSET)
+			| (height << SMS_IMAGEHEIGHT_OFFSET), reg_address);
+
+	/* Program the context control register with required values */
+	reg_address = SMS_ROT_CONTROL(context_virt_address);
+	__raw_writel(0, reg_address);
+	__raw_writel(pixel_size_exp << SMS_PS_OFFSET
+			| (page_width_exp - pixel_size_exp) << SMS_PW_OFFSET
+			| page_height_exp << SMS_PH_OFFSET, reg_address);
+
+	iounmap(context_virt_address);
+
+	return 0;
+}
+
+/* Buffer setup function is called by videobuf layer when REQBUF ioctl is
+ * called. This is used to setup buffers and return size and count of
+ * buffers allocated. After the call to this buffer, videobuf layer will
+ * setup buffer queue depending on the size and count of buffers
+ */
+static int
+omap_vout_buffer_setup(struct videobuf_queue *q, unsigned int *count,
+			  unsigned int *size)
+{
+	struct omap_vout_fh *fh = (struct omap_vout_fh *) q->priv_data;
+	struct omap_vout_device *vout = fh->vout;
+	int startindex = 0, i, j;
+	u32 phy_addr = 0, virt_addr = 0;
+
+	if (!vout)
+		return -EINVAL;
+
+	if (V4L2_BUF_TYPE_VIDEO_OUTPUT != q->type)
+		return -EINVAL;
+
+	startindex = (vout->vid == OMAP_VIDEO1) ?
+		video1_numbuffers : video2_numbuffers;
+	if (V4L2_MEMORY_MMAP == vout->memory && *count < startindex)
+		*count = startindex;
+
+	if(vout->rotation != -1 && *count > 4)
+		*count = 4;
+
+	/* If rotation is enabled, allocate memory for VRFB space also */
+	if (vout->rotation >= 0) {
+		for (i = 0; i < *count; i++) {
+			if (!vout->smsshado_virt_addr[i]) {
+				vout->smsshado_virt_addr[i] =
+				omap_vout_alloc_buffer(vout->smsshado_size,
+				&vout->smsshado_phy_addr[i]);
+			}
+
+			if (!vout->smsshado_virt_addr[i]) {
+				if (V4L2_MEMORY_MMAP == vout->memory
+				    && i >= startindex)
+					break;
+				for (j = 0; j < i; j++) {
+					omap_vout_free_buffer(
+						vout->smsshado_virt_addr[j],
+						vout->smsshado_phy_addr[j],
+						vout->smsshado_size);
+					vout->smsshado_virt_addr[j] = 0;
+					vout->smsshado_phy_addr[j] = 0;
+				}
+				*count = 0;
+				return -ENOMEM;
+			}
+
+			memset((void *) vout->smsshado_virt_addr[i], 0,
+			       vout->smsshado_size);
+
+			if (vout->rotation == 90 || vout->rotation == 270) {
+				omap_vout_set_vrfb(vout->vrfb_context[i],
+					vout->smsshado_phy_addr[i],
+					vout->pix.height,
+					vout->pix.width,
+					vout->bpp * vout->vrfb_bpp);
+			} else {
+				omap_vout_set_vrfb(vout->vrfb_context[i],
+					vout->smsshado_phy_addr[i],
+					vout->pix.width,
+					vout->pix.height,
+					vout->bpp * vout->vrfb_bpp);
+			}
+		}
+	}
+
+	if (V4L2_MEMORY_MMAP != vout->memory)
+		return 0;
+
+	*size = vout->buffer_size;
+	startindex = (vout->vid == OMAP_VIDEO1) ?
+		video1_numbuffers : video2_numbuffers;
+	for (i = startindex; i < *count; i++) {
+		vout->buffer_size = *size;
+
+		virt_addr = omap_vout_alloc_buffer(vout->buffer_size,
+				&phy_addr);
+		if (!virt_addr) {
+			if (vout->rotation < 0)
+				break;
+			for (j = i; j < *count; j++) {
+				omap_vout_free_buffer(
+					vout->smsshado_virt_addr[j],
+					vout->smsshado_phy_addr[j],
+					vout->smsshado_size);
+				vout->smsshado_virt_addr[j] = 0;
+				vout->smsshado_phy_addr[j] = 0;
+			}
+		}
+		vout->buf_virt_addr[i] = virt_addr;
+		vout->buf_phy_addr[i] = phy_addr;
+	}
+
+	*count = vout->buffer_allocated = i;
+	return 0;
+}
+
+/* This function will be called when VIDIOC_QBUF ioctl is called.
+ * It prepare buffers before give out for the display. This function
+ * user space virtual address into physical address if userptr memory
+ * exchange mechanism is used. If rotation is enabled, it copies entire
+ * buffer into VRFB memory space before giving it to the DSS.
+ */
+#define MAX_PIXELS_PER_LINE     2048
+#define VRFB_TX_TIMEOUT         1000
+static int
+omap_vout_buffer_prepare(struct videobuf_queue *q,
+			    struct videobuf_buffer *vb,
+			    enum v4l2_field field)
+{
+	struct omap_vout_fh *fh = (struct omap_vout_fh *) q->priv_data;
+	struct omap_vout_device *vout = fh->vout;
+	u32 dest_frame_index = 0, src_element_index = 0;
+	u32 dest_element_index = 0, src_frame_index = 0;
+	u32 elem_count = 0, frame_count = 0, pixsize = 2;
+	struct videobuf_dmabuf *dmabuf = NULL;
+
+	if (VIDEOBUF_NEEDS_INIT == vb->state) {
+		vb->width = vout->pix.width;
+		vb->height = vout->pix.height;
+		vb->size = vb->width * vb->height * vout->bpp;
+		vb->field = field;
+	}
+	vb->state = VIDEOBUF_PREPARED;
+	/* if user pointer memory mechanism is used, get the physical
+	 * address of the buffer
+	 */
+	if (V4L2_MEMORY_USERPTR == vb->memory) {
+		if (0 == vb->baddr)
+			return -EINVAL;
+		/* Virtual address */
+		/* priv points to struct videobuf_pci_sg_memory. But we went
+		 * pointer to videobuf_dmabuf, which is member of
+		 * videobuf_pci_sg_memory */
+		dmabuf = videobuf_to_dma(q->bufs[vb->i]);
+		dmabuf->vmalloc = (void *) vb->baddr;
+
+		/* Physical address */
+		dmabuf->bus_addr =
+			(dma_addr_t) omap_vout_uservirt_to_phys(vb->baddr);
+	}
+
+	if (vout->rotation >= 0) {
+		dmabuf = videobuf_to_dma(q->bufs[vb->i]);
+		/* If rotation is enabled, copy input buffer into VRFB
+		 * memory space using DMA. We are copying input buffer
+		 * into VRFB memory space of desired angle and DSS will
+		 * read image VRFB memory for 0 degree angle
+		 */
+		pixsize = vout->bpp * vout->vrfb_bpp;
+		/*
+		 * DMA transfer in double index mode
+		 */
+
+		/* Frame index */
+		dest_frame_index = ((MAX_PIXELS_PER_LINE * pixsize) -
+				    (vout->pix.width * vout->bpp)) + 1;
+
+		/* Source and destination parameters */
+		src_element_index = 0;
+		src_frame_index = 0;
+		dest_element_index = 1;
+		/* Number of elements per frame */
+		elem_count = vout->pix.width * vout->bpp;
+		frame_count = vout->pix.height;
+		vout->vrfb_dma_tx.tx_status = 0;
+		omap_set_dma_transfer_params(vout->vrfb_dma_tx.dma_ch,
+					     OMAP_DMA_DATA_TYPE_S32,
+					     (elem_count / 4), frame_count,
+					     OMAP_DMA_SYNC_ELEMENT,
+					     vout->vrfb_dma_tx.dev_id,
+					     0x0);
+		/* src_port required only for OMAP1 */
+		omap_set_dma_src_params(vout->vrfb_dma_tx.dma_ch, 0,
+					OMAP_DMA_AMODE_POST_INC,
+					dmabuf->bus_addr,
+					src_element_index,
+					src_frame_index);
+		/*set dma source burst mode for VRFB */
+		omap_set_dma_src_burst_mode(vout->vrfb_dma_tx.dma_ch,
+					    OMAP_DMA_DATA_BURST_16);
+		/* dest_port required only for OMAP1 */
+		omap_set_dma_dest_params(vout->vrfb_dma_tx.dma_ch, 0,
+			 OMAP_DMA_AMODE_DOUBLE_IDX,
+			 vout->sms_rot_phy[vb->i][vout->rotation / 90],
+			 dest_element_index, dest_frame_index);
+		/*set dma dest burst mode for VRFB */
+		omap_set_dma_dest_burst_mode(vout->vrfb_dma_tx.dma_ch,
+					     OMAP_DMA_DATA_BURST_16);
+		omap_dma_set_global_params(DMA_DEFAULT_ARB_RATE, 0x20, 0);
+
+		omap_start_dma(vout->vrfb_dma_tx.dma_ch);
+		interruptible_sleep_on_timeout(&vout->vrfb_dma_tx.wait,
+					       VRFB_TX_TIMEOUT);
+
+		if (vout->vrfb_dma_tx.tx_status == 0) {
+			omap_stop_dma(vout->vrfb_dma_tx.dma_ch);
+			return -EINVAL;
+		}
+		/* Store buffers physical address into an array. Addresses
+		 * from this array will be used to configure DSS */
+		vout->queued_buf_addr[vb->i] =
+			(u8 *) vout->sms_rot_phy[vb->i][0];
+		} else {
+			dmabuf = videobuf_to_dma(q->bufs[vb->i]);
+
+			vout->queued_buf_addr[vb->i] = (u8 *) dmabuf->bus_addr;
+		}
+		return 0;
+}
+
+/* Buffer queue funtion will be called from the videobuf layer when _QBUF
+ * ioctl is called. It is used to enqueue buffer, which is ready to be
+ * displayed. */
+static void
+omap_vout_buffer_queue(struct videobuf_queue *q,
+			  struct videobuf_buffer *vb)
+{
+	struct omap_vout_fh *fh =
+	    (struct omap_vout_fh *) q->priv_data;
+	struct omap_vout_device *vout = fh->vout;
+
+	/* Driver is also maintainig a queue. So enqueue buffer in the driver
+	 * queue */
+	list_add_tail(&vb->queue, &vout->dma_queue);
+
+	vb->state = VIDEOBUF_PREPARED;
+}
+
+/* Buffer release function is called from videobuf layer to release buffer
+ * which are already allocated */
+static void
+omap_vout_buffer_release(struct videobuf_queue *q,
+			    struct videobuf_buffer *vb)
+{
+	struct omap_vout_fh *fh = (struct omap_vout_fh *) q->priv_data;
+	struct omap_vout_device *vout = fh->vout;
+
+	vb->state = VIDEOBUF_NEEDS_INIT;
+
+	if (V4L2_MEMORY_MMAP != vout->memory)
+		return;
+}
+
+/* VRFB offset computation parameters */
+#define SIDE_H                  1
+#define SIDE_W                  0
+
+/* SDRAM page size parameters used for VRFB settings */
+#define PAGE_WIDTH_EXP          5       /* page width = 1 << PAGE_WIDTH_EXP */
+#define PAGE_HEIGHT_EXP         5       /* page height = 1 << PAGE_HEIGHT_EXP */
+
+static int omap_disp_get_vrfb_offset(u32 img_len, u32 bytes_per_pixel, int side)
+{
+	int page_width_exp, page_height_exp, pixel_size_exp, offset = 0;
+
+	/* Maximum supported is 4 bytes (RGB32) */
+	if (bytes_per_pixel > 4)
+		return -EINVAL;
+
+	page_width_exp = PAGE_WIDTH_EXP;
+	page_height_exp = PAGE_HEIGHT_EXP;
+	pixel_size_exp = bytes_per_pixel >> 1;
+
+	if (side == SIDE_W) {
+		offset = ((1 << page_width_exp) *
+			(pages_per_side(img_len *
+			bytes_per_pixel, page_width_exp))) >> pixel_size_exp;
+		/* in pixels */
+	} else {
+		offset = (1 << page_height_exp) *
+			(pages_per_side(img_len, page_height_exp));
+	}
+
+	return offset;
+}
+EXPORT_SYMBOL(omap_disp_get_vrfb_offset);
+
+static int omap_vout_calculate_offset(struct omap_vout_device *vout)
+{
+	struct v4l2_pix_format *pix = &(vout->pix);
+	struct v4l2_rect *crop = &(vout->crop);
+	struct v4l2_window *win = &(vout->win);
+	int rotation_deg;
+	int mirroring = vout->mirror;
+	int vr_ps = 1, ps = 2, temp_ps = 2;
+	int offset = 0, ctop = 0, cleft = 0, line_length = 0;
+	struct omapvideo_info *ovid;
+	struct omap_overlay *ovl;
+	struct omap_display *cur_display;
+	int *cropped_offset = &(vout->cropped_offset);
+
+	ovid = &(vout->vid_info);
+	ovl = ovid->overlays[0];
+	/* get the display device attached to the overlay */
+	cur_display = ovl->manager->display;
+
+	if ((cur_display->type == OMAP_DISPLAY_TYPE_VENC) &&
+	    ((win->w.width == crop->width)
+	     && (win->w.height == crop->height)))
+		vout->flicker_filter = 1;
+	else
+		vout->flicker_filter = 0;
+
+	if (1 == vout->mirror && vout->rotation >= 0) {
+		rotation_deg = (vout->rotation == 90) ?
+			270 : (vout->rotation == 270) ?
+			90 : (vout->rotation ==  180) ?
+			0 : 180;
+
+	} else if (vout->rotation >= 0) {
+		rotation_deg = vout->rotation;
+	} else {
+		rotation_deg = -1;
+	}
+
+	if (V4L2_PIX_FMT_YUYV == pix->pixelformat ||
+	    V4L2_PIX_FMT_UYVY == pix->pixelformat) {
+		if (rotation_deg >= 0 || mirroring == 1) {
+			/*
+			 * ps    - Actual pixel size for YUYV/UYVY for
+			 *              VRFB/Mirroring is 4 bytes
+			 * vr_ps - Virtually pixel size for YUYV/UYVY is
+			 *              2 bytes
+			 */
+			ps = 4;
+			vr_ps = 2;
+		} else {
+			ps = 2;	/* otherwise the pixel size is 2 byte */
+		}
+	} else if (V4L2_PIX_FMT_RGB32 == pix->pixelformat) {
+		ps = 4;
+	} else if (V4L2_PIX_FMT_RGB24 == pix->pixelformat) {
+		ps = 3;
+	}
+	vout->ps = ps;
+	vout->vr_ps = vr_ps;
+	if (rotation_deg >= 0) {
+		line_length = MAX_PIXELS_PER_LINE;
+		ctop = (pix->height - crop->height) - crop->top;
+		cleft = (pix->width - crop->width) - crop->left;
+	} else {
+		line_length = pix->width;
+	}
+	vout->line_length = line_length;
+	switch (rotation_deg) {
+	case 90:
+		offset = (omap_disp_get_vrfb_offset(pix->width, ps, SIDE_H) -
+				(pix->width / vr_ps)) * ps * line_length;
+		temp_ps = ps / vr_ps;
+		if (mirroring == 0) {
+			*cropped_offset = offset + line_length *
+				temp_ps * cleft + crop->top * temp_ps;
+		} else {
+			*cropped_offset = offset + line_length * temp_ps *
+				cleft + crop->top * temp_ps + (line_length *
+				((crop->width / (vr_ps)) - 1) * ps);
+		}
+		break;
+
+	case 180:
+		offset = (omap_disp_get_vrfb_offset(pix->height, ps, SIDE_H) -
+				pix->height) * ps * line_length +
+				(omap_disp_get_vrfb_offset(pix->width,
+				ps, SIDE_W) - (pix->width / vr_ps)) * ps;
+		if (mirroring == 0) {
+			*cropped_offset = offset + (line_length * ps * ctop) +
+				(cleft / vr_ps) * ps;
+		} else {
+			*cropped_offset = offset + (line_length * ps * ctop) +
+				(cleft / vr_ps) * ps + (line_length *
+				(crop->height - 1) * ps);
+		}
+		break;
+
+	case 270:
+		offset = (omap_disp_get_vrfb_offset(pix->height, ps, SIDE_W) -
+				pix->height) * ps;
+		temp_ps = ps / vr_ps;
+		if (mirroring == 0) {
+			*cropped_offset = offset + line_length *
+			    temp_ps * crop->left + ctop * ps;
+		} else {
+			*cropped_offset = offset + line_length *
+				temp_ps * crop->left + ctop * ps +
+				(line_length * ((crop->width / vr_ps) - 1) *
+				 ps);
+		}
+		break;
+	case 0:
+		if (mirroring == 0) {
+			*cropped_offset = (line_length * ps) *
+				crop->top + (crop->left / vr_ps) * ps;
+		} else {
+			*cropped_offset = (line_length * ps) *
+				crop->top + (crop->left / vr_ps) * ps +
+				(line_length * (crop->height - 1) * ps);
+		}
+		break;
+	default:
+		if (mirroring == 0) {
+			*cropped_offset =
+			    line_length * ps * crop->top + crop->left * ps;
+		} else {
+			*cropped_offset = (line_length * ps * crop->top) /
+				vr_ps + (crop->left * ps) / vr_ps +
+				((crop->width / vr_ps) - 1) * ps;
+		}
+		break;
+	}
+
+	if (vout->flicker_filter == 1)
+		vout->tv_field1_offset = 0;
+	else if (vout->rotation >= 0) {
+		if (vout->mirror == 1)
+			vout->tv_field1_offset = -vout->line_length * vout->ps;
+		else
+			vout->tv_field1_offset = vout->line_length * vout->ps;
+	} else {
+		if (vout->mirror == 1)
+			vout->tv_field1_offset = vout->line_length
+				* vout->ps / vout->vr_ps;
+		else
+			vout->tv_field1_offset = vout->line_length * vout->ps;
+	}
+	return 0;
+}
+
+/*
+ *  file operations
+ */
+static void omap_vout_vm_open(struct vm_area_struct *vma)
+{
+	struct omap_vout_device *vout = vma->vm_private_data;
+	DPRINTK("vm_open [vma=%08lx-%08lx]\n", vma->vm_start, vma->vm_end);
+	vout->mmap_count++;
+}
+
+static void omap_vout_vm_close(struct vm_area_struct *vma)
+{
+	struct omap_vout_device *vout = vma->vm_private_data;
+	DPRINTK("vm_close [vma=%08lx-%08lx]\n", vma->vm_start, vma->vm_end);
+	vout->mmap_count--;
+}
+
+static struct vm_operations_struct omap_vout_vm_ops = {
+	.open = omap_vout_vm_open,
+	.close = omap_vout_vm_close,
+};
+
+static int omap_vout_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct omap_vout_fh *fh = file->private_data;
+	struct omap_vout_device *vout = fh->vout;
+	struct videobuf_queue *q = &fh->vbq;
+	unsigned long size = (vma->vm_end - vma->vm_start);
+	unsigned long start = vma->vm_start;
+	int i;
+	void *pos;
+	struct videobuf_dmabuf *dmabuf = NULL;
+
+	DPRINTK("pgoff=0x%lx, start=0x%lx, end=0x%lx\n", vma->vm_pgoff,
+		vma->vm_start, vma->vm_end);
+
+	/* look for the buffer to map */
+	for (i = 0; i < VIDEO_MAX_FRAME; i++) {
+		if (NULL == q->bufs[i])
+			continue;
+		if (V4L2_MEMORY_MMAP != q->bufs[i]->memory)
+			continue;
+		if (q->bufs[i]->boff == (vma->vm_pgoff << PAGE_SHIFT))
+			break;
+	}
+
+	if (VIDEO_MAX_FRAME == i) {
+		DPRINTK("offset invalid [offset=0x%lx]\n",
+			(vma->vm_pgoff << PAGE_SHIFT));
+		return -EINVAL;
+	}
+	q->bufs[i]->baddr = vma->vm_start;
+
+	vma->vm_flags |= VM_RESERVED;
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+	vma->vm_ops = &omap_vout_vm_ops;
+	vma->vm_private_data = (void *) vout;
+	dmabuf = videobuf_to_dma(q->bufs[i]);
+	pos = dmabuf->vmalloc;
+	while (size > 0) {
+		unsigned long pfn;
+		pfn = virt_to_phys((void *) pos) >> PAGE_SHIFT;
+		if (remap_pfn_range(vma, start, pfn, PAGE_SIZE, PAGE_SHARED))
+			return -EAGAIN;
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	vout->mmap_count++;
+	return 0;
+}
+
+static void omap_vout_free_allbuffers(struct omap_vout_device *vout)
+{
+	int num_buffers = 0, i;
+	num_buffers = (vout->vid == OMAP_VIDEO1) ?
+	    video1_numbuffers : video2_numbuffers;
+	for (i = num_buffers; i < vout->buffer_allocated; i++) {
+		if (vout->buf_virt_addr[i]) {
+			omap_vout_free_buffer(vout->buf_virt_addr[i],
+				 vout->buf_phy_addr[i], vout->buffer_size);
+		}
+		vout->buf_virt_addr[i] = 0;
+		vout->buf_phy_addr[i] = 0;
+	}
+	for (i = 0; i < 4; i++) {
+		if (vout->smsshado_virt_addr[i]) {
+			omap_vout_free_buffer(vout->smsshado_virt_addr[i],
+					vout->smsshado_phy_addr[i],
+					vout->smsshado_size);
+			vout->smsshado_virt_addr[i] = 0;
+			vout->smsshado_phy_addr[i] = 0;
+		}
+	}
+	vout->buffer_allocated = num_buffers;
+}
+
+static int omap_vout_release(struct inode *inode, struct file *file)
+{
+
+	struct omap_vout_fh *fh = file->private_data;
+	struct omap_vout_device *vout;
+	struct videobuf_queue *q;
+	unsigned int t;
+	struct omapvideo_info *ovid;
+	unsigned int r;
+
+	vout = fh->vout;
+
+	printk("vout = %x\n", vout);
+
+	ovid = &(vout->vid_info);
+	if (fh == 0)
+		return 0;
+	if (!vout)
+		return 0;
+	q = &fh->vbq;
+
+	printk("vout = %x\n", vout);
+	/* Disable all the overlay managers connected with this interface */
+	for (t = 0; t < ovid->num_overlays; t++) {
+			struct omap_overlay *ovl = ovid->overlays[t];
+			if (ovl->manager && ovl->manager->display)
+				ovl->enable(ovl, 0);
+		}
+
+	r = omapvid_apply_changes(vout, 0, 0);
+		if (r)
+			printk(KERN_ERR VOUT_NAME "failed to change mode\n");
+
+	/* Even if apply changes fails we should continue
+	   freeing allocated memeory */
+	if (fh->io_allowed) {
+		videobuf_streamoff(q);
+		videobuf_queue_cancel(q);
+		/* Free all buffers */
+		omap_vout_free_allbuffers(vout);
+		videobuf_mmap_free(q);
+	}
+
+	//printk("%s %d\n", __func__, __LINE__);
+	if (vout->streaming == fh) {
+		printk("Deregistering isr\n\n");
+		omap_dispc_unregister_isr(vout->isr_handle);
+		printk("vout = %x\n", vout);
+		vout->streaming = NULL;
+	}
+#if 1
+	if (vout->mmap_count != 0)
+		vout->mmap_count = 0;
+
+	vout->opened -= 1;
+	file->private_data = NULL;
+
+	if (vout->buffer_allocated)
+		videobuf_mmap_free(q);
+
+	kfree(fh);
+
+	return r;
+#endif
+	return 0;
+}
+
+static int omap_vout_open(struct inode *inode, struct file *file)
+{
+	int minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	struct omap_vout_device *vout = NULL;
+	struct omap_vout_fh *fh;
+	struct videobuf_queue *q;
+
+	DPRINTK("entering\n");
+
+	if (saved_v1out && saved_v1out->vfd
+	    && (saved_v1out->vfd->minor == minor)) {
+		vout = saved_v1out;
+	}
+
+	if (vout == NULL) {
+		if (saved_v2out && saved_v2out->vfd
+		    && (saved_v2out->vfd->minor == minor)) {
+			vout = saved_v2out;
+		}
+	}
+
+	if (vout == NULL)
+		return -ENODEV;
+
+	/* for now, we only support single open */
+	if (vout->opened)
+		return -EBUSY;
+
+	vout->opened += 1;
+
+	fh = kmalloc(sizeof(*fh), GFP_KERNEL);
+	if (NULL == fh)
+		return -ENOMEM;
+	memset(fh, 0, sizeof(*fh));
+
+	file->private_data = fh;
+	fh->vout = vout;
+	fh->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+
+	q = &fh->vbq;
+	video_vbq_ops.buf_setup = omap_vout_buffer_setup;
+	video_vbq_ops.buf_prepare = omap_vout_buffer_prepare;
+	video_vbq_ops.buf_release = omap_vout_buffer_release;
+	video_vbq_ops.buf_queue = omap_vout_buffer_queue;
+	spin_lock_init(&vout->vbq_lock);
+
+	videobuf_queue_sg_init(q, &video_vbq_ops, NULL, &vout->vbq_lock,
+			       fh->type, V4L2_FIELD_NONE, sizeof
+			       (struct videobuf_buffer), fh);
+
+	return 0;
+}
+
+static int vidioc_querycap(struct file *file, void *fh,
+		struct v4l2_capability *cap)
+{
+	struct omap_vout_device *vout = ((struct omap_vout_fh *) fh)->vout;
+
+	memset(cap, 0, sizeof(*cap));
+	strncpy(cap->driver, VOUT_NAME,
+		sizeof(cap->driver));
+	strncpy(cap->card, vout->vfd->name, sizeof(cap->card));
+	cap->bus_info[0] = '\0';
+	cap->capabilities = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_OUTPUT;
+	return 0;
+}
+static int vidioc_enum_fmt_vid_out(struct file *file, void *fh,
+			struct v4l2_fmtdesc *fmt)
+{
+	int index = fmt->index;
+	enum v4l2_buf_type type = fmt->type;
+
+	memset(fmt, 0, sizeof(*fmt));
+	fmt->index = index;
+	fmt->type = type;
+	if (index >= NUM_OUTPUT_FORMATS)
+		return -EINVAL;
+
+	fmt->flags = omap_formats[index].flags;
+	strncpy(fmt->description, omap_formats[index].description,
+			sizeof(fmt->description));
+	fmt->pixelformat = omap_formats[index].pixelformat;
+	return 0;
+}
+static int vidioc_g_fmt_vid_out(struct file *file, void *fh,
+			struct v4l2_format *f)
+{
+	struct omap_vout_device *vout = ((struct omap_vout_fh *) fh)->vout;
+
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	memset(pix, 0, sizeof(*pix));
+	*pix = vout->pix;
+	return 0;
+
+}
+
+static int vidioc_try_fmt_vid_out(struct file *file, void *fh,
+			struct v4l2_format *f)
+{
+	struct omap_vout_device *vout = ((struct omap_vout_fh *) fh)->vout;
+	struct omapvideo_info *ovid;
+	struct omap_overlay *ovl;
+	struct omap_video_timings *timing;
+
+	if (vout->streaming)
+		return -EBUSY;
+
+	ovid = &(vout->vid_info);
+	ovl = ovid->overlays[0];
+	/* get the display device attached to the overlay */
+	timing = &ovl->manager->display->panel->timings;
+
+	vout->fbuf.fmt.height = timing->y_res;
+	vout->fbuf.fmt.width = timing->x_res;
+
+	omap_vout_try_format(&f->fmt.pix, &vout->fbuf.fmt);
+	return 0;
+}
+
+static int vidioc_s_fmt_vid_out(struct file *file, void *fh,
+			struct v4l2_format *f)
+{
+	struct omap_vout_fh *ofh = (struct omap_vout_fh *)fh;
+	struct omap_vout_device *vout = ofh->vout;
+	int bpp;
+	int r;
+	struct omapvideo_info *ovid;
+	struct omap_overlay *ovl;
+	struct omap_video_timings *timing;
+
+	if (vout->streaming)
+		return -EBUSY;
+
+	if (down_interruptible(&vout->lock))
+		return -EINVAL;
+
+	ovid = &(vout->vid_info);
+	ovl = ovid->overlays[0];
+	/* get the display device attached to the overlay */
+	timing = &ovl->manager->display->panel->timings;
+	/* We dont support RGB24-packed mode if vrfb rotation
+	 * is enabled*/
+	if (vout->rotation != -1
+			&& f->fmt.pix.pixelformat == V4L2_PIX_FMT_RGB24) {
+		up(&vout->lock);
+		return -EINVAL;
+	}
+
+	/* get the framebuffer parameters */
+
+	if (vout->rotation == 90 || vout->rotation == 270) {
+		vout->fbuf.fmt.height = timing->x_res;
+		vout->fbuf.fmt.width = timing->y_res;
+	} else {
+		vout->fbuf.fmt.height = timing->y_res;
+		vout->fbuf.fmt.width = timing->x_res;
+	}
+
+	/* change to samller size is OK */
+
+	bpp = omap_vout_try_format(&f->fmt.pix, &vout->fbuf.fmt);
+	f->fmt.pix.sizeimage = f->fmt.pix.width * f->fmt.pix.height * bpp;
+
+	/* try & set the new output format */
+	vout->bpp = bpp;
+	vout->pix = f->fmt.pix;
+	vout->vrfb_bpp = 1;
+
+	/* If YUYV then vrfb bpp is 2, for  others its 1 */
+	if (V4L2_PIX_FMT_YUYV == vout->pix.pixelformat ||
+		V4L2_PIX_FMT_UYVY == vout->pix.pixelformat)
+		vout->vrfb_bpp = 2;
+
+	/* set default crop and win */
+	omap_vout_new_format(&vout->pix, &vout->fbuf, &vout->crop, &vout->win);
+
+	/* Save the changes in the overlay strcuture */
+	r = omapvid_apply_changes(vout, 0, 0);
+		if (r)
+			printk(KERN_ERR VOUT_NAME "failed to change mode\n");
+
+	up(&vout->lock);
+	return 0;
+}
+
+static int vidioc_try_fmt_vid_overlay(struct file *file, void *fh,
+			struct v4l2_format *f)
+{
+	int err = -EINVAL;
+	struct omap_vout_device *vout = ((struct omap_vout_fh *) fh)->vout;
+	struct v4l2_window *win = &f->fmt.win;
+
+	err = omap_vout_try_window(&vout->fbuf, win);
+	return err;
+}
+
+static int vidioc_s_fmt_vid_overlay(struct file *file, void *fh,
+			struct v4l2_format *f)
+{
+	struct omap_vout_device *vout = ((struct omap_vout_fh *) fh)->vout;
+	int err = -EINVAL;
+	struct v4l2_window *win = &f->fmt.win;
+
+	err = omap_vout_new_window(&vout->crop, &vout->win, &vout->fbuf, win);
+	up(&vout->lock);
+	return err;
+}
+
+static int vidioc_enum_fmt_vid_overlay(struct file *file, void *fh,
+			struct v4l2_fmtdesc *fmt)
+{
+	int index = fmt->index;
+	enum v4l2_buf_type type = fmt->type;
+
+	memset(fmt, 0, sizeof(*fmt));
+	fmt->index = index;
+	fmt->type = type;
+	if (index >= NUM_OUTPUT_FORMATS)
+		return -EINVAL;
+
+	fmt->flags = omap_formats[index].flags;
+	strncpy(fmt->description, omap_formats[index].description,
+		sizeof(fmt->description));
+	fmt->pixelformat = omap_formats[index].pixelformat;
+	return 0;
+}
+
+static int vidioc_g_fmt_vid_overlay(struct file *file, void *fh,
+			struct v4l2_format *f)
+{
+	struct omap_vout_device *vout = ((struct omap_vout_fh *) fh)->vout;
+
+	struct v4l2_window *win = &f->fmt.win;
+	memset(win, 0, sizeof(*win));
+
+	/*
+	 * The API has a bit of a problem here.
+	 * We're returning a v4l2_window
+	 * structure, but that structure
+	 * contains pointers to variable-sized
+	 * objects for clipping rectangles and
+	 * clipping bitmaps.  We will just
+	 * return NULLs for those pointers.
+	 */
+	win->w = vout->win.w;
+	win->field = vout->win.field;
+	win->chromakey = vout->win.chromakey;
+	return 0;
+}
+
+static int vidioc_cropcap(struct file *file, void *fh,
+			struct v4l2_cropcap *cropcap)
+{
+	struct omap_vout_device *vout = ((struct omap_vout_fh *) fh)->vout;
+	enum v4l2_buf_type type = cropcap->type;
+
+	memset(cropcap, 0, sizeof(*cropcap));
+	cropcap->type = type;
+	if (type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		struct v4l2_pix_format *pix = &vout->pix;
+
+		/* Width and height are always even */
+		cropcap->bounds.width = pix->width & ~1;
+		cropcap->bounds.height = pix->height & ~1;
+
+		omap_vout_default_crop(&vout->pix,
+				&vout->fbuf, &cropcap->defrect);
+		cropcap->pixelaspect.numerator = 1;
+		cropcap->pixelaspect.denominator = 1;
+		return 0;
+	} else
+		return -EINVAL;
+}
+static int vidioc_g_crop(struct file *file, void *fh,
+	struct v4l2_crop *crop)
+{
+	struct omap_vout_device *vout = ((struct omap_vout_fh *) fh)->vout;
+
+	if (crop->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		crop->c = vout->crop;
+		return 0;
+	} else
+		return -EINVAL;
+}
+static int vidioc_s_crop(struct file *file, void *fh,
+			struct v4l2_crop *crop)
+{
+	struct omap_vout_device *vout = ((struct omap_vout_fh *) fh)->vout;
+	int err = -EINVAL;
+	struct omapvideo_info *ovid;
+	struct omap_overlay *ovl;
+	struct omap_video_timings *timing;
+
+	if (vout->streaming)
+		return -EBUSY;
+
+	if (down_interruptible(&vout->lock))
+		return -EINVAL;
+
+	ovid = &(vout->vid_info);
+	ovl = ovid->overlays[0];
+	/* get the display device attached to the overlay */
+	timing = &ovl->manager->display->panel->timings;
+
+	if (vout->rotation == 90 || vout->rotation == 270) {
+		vout->fbuf.fmt.height = timing->x_res;
+		vout->fbuf.fmt.width = timing->y_res;
+	} else {
+		vout->fbuf.fmt.height = timing->y_res;
+		vout->fbuf.fmt.width = timing->x_res;
+	}
+
+	if (crop->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		err = omap_vout_new_crop(&vout->pix, &vout->crop, &vout->win,
+			&vout->fbuf, &crop->c);
+		up(&vout->lock);
+		return err;
+	} else {
+		up(&vout->lock);
+		return -EINVAL;
+	}
+}
+
+static int vidioc_queryctrl(struct file *file, void *fh,
+		struct v4l2_queryctrl *a)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(omap_vout_qctrl); i++)
+		if (a->id && a->id == omap_vout_qctrl[i].id) {
+			memcpy(a, &omap_vout_qctrl[i],
+					sizeof(struct v4l2_queryctrl));
+			return 0;
+		}
+	return -EINVAL;
+}
+
+static int vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *a)
+{
+	int i;
+	struct omap_vout_device *vout = ((struct omap_vout_fh *) fh)->vout;
+
+	for (i = 0; i < ARRAY_SIZE(omap_vout_qctrl); i++)
+		if (a->id && a->id == vout->control[i].id) {
+			a->value = vout->control[i].value;
+			return 0;
+		}
+	return -EINVAL;
+}
+
+static int vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *a)
+{
+	struct omap_vout_device *vout = ((struct omap_vout_fh *) fh)->vout;
+
+	switch (a->id) {
+	case V4L2_CID_ROTATION:
+		{
+			int rotation = a->value;
+
+			if (down_interruptible(&vout->lock))
+				return -EINVAL;
+			if ((rotation == 0) || (rotation == 90) ||
+			    (rotation == 180) || (rotation == 270)
+			    || (rotation == -1)) {
+				vout->rotation = (rotation == 90) ?
+					270 : (rotation == 270) ?
+					90 : rotation;
+				up(&vout->lock);
+				rotation_support = vout->rotation;
+				vout->control[0].value = vout->rotation;
+				return 0;
+			} else {
+				up(&vout->lock);
+				return -EINVAL;
+			}
+		}
+
+	default:
+		return -EINVAL;
+	}
+
+}
+
+static int vidioc_reqbufs(struct file *file, void *fh,
+			struct v4l2_requestbuffers *req)
+{
+	struct omap_vout_device *vout = ((struct omap_vout_fh *) fh)->vout;
+	struct videobuf_queue *q = &(((struct omap_vout_fh *) fh)->vbq);
+	unsigned int i, num_buffers = 0;
+	int ret = 0;
+	struct videobuf_dmabuf *dmabuf = NULL;
+
+	if (down_interruptible(&vout->lock))
+		return -EINVAL;
+
+	if ((req->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) || (req->count < 0)) {
+		up(&vout->lock);
+		return -EINVAL;
+	}
+	/* if memory is not mmp or userptr
+	   return error */
+	if ((V4L2_MEMORY_MMAP != req->memory) &&
+		(V4L2_MEMORY_USERPTR != req->memory)) {
+		up(&vout->lock);
+		return -EINVAL;
+	}
+
+	/* Cannot be requested when streaming is on */
+	if (vout->streaming) {
+		up(&vout->lock);
+		return -EBUSY;
+	}
+
+	/* If buffers are already allocated free them */
+	if (q->bufs[0] && (V4L2_MEMORY_MMAP == q->bufs[0]->memory)) {
+		if (vout->mmap_count) {
+			up(&vout->lock);
+			return -EBUSY;
+		}
+		num_buffers = (vout->vid == OMAP_VIDEO1) ?
+			video1_numbuffers : video2_numbuffers;
+		for (i = num_buffers; i < vout->buffer_allocated; i++) {
+			dmabuf = videobuf_to_dma(q->bufs[i]);
+			omap_vout_free_buffer((u32)dmabuf->vmalloc,
+				dmabuf->bus_addr, vout->buffer_size);
+			vout->buf_virt_addr[i] = 0;
+			vout->buf_phy_addr[i] = 0;
+		}
+		vout->buffer_allocated = num_buffers;
+		videobuf_mmap_free(q);
+	} else if (q->bufs[0] && (V4L2_MEMORY_USERPTR == q->bufs[0]->memory)) {
+		if (vout->buffer_allocated) {
+			videobuf_mmap_free(q);
+			for (i = 0; i < vout->buffer_allocated; i++) {
+				kfree(q->bufs[i]);
+				q->bufs[i] = NULL;
+			}
+			vout->buffer_allocated = 0;
+		}
+	}
+	((struct omap_vout_fh *) fh)->io_allowed = 1;
+
+	/*store the memory type in data structure */
+	vout->memory = req->memory;
+
+	INIT_LIST_HEAD(&vout->dma_queue);
+
+	/* call videobuf_reqbufs api */
+	ret = videobuf_reqbufs(q, req);
+	if (ret < 0) {
+		up(&vout->lock);
+		return ret;
+	}
+
+	vout->buffer_allocated = req->count;
+	for (i = 0; i < req->count; i++) {
+		dmabuf = videobuf_to_dma(q->bufs[i]);
+		dmabuf->vmalloc = (void *) vout->buf_virt_addr[i];
+		dmabuf->bus_addr = (dma_addr_t) vout->buf_phy_addr[i];
+		dmabuf->sglen = 1;
+	}
+	up(&vout->lock);
+	return 0;
+}
+static int vidioc_querybuf(struct file *file, void *fh,
+			struct v4l2_buffer *b)
+{
+	return videobuf_querybuf(&(((struct omap_vout_fh *) fh)->vbq), b);
+}
+static int vidioc_qbuf(struct file *file, void *fh,
+			struct v4l2_buffer *buffer)
+{
+	struct omap_vout_fh *ofh = (struct omap_vout_fh *)fh;
+	struct omap_vout_device *vout = ofh->vout;
+	struct videobuf_queue *q = &ofh->vbq;
+	int ret = 0;
+
+	if (!ofh->io_allowed)
+		return -EINVAL;
+
+	timeout = HZ / 5;
+	timeout += jiffies;
+
+	if ((V4L2_BUF_TYPE_VIDEO_OUTPUT != buffer->type) ||
+			(buffer->index >= vout->buffer_allocated) ||
+			(q->bufs[buffer->index]->memory != buffer->memory)) {
+		return -EINVAL;
+	}
+	if (V4L2_MEMORY_USERPTR == buffer->memory) {
+		if ((buffer->length < vout->pix.sizeimage) ||
+			(0 == buffer->m.userptr)) {
+			return -EINVAL;
+		}
+	}
+
+	if (vout->rotation >= 0 &&
+			vout->vrfb_dma_tx.req_status == DMA_CHAN_NOT_ALLOTED) {
+		printk(KERN_WARNING "DMA Channel not allocated for Rotation\n");
+		return -EINVAL;
+	}
+
+	ret = videobuf_qbuf(q, buffer);
+	return ret;
+}
+static int vidioc_dqbuf(struct file *file, void *fh,
+			struct v4l2_buffer *b)
+{
+	struct omap_vout_fh *ofh = (struct omap_vout_fh *)fh;
+	struct omap_vout_device *vout = ofh->vout;
+	struct videobuf_queue *q = &ofh->vbq;
+	int ret = 0;
+
+
+	if (!vout->streaming || !ofh->io_allowed)
+		return -EINVAL;
+
+	if (file->f_flags & O_NONBLOCK)
+		/* Call videobuf_dqbuf for non blocking mode */
+		ret = videobuf_dqbuf(q, (struct v4l2_buffer *)b, 1);
+	else
+		/* Call videobuf_dqbuf for  blocking mode */
+		ret = videobuf_dqbuf(q, (struct v4l2_buffer *)b, 0);
+	return ret;
+}
+#define DISPC_IRQSTATUS_VSYNC                           (1 <<  1)
+#define DISPC_IRQENABLE_EVSYNC_ODD                      (1 <<  3)
+#define DISPC_IRQENABLE_EVSYNC_EVEN                     (1 <<  2)
+
+static int vidioc_streamon(struct file *file, void *fh,
+			enum v4l2_buf_type i)
+{
+	struct omap_vout_fh *ofh = (struct omap_vout_fh *)fh;
+	struct omap_vout_device *vout = ofh->vout;
+	struct videobuf_queue *q = &ofh->vbq;
+	u32 addr = 0;
+	int r = 0;
+	void *handle = NULL;
+	int t;
+	struct omapvideo_info *ovid = &(vout->vid_info);
+	u32 mask = 0;
+
+	if (down_interruptible(&vout->lock))
+		return -EINVAL;
+	if (!ofh->io_allowed) {
+		up(&vout->lock);
+		return -EINVAL;
+	}
+
+	if (vout->streaming) {
+		up(&vout->lock);
+		return -EBUSY;
+	}
+
+	r = videobuf_streamon(q);
+	if (r < 0) {
+		up(&vout->lock);
+		return r;
+	}
+
+	if (list_empty(&vout->dma_queue)) {
+		up(&vout->lock);
+		return -EIO;
+	}
+	/* Get the next frame from the buffer queue */
+	vout->nextFrm = vout->curFrm = list_entry(vout->dma_queue.next,
+				struct videobuf_buffer, queue);
+	/* Remove buffer from the buffer queue */
+	list_del(&vout->curFrm->queue);
+	/* Mark state of the current frame to active */
+	vout->curFrm->state = VIDEOBUF_ACTIVE;
+	/* Initialize field_id and started member */
+	vout->field_id = 0;
+
+	/* set flag here. Next QBUF will start DMA */
+	vout->streaming = ofh;
+
+	vout->first_int = 1;
+
+	omap_vout_calculate_offset(vout);
+	addr = (unsigned long) vout->queued_buf_addr[vout->curFrm->i] +
+		vout->cropped_offset;
+
+	mask = DISPC_IRQENABLE_EVSYNC_ODD | DISPC_IRQENABLE_EVSYNC_EVEN |
+			DISPC_IRQSTATUS_VSYNC;
+
+	handle = omap_dispc_register_isr(omap_vout_isr, vout, mask);
+	if(handle)
+		vout->isr_handle = handle;
+	else
+		return -EINVAL;
+
+	for (t = 0; t < ovid->num_overlays; t++) {
+		struct omap_overlay *ovl = ovid->overlays[t];
+		if (ovl->manager && ovl->manager->display)
+			ovl->enable(ovl, 1);
+	}
+
+	r = omapvid_apply_changes(vout, addr, 0);
+	if (r)
+		printk(KERN_ERR VOUT_NAME "failed to change mode\n");
+
+	up(&vout->lock);
+	return 0;
+}
+static int vidioc_streamoff(struct file *file, void *fh,
+			enum v4l2_buf_type i)
+{
+
+	struct omap_vout_fh *ofh = (struct omap_vout_fh *)fh;
+	struct omap_vout_device *vout = ofh->vout;
+	int t, r = 0;
+	struct omapvideo_info *ovid = &(vout->vid_info);
+
+	if (!ofh->io_allowed)
+		return -EINVAL;
+	if (!vout->streaming)
+		return -EINVAL;
+	if (vout->streaming == fh) {
+		vout->streaming = NULL;
+
+		printk("Derigistering ISR\n\n\n");
+		omap_dispc_unregister_isr(vout->isr_handle);
+
+		for (t = 0; t < ovid->num_overlays; t++) {
+			struct omap_overlay *ovl = ovid->overlays[t];
+			if (ovl->manager && ovl->manager->display)
+				ovl->enable(ovl, 0);
+		}
+
+		r = omapvid_apply_changes(vout, 0, 0);
+		if (r) {
+			printk(KERN_ERR VOUT_NAME "failed to change mode\n");
+			return r;
+		}
+	}
+	return 0;
+}
+
+static const struct v4l2_ioctl_ops vout_ioctl_ops = {
+	.vidioc_querycap      			= vidioc_querycap,
+	.vidioc_querycap	 			= vidioc_querycap,
+	.vidioc_enum_fmt_vid_out 		= vidioc_enum_fmt_vid_out,
+	.vidioc_g_fmt_vid_out			= vidioc_g_fmt_vid_out,
+	.vidioc_try_fmt_vid_out			= vidioc_try_fmt_vid_out,
+	.vidioc_s_fmt_vid_out			= vidioc_s_fmt_vid_out,
+	.vidioc_queryctrl    			= vidioc_queryctrl,
+	.vidioc_g_ctrl       			= vidioc_g_ctrl,
+	.vidioc_s_ctrl       			= vidioc_s_ctrl,
+	.vidioc_try_fmt_vid_overlay 	= vidioc_try_fmt_vid_overlay,
+	.vidioc_s_fmt_vid_overlay		= vidioc_s_fmt_vid_overlay,
+	.vidioc_enum_fmt_vid_overlay		= vidioc_enum_fmt_vid_overlay,
+	.vidioc_g_fmt_vid_overlay		= vidioc_g_fmt_vid_overlay,
+	.vidioc_cropcap					= vidioc_cropcap,
+	.vidioc_g_crop					= vidioc_g_crop,
+	.vidioc_s_crop					= vidioc_s_crop,
+	.vidioc_reqbufs					= vidioc_reqbufs,
+	.vidioc_querybuf				= vidioc_querybuf,
+	.vidioc_qbuf					= vidioc_qbuf,
+	.vidioc_dqbuf					= vidioc_dqbuf,
+	.vidioc_streamon				= vidioc_streamon,
+	.vidioc_streamoff				= vidioc_streamoff,
+};
+
+static struct file_operations omap_vout_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.ioctl = video_ioctl2,
+	.mmap = omap_vout_mmap,
+	.open = omap_vout_open,
+	.release = omap_vout_release,
+};
+
+static int omap_vout_remove(struct platform_device *pdev)
+{
+
+	struct omap2video_device *vid_dev = platform_get_drvdata(pdev);
+	int k;
+
+	for (k = 0; k < pdev->num_resources; k++)
+		omap_vout_cleanup_device(vid_dev->vouts[k]);
+
+	for (k = 0; k < vid_dev->num_displays; k++) {
+		if (vid_dev->displays[k]->state != OMAP_DSS_DISPLAY_DISABLED)
+			vid_dev->displays[k]->disable(vid_dev->displays[k]);
+
+		omap_dss_put_display(vid_dev->displays[k]);
+	}
+	kfree(vid_dev);
+	return 0;
+}
+
+static int omap_vout_probe(struct platform_device *pdev)
+{
+	int r = 0, i, t;
+	struct omap2video_device *vid_dev = NULL;
+	struct omap_overlay *ovl;
+
+	if (pdev->num_resources == 0) {
+		dev_err(&pdev->dev, "probed for an unknown device\n");
+		r = -ENODEV;
+		return r;
+	}
+
+	vid_dev = kzalloc(sizeof(struct omap2video_device), GFP_KERNEL);
+	if (vid_dev == NULL) {
+		r = -ENOMEM;
+		return r;
+	}
+
+	platform_set_drvdata(pdev, vid_dev);
+
+	vid_dev->num_displays = 0;
+	t = omap_dss_get_num_displays();
+	for (i = 0; i < t; i++) {
+		struct omap_display *display;
+		display = omap_dss_get_display(i);
+		if (!display) {
+			dev_err(&pdev->dev, "probed for an unknown device\n");
+			r = -EINVAL;
+			goto error0;
+		}
+		vid_dev->displays[vid_dev->num_displays++] = display;
+	}
+
+	if (vid_dev->num_displays == 0) {
+		dev_err(&pdev->dev, "probed for an unknown device\n");
+		r = -EINVAL;
+		goto error0;
+	}
+
+	vid_dev->num_overlays = omap_dss_get_num_overlays();
+	for (i = 0; i < vid_dev->num_overlays; i++)
+		vid_dev->overlays[i] = omap_dss_get_overlay(i);
+
+	vid_dev->num_managers = omap_dss_get_num_overlay_managers();
+	for (i = 0; i < vid_dev->num_managers; i++)
+		vid_dev->managers[i] = omap_dss_get_overlay_manager(i);
+
+	/* Get the Video1 overlay and video2 overlay.
+	 *  Setup the Display attached to that overlays
+	 */
+	 for (i = 1; i < 3; i++) {
+		ovl = omap_dss_get_overlay(i);
+		if (ovl->manager && ovl->manager->display) {
+			def_display = ovl->manager->display;
+		} else {
+			dev_err(&pdev->dev, "probed for an unknown device\n");
+			r = -EINVAL;
+			goto error0;
+		}
+		r = def_display->enable(def_display);
+		if (r) {
+			/* Here we are not considering a error as display may be
+			enabled by frame buffer driver */
+			printk(KERN_WARNING "Display already enabled\n");
+		}
+		/* set the update mode */
+		if (def_display->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE) {
+#ifdef CONFIG_FB_OMAP2_FORCE_AUTO_UPDATE
+			if (def_display->set_update_mode)
+				def_display->set_update_mode(def_display,
+						OMAP_DSS_UPDATE_AUTO);
+			if (def_display->enable_te)
+				def_display->enable_te(def_display, 1);
+#else
+			if (def_display->set_update_mode)
+				def_display->set_update_mode(def_display,
+						OMAP_DSS_UPDATE_MANUAL);
+			if (def_display->enable_te)
+				def_display->enable_te(def_display, 0);
+#endif
+		} else {
+			if (def_display->set_update_mode)
+				def_display->set_update_mode(def_display,
+						OMAP_DSS_UPDATE_AUTO);
+		}
+	 }
+
+	r = omap_vout_create_video_devices(pdev);
+	if (r)
+		goto error0;
+
+
+	for (i = 0; i < vid_dev->num_displays; i++) {
+		struct omap_display *display = vid_dev->displays[i];
+
+		if (display->update)
+			display->update(display, 0, 0,
+			display->panel->timings.x_res,
+			display->panel->timings.y_res);
+	}
+	printk(KERN_INFO "display->updated\n");
+	return 0;
+
+error0:
+	kfree(vid_dev);
+	return r;
+}
+
+static void omap_vout_release_vrfb(struct omap_vout_device *vout)
+{
+	int i, j;
+	for (i = 0; i < 4; i++) {
+		for (j = 0; j < 4; j++)
+			release_mem_region(vout->sms_rot_phy[i][j], VRFB_SIZE);
+	}
+
+	if (vout->vrfb_dma_tx.req_status == DMA_CHAN_ALLOTED) {
+		vout->vrfb_dma_tx.req_status = DMA_CHAN_NOT_ALLOTED;
+		omap_free_dma(vout->vrfb_dma_tx.dma_ch);
+	}
+
+}
+
+static void omap_vout_free_buffers(struct omap_vout_device *vout)
+{
+	int i, numbuffers;
+	/* Allocate memory for the buffes */
+	numbuffers = (vout->vid) ?  video2_numbuffers : video1_numbuffers;
+	vout->buffer_size = (vout->vid) ? video2_bufsize : video1_bufsize;
+
+	for (i = 0; i < numbuffers; i++) {
+		omap_vout_free_buffer(vout->buf_virt_addr[i],
+			 vout->buf_phy_addr[i], vout->buffer_size);
+		vout->buf_phy_addr[i] = 0;
+		vout->buf_virt_addr[i] = 0;
+	}
+}
+
+static int omap_vout_setup_video_data(struct omap_vout_device *vout)
+{
+	struct v4l2_pix_format *pix;
+	struct video_device *vfd;
+	struct v4l2_control *control;
+
+	/* set the default pix */
+	pix = &vout->pix;
+
+	/* Set the default picture of QVGA  */
+	pix->width = QQVGA_WIDTH;
+	pix->height = QQVGA_HEIGHT;
+
+	/* Default pixel format is RGB 5-6-5 */
+	pix->pixelformat = V4L2_PIX_FMT_RGB565;
+	pix->field = V4L2_FIELD_ANY;
+	pix->bytesperline = pix->width * 2;
+	pix->sizeimage = pix->bytesperline * pix->height;
+	pix->priv = 0;
+	pix->colorspace = V4L2_COLORSPACE_JPEG;
+
+	vout->bpp = RGB565_BPP;
+	vout->fbuf.fmt.width = vout->vid_info.overlays[0]->manager->display->panel->timings.x_res;
+	vout->fbuf.fmt.height = vout->vid_info.overlays[0]->manager->display->panel->timings.y_res;
+
+	omap_vout_new_format(pix, &vout->fbuf, &vout->crop, &vout->win);
+
+	/*Disable the rotation. */
+	control = vout->control;
+
+	control[0].id = V4L2_CID_ROTATION;
+	control[0].value = -1;
+	vout->rotation = control[0].value;
+
+	/* initialize the video_device struct */
+	vfd = vout->vfd = video_device_alloc();
+
+	if (!vfd) {
+		printk(KERN_ERR VOUT_NAME ": could not allocate video device struct\n");
+		return -ENOMEM;
+	}
+	vfd->release = video_device_release;
+	vfd->ioctl_ops = &vout_ioctl_ops;
+
+	strncpy(vfd->name, VOUT_NAME, sizeof(vfd->name));
+	vfd->vfl_type = VID_TYPE_OVERLAY | VID_TYPE_CHROMAKEY;
+
+	/* need to register for a VID_HARDWARE_* ID in videodev.h */
+	vfd->fops = &omap_vout_fops;
+	vout->suspended = 0;
+	init_waitqueue_head(&vout->suspend_wq);
+	init_MUTEX(&vout->lock);
+
+
+	vfd->minor = -1;
+	return 0;
+
+}
+static int omap_vout_setup_video_bufs(struct platform_device *pdev, int vid_num)
+{
+	struct omap2video_device *vid_dev = platform_get_drvdata(pdev);
+	struct omap_vout_device *vout;
+	int i, j, r = 0;
+	int index_i, index_j, image_width, image_height;
+	u32 sms_start_addr, numbuffers;
+	struct video_device *vfd;
+
+
+	vout = vid_dev->vouts[vid_num];
+	vfd = vout->vfd;
+
+	sms_start_addr = pdev->resource[vid_num].start;
+	for (i = 0; i < 4; i++) {
+		for (j = 0; j < 4; j++) {
+			vout->sms_rot_phy[i][j] = sms_start_addr;
+			if (!request_mem_region(vout->sms_rot_phy[i][j], VRFB_SIZE,
+				vfd->name)) {
+				printk(KERN_ERR "Cannot reserve smsm IO %x\n",
+						vout->sms_rot_phy[i][j]);
+				index_i = i;
+				index_j = j;
+				r = -1;
+				r = -ENOMEM;
+				goto release_vrfb_region;
+			}
+			sms_start_addr += 0x1000000;
+		}
+	}
+	index_i = 4;
+	index_j = 0;
+
+	numbuffers = (vid_num == 0) ? video1_numbuffers : video2_numbuffers;
+	vout->buffer_size = (vid_num == 0) ? video1_bufsize : video2_bufsize;
+	printk(KERN_INFO "Buffer Size = %d\n", vout->buffer_size);
+	for (i = 0; i < numbuffers; i++) {
+		vout->buf_virt_addr[i] = omap_vout_alloc_buffer(vout->buffer_size,
+						(u32 *) &vout->buf_phy_addr[i]);
+		if (!vout->buf_virt_addr[i]) {
+				numbuffers = i;
+				r = -ENOMEM;
+				goto free_buffers;
+			}
+		}
+
+	if (vid_num == OMAP_VIDEO1) {
+			vout->vrfb_context[0] = 4;
+			vout->vrfb_context[1] = 5;
+			vout->vrfb_context[2] = 6;
+			vout->vrfb_context[3] = 7;
+		} else {
+			vout->vrfb_context[0] = 8;
+			vout->vrfb_context[1] = 9;
+			vout->vrfb_context[2] = 10;
+			vout->vrfb_context[3] = 11;
+		}
+	vout->cropped_offset = 0;
+
+	/* Calculate VRFB memory size */
+	/* allocate for worst case size */
+	image_width = VID_MAX_WIDTH / TILE_SIZE;
+	if (VID_MAX_WIDTH % TILE_SIZE)
+		image_width++;
+
+	image_width = image_width * TILE_SIZE;
+	image_height = VID_MAX_HEIGHT / TILE_SIZE;
+
+	if (VID_MAX_HEIGHT % TILE_SIZE)
+		image_height++;
+
+	image_height = image_height * TILE_SIZE;
+	vout->smsshado_size = PAGE_ALIGN(image_width * image_height * 2 * 2);
+
+	/*
+	 * Request and Initialize DMA, for DMA based VRFB transfer
+	 */
+	vout->vrfb_dma_tx.dev_id = OMAP_DMA_NO_DEVICE;
+	vout->vrfb_dma_tx.dma_ch = -1;
+	vout->vrfb_dma_tx.req_status = DMA_CHAN_ALLOTED;
+	r = omap_request_dma(vout->vrfb_dma_tx.dev_id, "VRFB DMA TX",
+			omap_vout_vrfb_dma_tx_callback, (void *) &vout->vrfb_dma_tx,
+			&vout->vrfb_dma_tx.dma_ch);
+	if (r < 0) {
+		vout->vrfb_dma_tx.req_status = DMA_CHAN_NOT_ALLOTED;
+		printk(KERN_INFO VOUT_NAME ": DMA Channel not alloted\
+			for video%d [v4l2]\n", vfd->minor);
+	}
+	init_waitqueue_head(&vout->vrfb_dma_tx.wait);
+
+	return 0;
+
+free_buffers:
+	for (i = 0; i < numbuffers; i++) {
+		omap_vout_free_buffer(vout->buf_virt_addr[i], vout->buf_phy_addr[i],
+				vout->buffer_size);
+		vout->buf_virt_addr[i] = 0;
+		vout->buf_phy_addr[i] = 0;
+	}
+release_vrfb_region:
+	for (i = 0; i < index_i; i++)
+		for (j = 0; j < 4; j++)
+			release_mem_region(vout->sms_rot_phy[i][j], VRFB_SIZE);
+
+	for (j = 0; j < index_j; j++)
+		release_mem_region(vout->sms_rot_phy[index_i][j], VRFB_SIZE);
+
+	return r;
+
+}
+
+
+static int omap_vout_create_video_devices(struct platform_device *pdev)
+{
+	int r = 0, k;
+	struct omap_vout_device *vout;
+	struct video_device *vfd = NULL;
+	struct omap2video_device *vid_dev = platform_get_drvdata(pdev);
+
+
+	for (k = 0; k < pdev->num_resources; k++) {
+
+		vout = kmalloc(sizeof(struct omap_vout_device), GFP_KERNEL);
+		if (!vout) {
+			printk(KERN_ERR VOUT_NAME ": could not allocate \
+					memory\n");
+			return -ENOMEM;
+		}
+
+		memset(vout, 0, sizeof(struct omap_vout_device));
+
+		vout->vid = k;
+		vid_dev->vouts[k] = vout;
+		vout->vid_info.vid_dev = vid_dev;
+		vout->vid_info.overlays[0] = vid_dev->overlays[k + 1];
+		vout->vid_info.num_overlays = 1;
+		vout->vid_info.id = k + 1;
+		vid_dev->num_videos++;
+
+		/* Setup the default configuration for the video devices */
+		if (omap_vout_setup_video_data(vout) != 0) {
+			r = -ENOMEM;
+			goto error;
+		}
+
+		/* Allocate default number of buffers for the video streaming
+		 * and reserve the VRFB space for rotation
+		 */
+		if(omap_vout_setup_video_bufs(pdev, k) != 0) {
+			r = -ENOMEM;
+			goto error1;
+		}
+
+		vfd = vout->vfd;
+		if (video_register_device(vfd, VFL_TYPE_GRABBER, k + 1) < 0) {
+			printk(KERN_ERR VOUT_NAME ": could not register \
+					Video for Linux device\n");
+			vfd->minor = -1;
+			r = -ENODEV;
+			goto error2;
+		}
+
+		if (k == 0)
+			saved_v1out = vout;
+		else
+			saved_v2out = vout;
+
+		r = omapvid_apply_changes(vid_dev->vouts[k], 0, 1);
+
+		if (r)
+			goto error2;
+		else
+			goto success;
+
+		printk(KERN_ERR VOUT_NAME ": could not register Video for Linux device\n");
+
+
+error2:
+	omap_vout_release_vrfb(vout);
+	omap_vout_free_buffers(vout);
+error1:
+	video_device_release(vfd);
+error:
+	kfree(vout);
+	return r;
+
+success:
+	printk(KERN_INFO VOUT_NAME ": registered and initialized video device %d \
+				[v4l2]\n", vfd->minor);
+	if (k == (pdev->num_resources - 1))
+		return 0;
+	}
+	return -ENODEV;
+
+}
+
+int omapvid_apply_changes(struct omap_vout_device *vout, u32 addr, int init)
+{
+	int r = 0;
+	struct omapvideo_info *ovid = &(vout->vid_info);
+	struct omap_overlay *ovl;
+	int posx, posy;
+	int outw, outh, temp, rotation;
+	int i;
+	struct v4l2_window *win;
+	struct omap_video_timings *timing;
+	struct omap_display *cur_display;
+
+	win = &vout->win;
+	rotation = vout->rotation;
+	for (i = 0; i < ovid->num_overlays; i++) {
+		ovl = ovid->overlays[i];
+		timing = &ovl->manager->display->panel->timings;
+		cur_display = ovl->manager->display;
+
+		if (init || (ovl->caps & OMAP_DSS_OVL_CAP_SCALE) == 0) {
+			outw = win->w.width;
+			outh = win->w.height;
+
+		} else {
+			outw = win->w.width;
+			outh = win->w.height;
+		}
+		if (init) {
+			posx = 0;
+			posy = 0;
+		} else {
+			switch (rotation) {
+
+			case 90:
+				/* Invert the height and widht for 90
+				   and 270 degree rotation */
+				temp = outw;
+				outw = outh;
+				outh = temp;
+				posy = (timing->y_res - win->w.width)-
+					win->w.left;
+				posx = win->w.top;
+				break;
+
+			case 180:
+				posx = (timing->x_res - win->w.width) -
+					win->w.left;
+				posy = (timing->y_res - win->w.height) -
+					win->w.top;
+				break;
+
+			case 270:
+				temp = outw;
+				outw = outh;
+				outh = temp;
+				posy = win->w.left;
+				posx = (timing->x_res - win->w.height)
+					- win->w.top;
+				break;
+
+			default:
+				posx = win->w.left;
+				posy = win->w.top;
+				break;
+			}
+		}
+
+		if(cur_display->type == OMAP_DISPLAY_TYPE_VENC)
+			posy = posy/2;
+
+		//printk("POSY = %d\n", posy);
+
+		r = omapvid_setup_overlay(vout, ovl, posx, posy, outw,
+				outh, addr, vout->tv_field1_offset);
+		//printk("Fieldoffset = %d\n", vout->tv_field1_offset);
+		if (r)
+			goto err;
+
+		/* disabled for now. if the display has changed, var
+		 * still contains the old timings. */
+#if 0
+		if (display && display->set_timings) {
+			struct omap_video_timings timings;
+			timings.pixel_clock = PICOS2KHZ(var->pixclock);
+			timings.hfp = var->left_margin;
+			timings.hbp = var->right_margin;
+			timings.vfp = var->upper_margin;
+			timings.vbp = var->lower_margin;
+			timings.hsw = var->hsync_len;
+			timings.vsw = var->vsync_len;
+
+			display->set_timings(display, &timings);
+		}
+#endif
+	if (!init && ovl->manager)
+			ovl->manager->apply(ovl->manager);
+
+	}
+	return 0;
+err:
+	printk(KERN_WARNING "apply_changes failed\n");
+	return r;
+}
+
+int omapvid_setup_overlay(struct omap_vout_device *vout,
+		struct omap_overlay *ovl, int posx, int posy, int outw,
+		int outh, u32 addr, int tv_field1_offset)
+{
+	int r = 0;
+	enum omap_color_mode mode = 0;
+	int rotation, mirror;
+	int cropheight, cropwidth, pixheight, pixwidth;
+
+	if ((ovl->caps & OMAP_DSS_OVL_CAP_SCALE) == 0 &&
+			(outw != vout->pix.width || outh != vout->pix.height)) {
+		r = -EINVAL;
+		goto err;
+	}
+
+	mode = video_mode_to_dss_mode(&(vout->pix));
+
+	if (mode == -EINVAL) {
+		r = -EINVAL;
+		goto err;
+	}
+
+	rotation = vout->rotation;
+	mirror = 0;
+
+	/* Setup the input plane parameters according to
+	 * rotation value selected. */
+	if (rotation == 90 || rotation == 270) {
+		cropheight = vout->crop.width;
+		cropwidth = vout->crop.height;
+		pixheight = vout->pix.width;
+		pixwidth = vout->pix.height;
+	} else {
+		cropheight = vout->crop.height;
+		cropwidth = vout->crop.width;
+		pixheight = vout->pix.height;
+		pixwidth = vout->pix.width;
+	}
+
+	r = ovl->setup_input(ovl, (u32)addr, (void *)addr, tv_field1_offset,
+		pixwidth, cropwidth, cropheight, mode, rotation, mirror);
+
+	if (r)
+		goto err;
+
+	/* Output plane already setup in the parent function
+	 * according to the rotation degree selected */
+	r = ovl->setup_output(ovl, posx, posy, outw, outh);
+
+	if (r)
+		goto err;
+
+	return 0;
+
+err:
+	printk(KERN_WARNING "setup_overlay failed\n");
+	return r;
+}
+
+static enum omap_color_mode video_mode_to_dss_mode(struct v4l2_pix_format *pix)
+{
+	switch (pix->pixelformat) {
+
+	case 0:
+		break;
+	case V4L2_PIX_FMT_YUYV:
+		return OMAP_DSS_COLOR_YUV2;
+
+	case V4L2_PIX_FMT_UYVY:
+		return OMAP_DSS_COLOR_UYVY;
+
+	case V4L2_PIX_FMT_RGB565:
+		return OMAP_DSS_COLOR_RGB16;
+
+	case V4L2_PIX_FMT_RGB24:
+		return OMAP_DSS_COLOR_RGB24P;
+
+	case V4L2_PIX_FMT_RGB32:
+		return OMAP_DSS_COLOR_RGB24U;
+	case V4L2_PIX_FMT_BGR32:
+		return OMAP_DSS_COLOR_RGBX32;
+
+	default:
+		return -EINVAL;
+	}
+	return -EINVAL;
+}
+
+static struct platform_driver omap_vout_driver = {
+	.driver = {
+		   .name = VOUT_NAME,
+		   },
+	.probe = omap_vout_probe,
+	.remove = omap_vout_remove,
+};
+
+void omap_vout_isr(void *arg, unsigned int irqstatus)
+{
+	int r;
+
+	struct timeval timevalue;
+	struct omap_vout_device *vout =
+	    (struct omap_vout_device *) arg;
+	u32 addr, fid;
+	struct omapvideo_info *ovid;
+	struct omap_overlay *ovl;
+	struct omap_display *cur_display;
+
+
+	//printk("%s %d %x\n", __func__, __LINE__, vout);
+	if (!vout->streaming)
+		return;
+
+	//printk("%s %d\n", __func__, __LINE__);
+	ovid = &(vout->vid_info);
+	ovl = ovid->overlays[0];
+	/* get the display device attached to the overlay */
+	cur_display = ovl->manager->display;
+
+	spin_lock(&vout->vbq_lock);
+	do_gettimeofday(&timevalue);
+	//printk("addr = %x\n", addr);
+	//printk("%s %d\n", __func__, __LINE__);
+	if(cur_display->type == OMAP_DISPLAY_TYPE_DPI) {
+		if (!(irqstatus & DISPC_IRQSTATUS_VSYNC))
+			return;
+		//printk("DPI\n");
+		if (!vout->first_int && (vout->curFrm != vout->nextFrm)) {
+			vout->curFrm->ts = timevalue;
+			vout->curFrm->state = VIDEOBUF_DONE;
+			wake_up_interruptible(&vout->curFrm->done);
+			vout->curFrm = vout->nextFrm;
+		}
+		vout->first_int = 0;
+		if (list_empty(&vout->dma_queue)) {
+			spin_unlock(&vout->vbq_lock);
+			return;
+		}
+
+		vout->nextFrm = list_entry(vout->dma_queue.next,
+					struct videobuf_buffer, queue);
+		list_del(&vout->nextFrm->queue);
+
+		vout->nextFrm->state = VIDEOBUF_ACTIVE;
+
+		addr = (unsigned long) vout->queued_buf_addr[vout->nextFrm->i] +
+				vout->cropped_offset;
+		//printk("addr = %x\n", addr);
+		r = omapvid_apply_changes(vout, addr, 0);
+		if (r)
+			printk(KERN_ERR VOUT_NAME "failed to change mode\n");
+	} else {
+		//printk("Returning from Else\n\n\n");
+		//printk("VENC\n");
+		if (vout->first_int) {
+			vout->first_int = 0;
+			spin_unlock(&vout->vbq_lock);
+			return;
+		}
+		if (irqstatus & DISPC_IRQENABLE_EVSYNC_ODD) {
+			//printk("ODD FIELD\n");
+			fid = 1;
+		}
+		else if (irqstatus & DISPC_IRQENABLE_EVSYNC_EVEN) {
+			fid = 0;
+			//printk("EVEN FIELD\n");
+		}
+		else {
+			spin_unlock(&vout->vbq_lock);
+			return;
+		}
+		vout->field_id ^= 1;
+		if (fid != vout->field_id) {
+			if (0 == fid)
+				vout->field_id = fid;
+
+			spin_unlock(&vout->vbq_lock);
+			return;
+		}
+		if (0 == fid) {
+			if (vout->curFrm == vout->nextFrm) {
+				spin_unlock(&vout->vbq_lock);
+				return;
+			}
+			vout->curFrm->ts = timevalue;
+			vout->curFrm->state = VIDEOBUF_DONE;
+			wake_up_interruptible(&vout->curFrm->done);
+			vout->curFrm = vout->nextFrm;
+		} else if (1 == fid) {
+			if (list_empty(&vout->dma_queue) ||
+			    (vout->curFrm != vout->nextFrm)) {
+				spin_unlock(&vout->vbq_lock);
+				return;
+			}
+			vout->nextFrm = list_entry(vout->dma_queue.next,
+					   struct videobuf_buffer, queue);
+			list_del(&vout->nextFrm->queue);
+
+			vout->nextFrm->state = VIDEOBUF_ACTIVE;
+			//printk("Address\n\n\n");
+			addr = (unsigned long)
+			    vout->queued_buf_addr[vout->nextFrm->i] +
+			    vout->cropped_offset;
+			//printk("addr = %x\n", addr);
+			r = omapvid_apply_changes(vout, addr, 0);
+			if (r)
+				printk(KERN_ERR VOUT_NAME "failed to change mode\n");
+		}
+
+	}
+	spin_unlock(&vout->vbq_lock);
+}
+
+static void omap_vout_cleanup_device(struct omap_vout_device *vout)
+{
+
+	struct video_device *vfd;
+
+
+	if (!vout)
+		return;
+	vfd = vout->vfd;
+
+	if (vfd) {
+		if (vfd->minor == -1) {
+			/*
+			 * The device was never registered, so release the
+			 * video_device struct directly.
+			 */
+			video_device_release(vfd);
+		} else {
+			/*
+			 * The unregister function will release the video_device
+			 * struct as well as unregistering it.
+			 */
+			video_unregister_device(vfd);
+		}
+	}
+
+	omap_vout_release_vrfb(vout);
+
+	omap_vout_free_buffers(vout);
+
+
+	kfree(vout);
+
+	if (!(vout->vid))
+		saved_v1out = NULL;
+	else
+		saved_v2out = NULL;
+}
+
+static int __init omap_vout_init(void)
+{
+
+	if (platform_driver_register(&omap_vout_driver) != 0) {
+		printk(KERN_ERR VOUT_NAME ": could not register \
+				Video driver\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void omap_vout_cleanup(void)
+{
+	platform_driver_unregister(&omap_vout_driver);
+}
+
+MODULE_AUTHOR("Texas Instruments.");
+MODULE_DESCRIPTION("OMAP Video for Linux Video out driver");
+MODULE_LICENSE("GPL");
+
+late_initcall(omap_vout_init);
+module_exit(omap_vout_cleanup);
diff --git a/drivers/media/video/omap/omap_voutdef.h b/drivers/media/video/omap/omap_voutdef.h
new file mode 100644
index 0000000..06292bc
--- /dev/null
+++ b/drivers/media/video/omap/omap_voutdef.h
@@ -0,0 +1,174 @@
+/*
+ * drivers/media/video/omap/omap_voutdef.h
+ *
+ * Copyright (C) 2005 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef OMAP_VOUTDEF_H
+#define OMAP_VOUTDEF_H
+
+#include <mach/display.h>
+
+#define YUYV_BPP        2
+#define RGB565_BPP      2
+#define RGB24_BPP       3
+#define RGB32_BPP       4
+#define TILE_SIZE       32
+#define YUYV_VRFB_BPP   2
+#define RGB_VRFB_BPP    1
+#define MAX_CID			3
+
+/* Rotation using VRFB */
+#define SMS_ROT_VIRT_BASE(context, degree)      (0x70000000             \
+						| 0x4000000 * (context) \
+						| 0x1000000 * (degree/90))
+#define SMS_IMAGEHEIGHT_OFFSET                  16
+#define SMS_IMAGEWIDTH_OFFSET                   0
+#define SMS_PH_OFFSET                           8
+#define SMS_PW_OFFSET                           4
+#define SMS_PS_OFFSET                           0
+
+#define SMS_PHYS        OMAP343X_SMS_BASE       /* 0x6C000000 */
+#define SMS_VIRT        (SMS_PHYS + IO_OFFSET)  /* 0xFC000000 */
+#define SMS_SIZE        SZ_1M
+
+#define SDRC_PHYS       OMAP343X_SDRC_BASE      /* 0x6D000000 */
+#define SDRC_VIRT       (SDRC_PHYS + IO_OFFSET) /* 0xFD000000 */
+#define SDRC_SIZE       SZ_1M
+
+#define GPMC_PHYS       OMAP34XX_GPMC_BASE      /* 0x6E000000 */
+#define GPMC_VIRT       (GPMC_PHYS + IO_OFFSET) /* 0xFE000000 */
+#define GPMC_SIZE       SZ_1M
+
+#define OMAP_SMS_BASE   SMS_PHYS
+
+#define SMS_CONTEXT_BASE(context)       (OMAP_SMS_BASE + 0x10 * context)
+#define SMS_ROT0_PHYSICAL_BA(virt)      (virt + 0x188)
+#define SMS_ROT_CONTROL(virt)           (virt + 0x180)
+#define SMS_ROT0_SIZE(virt)             (virt + 0x184)
+
+/*
+ * This structure is used to store the DMA transfer parameters
+ * for VRFB hidden buffer
+ */
+struct vid_vrfb_dma {
+	int dev_id;
+	int dma_ch;
+	int req_status;
+	int tx_status;
+	wait_queue_head_t wait;
+};
+
+struct omapvideo_info {
+	int id;
+	int num_overlays;
+	struct omap_overlay *overlays[3];
+	struct omap2video_device *vid_dev;
+};
+
+struct omap2video_device {
+	struct device *dev;
+	struct mutex  mtx;
+
+	int state;
+
+	int num_videos;
+	struct omap_vout_device *vouts[10];
+
+	int num_displays;
+	struct omap_display *displays[10];
+	int num_overlays;
+	struct omap_overlay *overlays[10];
+	int num_managers;
+	struct omap_overlay_manager *managers[10];
+};
+
+/* per-device data structure */
+struct omap_vout_device {
+
+	struct omapvideo_info vid_info;
+	struct device dev;
+	struct video_device *vfd;
+	int vid;
+	int opened;
+
+	/* Power management suspend lockout stuff */
+	int suspended;
+	wait_queue_head_t suspend_wq;
+
+	/* we don't allow to change image fmt/size once buffer has
+	 * been allocated
+	 */
+	int buffer_allocated;
+	/* allow to reuse previosuly allocated buffer which is big enough */
+	int buffer_size;
+	/* keep buffer info accross opens */
+	unsigned long buf_virt_addr[VIDEO_MAX_FRAME];
+	unsigned long buf_phy_addr[VIDEO_MAX_FRAME];
+	unsigned int buf_memory_type;
+
+	/* we don't allow to request new buffer when old buffers are
+	 * still mmaped
+	 */
+	int mmap_count;
+
+	spinlock_t vbq_lock;		/* spinlock for videobuf queues */
+	unsigned long field_count;	/* field counter for videobuf_buffer */
+
+	/* non-NULL means streaming is in progress. */
+	struct omap_vout_fh *streaming;
+
+	struct v4l2_pix_format pix;
+	struct v4l2_rect crop;
+	struct v4l2_window win;
+	struct v4l2_framebuffer fbuf;
+
+	/* Lock to protect the shared data structures in ioctl */
+	struct semaphore lock;
+
+	/* rotation variablse goes here */
+	unsigned long sms_rot_virt[4]; /* virtual addresss for four angles */
+					/* four angles */
+	dma_addr_t sms_rot_phy[4][4];
+
+	/* V4L2 control structure for different control id */
+	struct v4l2_control control[MAX_CID];
+	int rotation;
+	int mirror;
+	int flicker_filter;
+	/* V4L2 control structure for different control id */
+
+	int bpp; /* bytes per pixel */
+	int vrfb_bpp; /* bytes per pixel with respect to VRFB */
+
+	struct vid_vrfb_dma vrfb_dma_tx;
+	unsigned int smsshado_phy_addr[4];
+	unsigned int smsshado_virt_addr[4];
+	unsigned int vrfb_context[4];
+	unsigned int smsshado_size;
+	unsigned char pos;
+
+	int ps, vr_ps, line_length, first_int, field_id;
+	enum v4l2_memory memory;
+	struct videobuf_buffer *curFrm, *nextFrm;
+	struct list_head dma_queue;
+	u8 *queued_buf_addr[32];
+	u32 cropped_offset;
+	s32 tv_field1_offset;
+	void *isr_handle;
+
+};
+
+/* per-filehandle data structure */
+struct omap_vout_fh {
+	struct omap_vout_device *vout;
+	enum v4l2_buf_type type;
+	struct videobuf_queue vbq;
+	int io_allowed;
+};
+
+#endif	/* ifndef OMAP_VOUTDEF_H */
diff --git a/drivers/media/video/omap/omap_voutlib.c b/drivers/media/video/omap/omap_voutlib.c
new file mode 100644
index 0000000..c51a413
--- /dev/null
+++ b/drivers/media/video/omap/omap_voutlib.c
@@ -0,0 +1,281 @@
+/*
+ * drivers/media/video/omap/omap_voutlib.c
+ *
+ * Copyright (C) 2008 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ * Based on the OMAP2 camera driver
+ * Video-for-Linux (Version 2) camera capture driver for
+ * the OMAP24xx camera controller.
+ *
+ * Author: Andy Lowe (source@mvista.com)
+ *
+ * Copyright (C) 2004 MontaVista Software, Inc.
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/kdev_t.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/videodev2.h>
+#include <linux/semaphore.h>
+
+/* Return the default overlay cropping rectangle in crop given the image
+ * size in pix and the video display size in fbuf.  The default
+ * cropping rectangle is the largest rectangle no larger than the capture size
+ * that will fit on the display.  The default cropping rectangle is centered in
+ * the image.  All dimensions and offsets are rounded down to even numbers.
+ */
+void omap_vout_default_crop(struct v4l2_pix_format *pix,
+		  struct v4l2_framebuffer *fbuf, struct v4l2_rect *crop)
+{
+	crop->width = (pix->width < fbuf->fmt.width) ?
+		pix->width : fbuf->fmt.width;
+	crop->height = (pix->height < fbuf->fmt.height) ?
+		pix->height : fbuf->fmt.height;
+	crop->width &= ~1;
+	crop->height &= ~1;
+	crop->left = ((pix->width - crop->width) >> 1) & ~1;
+	crop->top = ((pix->height - crop->height) >> 1) & ~1;
+}
+EXPORT_SYMBOL_GPL(omap_vout_default_crop);
+/* Given a new render window in new_win, adjust the window to the
+ * nearest supported configuration.  The adjusted window parameters are
+ * returned in new_win.
+ * Returns zero if succesful, or -EINVAL if the requested window is
+ * impossible and cannot reasonably be adjusted.
+ */
+int omap_vout_try_window(struct v4l2_framebuffer *fbuf,
+			struct v4l2_window *new_win)
+{
+	struct v4l2_rect try_win;
+
+	/* make a working copy of the new_win rectangle */
+	try_win = new_win->w;
+
+	/* adjust the preview window so it fits on the display by clipping any
+	 * offscreen areas
+	 */
+	if (try_win.left < 0) {
+		try_win.width += try_win.left;
+		try_win.left = 0;
+	}
+	if (try_win.top < 0) {
+		try_win.height += try_win.top;
+		try_win.top = 0;
+	}
+	try_win.width = (try_win.width < fbuf->fmt.width) ?
+		try_win.width : fbuf->fmt.width;
+	try_win.height = (try_win.height < fbuf->fmt.height) ?
+		try_win.height : fbuf->fmt.height;
+	if (try_win.left + try_win.width > fbuf->fmt.width)
+		try_win.width = fbuf->fmt.width - try_win.left;
+	if (try_win.top + try_win.height > fbuf->fmt.height)
+		try_win.height = fbuf->fmt.height - try_win.top;
+	try_win.width &= ~1;
+	try_win.height &= ~1;
+
+	if (try_win.width <= 0 || try_win.height <= 0)
+		return -EINVAL;
+
+	/* We now have a valid preview window, so go with it */
+	new_win->w = try_win;
+	new_win->field = /*V4L2_FIELD_NONE*/V4L2_FIELD_ANY;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(omap_vout_try_window);
+
+/* Given a new render window in new_win, adjust the window to the
+ * nearest supported configuration.  The image cropping window in crop
+ * will also be adjusted if necessary.  Preference is given to keeping the
+ * the window as close to the requested configuration as possible.  If
+ * successful, new_win, vout->win, and crop are updated.
+ * Returns zero if succesful, or -EINVAL if the requested preview window is
+ * impossible and cannot reasonably be adjusted.
+ */
+int omap_vout_new_window(struct v4l2_rect *crop,
+		struct v4l2_window *win, struct v4l2_framebuffer *fbuf,
+		struct v4l2_window *new_win)
+{
+	int err;
+
+	err = omap_vout_try_window(fbuf, new_win);
+	if (err)
+		return err;
+
+	/* update our preview window */
+	win->w = new_win->w;
+	win->field = new_win->field;
+	win->chromakey = new_win->chromakey;
+
+	/* adjust the cropping window to allow for resizing limitations */
+	if ((crop->height/win->w.height) >= 2) {
+		/* The maximum vertical downsizing ratio is 2:1 */
+		crop->height = win->w.height * 2;
+	}
+	if ((crop->width/win->w.width) >= 2) {
+		/* The maximum horizontal downsizing ratio is 2:1 */
+		crop->width = win->w.width * 2;
+	}
+	if (crop->width > 768) {
+		/* The OMAP2420 vertical resizing line buffer is 768 pixels
+		 * wide.  If the cropped image is wider than 768 pixels then it
+		 * cannot be vertically resized.
+		 */
+		if (crop->height != win->w.height)
+			crop->width = 768;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(omap_vout_new_window);
+
+/* Given a new cropping rectangle in new_crop, adjust the cropping rectangle to
+ * the nearest supported configuration.  The image render window in win will
+ * also be adjusted if necessary.  The preview window is adjusted such that the
+ * horizontal and vertical rescaling ratios stay constant.  If the render
+ * window would fall outside the display boundaries, the cropping rectangle
+ * will also be adjusted to maintain the rescaling ratios.  If successful, crop
+ * and win are updated.
+ * Returns zero if succesful, or -EINVAL if the requested cropping rectangle is
+ * impossible and cannot reasonably be adjusted.
+ */
+int omap_vout_new_crop(struct v4l2_pix_format *pix,
+	      struct v4l2_rect *crop, struct v4l2_window *win,
+	      struct v4l2_framebuffer *fbuf, const struct v4l2_rect *new_crop)
+{
+	struct v4l2_rect try_crop;
+	unsigned long vresize, hresize;
+
+	/* make a working copy of the new_crop rectangle */
+	try_crop = *new_crop;
+
+	/* adjust the cropping rectangle so it fits in the image */
+	if (try_crop.left < 0) {
+		try_crop.width += try_crop.left;
+		try_crop.left = 0;
+	}
+	if (try_crop.top < 0) {
+		try_crop.height += try_crop.top;
+		try_crop.top = 0;
+	}
+	try_crop.width = (try_crop.width < pix->width) ?
+		try_crop.width : pix->width;
+	try_crop.height = (try_crop.height < pix->height) ?
+		try_crop.height : pix->height;
+	if (try_crop.left + try_crop.width > pix->width)
+		try_crop.width = pix->width - try_crop.left;
+	if (try_crop.top + try_crop.height > pix->height)
+		try_crop.height = pix->height - try_crop.top;
+	try_crop.width &= ~1;
+	try_crop.height &= ~1;
+	if (try_crop.width <= 0 || try_crop.height <= 0)
+		return -EINVAL;
+
+	if (crop->height != win->w.height) {
+		/* If we're resizing vertically, we can't support a crop width
+		 * wider than 768 pixels.
+		 */
+		if (try_crop.width > 768)
+			try_crop.width = 768;
+	}
+	/* vertical resizing */
+	vresize = (1024 * crop->height) / win->w.height;
+	if (vresize > 2048)
+		vresize = 2048;
+	else if (vresize == 0)
+		vresize = 1;
+	win->w.height = ((1024 * try_crop.height) / vresize) & ~1;
+	if (win->w.height == 0)
+		win->w.height = 2;
+	if (win->w.height + win->w.top > fbuf->fmt.height) {
+		/* We made the preview window extend below the bottom of the
+		 * display, so clip it to the display boundary and resize the
+		 * cropping height to maintain the vertical resizing ratio.
+		 */
+		win->w.height = (fbuf->fmt.height - win->w.top) & ~1;
+		if (try_crop.height == 0)
+			try_crop.height = 2;
+	}
+	/* horizontal resizing */
+	hresize = (1024 * crop->width) / win->w.width;
+	if (hresize > 2048)
+		hresize = 2048;
+	else if (hresize == 0)
+		hresize = 1;
+	win->w.width = ((1024 * try_crop.width) / hresize) & ~1;
+	if (win->w.width == 0)
+		win->w.width = 2;
+	if (win->w.width + win->w.left > fbuf->fmt.width) {
+		/* We made the preview window extend past the right side of the
+		 * display, so clip it to the display boundary and resize the
+		 * cropping width to maintain the horizontal resizing ratio.
+		 */
+		win->w.width = (fbuf->fmt.width - win->w.left) & ~1;
+		if (try_crop.width == 0)
+			try_crop.width = 2;
+	}
+
+	/* Check for resizing constraints */
+	if ((try_crop.height/win->w.height) >= 2) {
+		/* The maximum vertical downsizing ratio is 2:1 */
+		try_crop.height = win->w.height * 2;
+	}
+	if ((try_crop.width/win->w.width) >= 2) {
+		/* The maximum horizontal downsizing ratio is 2:1 */
+		try_crop.width = win->w.width * 2;
+	}
+	if (try_crop.width > 768) {
+		/* The OMAP2420 vertical resizing line buffer is 768 pixels
+		 * wide.  If the cropped image is wider than 768 pixels then it
+		 * cannot be vertically resized.
+		 */
+		if (try_crop.height != win->w.height)
+			try_crop.width = 768;
+	}
+
+	/* update our cropping rectangle and we're done */
+	*crop = try_crop;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(omap_vout_new_crop);
+
+/* Given a new format in pix and fbuf,  crop and win
+ * structures are initialized to default values. crop
+ * is initialized to the largest window size that will fit on the display.  The
+ * crop window is centered in the image. win is initialized to
+ * the same size as crop and is centered on the display.
+ * All sizes and offsets are constrained to be even numbers.
+ */
+void omap_vout_new_format(struct v4l2_pix_format *pix,
+		struct v4l2_framebuffer *fbuf, struct v4l2_rect *crop,
+		struct v4l2_window *win)
+{
+	/* crop defines the preview source window in the image capture
+	 * buffer
+	 */
+	omap_vout_default_crop(pix, fbuf, crop);
+
+	/* win defines the preview target window on the display */
+	win->w.width = crop->width;
+	win->w.height = crop->height;
+	win->w.left = ((fbuf->fmt.width - win->w.width) >> 1) & ~1;
+	win->w.top = ((fbuf->fmt.height - win->w.height) >> 1) & ~1;
+}
+EXPORT_SYMBOL_GPL(omap_vout_new_format);
+
+MODULE_AUTHOR("Texas Instruments.");
+MODULE_DESCRIPTION("OMAP Video library");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/omap/omap_voutlib.h b/drivers/media/video/omap/omap_voutlib.h
new file mode 100644
index 0000000..d98f659
--- /dev/null
+++ b/drivers/media/video/omap/omap_voutlib.h
@@ -0,0 +1,34 @@
+/*
+ * drivers/media/video/omap/omap_voutlib.h
+ *
+ * Copyright (C) 2008 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ */
+
+#ifndef OMAP_VOUTLIB_H
+#define OMAP_VOUTLIB_H
+
+extern void omap_vout_default_crop(struct v4l2_pix_format *pix,
+		struct v4l2_framebuffer *fbuf, struct v4l2_rect *crop);
+
+extern int omap_vout_new_crop(struct v4l2_pix_format *pix,
+		struct v4l2_rect *crop, struct v4l2_window *win,
+		struct v4l2_framebuffer *fbuf,
+		const struct v4l2_rect *new_crop);
+
+extern int omap_vout_try_window(struct v4l2_framebuffer *fbuf,
+		struct v4l2_window *new_win);
+
+extern int omap_vout_new_window(struct v4l2_rect *crop,
+		struct v4l2_window *win, struct v4l2_framebuffer *fbuf,
+		struct v4l2_window *new_win);
+
+extern void omap_vout_new_format(struct v4l2_pix_format *pix,
+		struct v4l2_framebuffer *fbuf, struct v4l2_rect *crop,
+		struct v4l2_window *win);
+#endif	/* #ifndef OMAP_LIB_H */
+
diff --git a/drivers/media/video/v4l2-ioctl.c b/drivers/media/video/v4l2-ioctl.c
index 52d687b..4ce2f2c 100644
--- a/drivers/media/video/v4l2-ioctl.c
+++ b/drivers/media/video/v4l2-ioctl.c
@@ -269,6 +269,8 @@ static const char *v4l2_ioctls[] = {
 	[_IOC_NR(VIDIOC_DBG_G_CHIP_IDENT)] = "VIDIOC_DBG_G_CHIP_IDENT",
 	[_IOC_NR(VIDIOC_S_HW_FREQ_SEEK)]   = "VIDIOC_S_HW_FREQ_SEEK",
 #endif
+	[_IOC_NR(VIDIOC_S_COLOR_SPACE_CONV)]   = "VIDIOC_S_COLOR_SPACE_CONV",
+	[_IOC_NR(VIDIOC_G_COLOR_SPACE_CONV)]   = "VIDIOC_G_COLOR_SPACE_CONV",
 };
 #define V4L2_IOCTLS ARRAY_SIZE(v4l2_ioctls)
 
@@ -1838,6 +1840,23 @@ static long __video_do_ioctl(struct file *file,
 		break;
 	}
 
+	/*---------------Color space conversion------------------------------*/
+	case VIDIOC_S_COLOR_SPACE_CONV:
+	{
+		struct v4l2_color_space_conversion *p = arg;
+		if (!ops->vidioc_s_color_space_conv)
+			break;
+		ret = ops->vidioc_s_color_space_conv(file, fh, p);
+		break;
+	}
+	case VIDIOC_G_COLOR_SPACE_CONV:
+	{
+		struct v4l2_color_space_conversion *p = arg;
+		if (!ops->vidioc_g_color_space_conv)
+			break;
+		ret = ops->vidioc_g_color_space_conv(file, fh, p);
+		break;
+	}
 	default:
 	{
 		if (!ops->vidioc_default)
diff --git a/include/linux/videodev2.h b/include/linux/videodev2.h
index 5571dbe..664aed2 100644
--- a/include/linux/videodev2.h
+++ b/include/linux/videodev2.h
@@ -879,8 +879,10 @@ enum v4l2_power_line_frequency {
 #define V4L2_CID_BACKLIGHT_COMPENSATION 	(V4L2_CID_BASE+28)
 #define V4L2_CID_CHROMA_AGC                     (V4L2_CID_BASE+29)
 #define V4L2_CID_COLOR_KILLER                   (V4L2_CID_BASE+30)
+#define V4L2_CID_ROTATION			(V4L2_CID_BASE+31)
+#define V4L2_CID_BG_COLOR			(V4L2_CID_BASE+32)
 /* last CID + 1 */
-#define V4L2_CID_LASTP1                         (V4L2_CID_BASE+31)
+#define V4L2_CID_LASTP1                         (V4L2_CID_BASE+33)
 
 /*  MPEG-class control IDs defined by V4L2 */
 #define V4L2_CID_MPEG_BASE 			(V4L2_CTRL_CLASS_MPEG | 0x900)
@@ -1192,6 +1194,18 @@ struct v4l2_hw_freq_seek {
 };
 
 /*
+ * Color conversion
+ * User needs to pass pointer to color conversion matrix
+ * defined by hardware
+ */
+struct v4l2_color_space_conversion {
+	__s32 coefficients[3][3];
+	__s32 const_factor;
+	__s32 input_offs[3];
+	__s32 output_offs[3];
+};
+
+/*
  *	A U D I O
  */
 struct v4l2_audio {
@@ -1244,7 +1258,6 @@ struct v4l2_enc_idx {
 	struct v4l2_enc_idx_entry entry[V4L2_ENC_IDX_ENTRIES];
 };
 
-
 #define V4L2_ENC_CMD_START      (0)
 #define V4L2_ENC_CMD_STOP       (1)
 #define V4L2_ENC_CMD_PAUSE      (2)
@@ -1265,7 +1278,6 @@ struct v4l2_encoder_cmd {
 
 #endif
 
-
 /*
  *	D A T A   S E R V I C E S   ( V B I )
  *
@@ -1355,7 +1367,6 @@ struct v4l2_format {
 	} fmt;
 };
 
-
 /*	Stream type-dependent parameters
  */
 struct v4l2_streamparm {
@@ -1493,6 +1504,8 @@ struct v4l2_chip_ident_old {
 #endif
 
 #define VIDIOC_S_HW_FREQ_SEEK	 _IOW('V', 82, struct v4l2_hw_freq_seek)
+#define VIDIOC_S_COLOR_SPACE_CONV	 _IOW('V', 83, struct v4l2_color_space_conversion)
+#define VIDIOC_G_COLOR_SPACE_CONV	 _IOR('V', 84, struct v4l2_color_space_conversion)
 /* Reminder: when adding new ioctls please add support for them to
    drivers/media/video/v4l2-compat-ioctl32.c as well! */
 
diff --git a/include/media/v4l2-ioctl.h b/include/media/v4l2-ioctl.h
index b01c044..0c44ecf 100644
--- a/include/media/v4l2-ioctl.h
+++ b/include/media/v4l2-ioctl.h
@@ -241,6 +241,10 @@ struct v4l2_ioctl_ops {
 	/* For other private ioctls */
 	long (*vidioc_default)	       (struct file *file, void *fh,
 					int cmd, void *arg);
+	int (*vidioc_s_color_space_conv)     (struct file *file, void *fh,
+					struct v4l2_color_space_conversion *a);
+	int (*vidioc_g_color_space_conv)     (struct file *file, void *fh,
+					struct v4l2_color_space_conversion *a);
 };
 
 
-- 
1.5.6

