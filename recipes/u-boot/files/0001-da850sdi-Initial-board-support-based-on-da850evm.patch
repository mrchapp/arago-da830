From 325fe26caa961ef13fb95b9e1647128beb58baa9 Mon Sep 17 00:00:00 2001
From: Martin Ambrose <martin@ti.com>
Date: Mon, 28 Feb 2011 10:15:20 -0600
Subject: [PATCH 1/1] da850sdi: Initial board support based on da850evm.

---
 Makefile                          |    3 +
 board/davinci/da8xxevm/Makefile   |    1 +
 board/davinci/da8xxevm/da850sdi.c |  484 +++++++++++++++++++++++++++++++++++++
 drivers/mtd/spi/winbond.c         |    9 +
 include/asm-arm/mach-types.h      |   14 +
 include/configs/da850sdi.h        |  302 +++++++++++++++++++++++
 6 files changed, 813 insertions(+), 0 deletions(-)
 create mode 100644 board/davinci/da8xxevm/da850sdi.c
 create mode 100644 include/configs/da850sdi.h

diff --git a/Makefile b/Makefile
index d730f9b..03dcd09 100644
--- a/Makefile
+++ b/Makefile
@@ -2933,6 +2933,9 @@ cp922_XA10_config	\
 cp1026_config: unconfig
 	@board/armltd/integrator/split_by_variant.sh cp $@
 
+da850sdi_config:	unconfig
+	@$(MKCONFIG) -a da850sdi arm arm926ejs da8xxevm davinci davinci
+
 da850_omapl138_evm_config	\
 da850evm_config:	unconfig
 	@$(MKCONFIG) -a da850evm arm arm926ejs da8xxevm davinci davinci
diff --git a/board/davinci/da8xxevm/Makefile b/board/davinci/da8xxevm/Makefile
index bcf315c..0138de9 100644
--- a/board/davinci/da8xxevm/Makefile
+++ b/board/davinci/da8xxevm/Makefile
@@ -29,6 +29,7 @@ LIB	= $(obj)lib$(BOARD).a
 
 COBJS-$(CONFIG_MACH_DAVINCI_DA830_EVM)	+= da830evm.o
 COBJS-$(CONFIG_MACH_DAVINCI_DA850_EVM)	+= da850evm.o
+COBJS-$(CONFIG_MACH_DAVINCI_DA850_SDI)	+= da850sdi.o
 
 COBJS   := $(sort $(COBJS-y))
 
diff --git a/board/davinci/da8xxevm/da850sdi.c b/board/davinci/da8xxevm/da850sdi.c
new file mode 100644
index 0000000..866d351
--- /dev/null
+++ b/board/davinci/da8xxevm/da850sdi.c
@@ -0,0 +1,484 @@
+/*
+ * Copyright (C) 2009 Nick Thompson, GE Fanuc, Ltd. <nick.thompson@gefanuc.com>
+ *
+ * Base on code from TI. Original Notices follow:
+ *
+ * (C) Copyright 2008, Texas Instruments, Inc. http://www.ti.com/
+ *
+ * Modified for DA8xx EVM.
+ *
+ * Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+ *
+ * Parts are shamelessly stolen from various TI sources, original copyright
+ * follows:
+ * -----------------------------------------------------------------
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <spi.h>
+#include <net.h>
+#include <spi_flash.h>
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <nand.h>
+#include <asm/arch/nand_defs.h>
+#include "../common/misc.h"
+#ifdef CONFIG_DAVINCI_MMC
+#include <mmc.h>
+#include <asm/arch/sdmmc_defs.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define pinmux	&davinci_syscfg_regs->pinmux
+
+#ifdef CONFIG_SPI_FLASH
+/* SPI0 pin muxer settings */
+const struct pinmux_config spi1_pins[] = {
+	{ pinmux[5], 1, 1 },
+	{ pinmux[5], 1, 2 },
+	{ pinmux[5], 1, 4 },
+	{ pinmux[5], 1, 5 },
+};
+#endif
+
+#ifdef CONFIG_DAVINCI_MMC
+/* SPI0 pin muxer settings */
+const struct pinmux_config mmc0_pins[] = {
+	/* GP0[11] is required for SD to work on Rev 3 EVMs */
+	{ pinmux[0],  8, 4 },   /* GP0[11] */
+	{ pinmux[10], 2, 0 },	/* MMCSD0_CLK */
+	{ pinmux[10], 2, 1 },	/* MMCSD0_CMD */
+	{ pinmux[10], 2, 2 },	/* MMCSD0_DAT_0 */
+	{ pinmux[10], 2, 3 },	/* MMCSD0_DAT_1 */
+	{ pinmux[10], 2, 4 },	/* MMCSD0_DAT_2 */
+	{ pinmux[10], 2, 5 },	/* MMCSD0_DAT_3 */
+	/* DA850 supports only 4-bit mode, remaining pins are not configured */
+};
+#endif
+
+/* UART pin muxer settings */
+const struct pinmux_config uart_pins[] = {
+	{ pinmux[0], 4, 6 },
+	{ pinmux[0], 4, 7 },
+	{ pinmux[4], 2, 4 },
+	{ pinmux[4], 2, 5 }
+};
+
+#ifdef CONFIG_DRIVER_TI_EMAC
+const struct pinmux_config emac_pins[] = {
+#ifdef CONFIG_DRIVER_TI_EMAC_USE_RMII
+	{ pinmux[14], 8, 2 },
+	{ pinmux[14], 8, 3 },
+	{ pinmux[14], 8, 4 },
+	{ pinmux[14], 8, 5 },
+	{ pinmux[14], 8, 6 },
+	{ pinmux[14], 8, 7 },
+	{ pinmux[15], 8, 1 },
+#else
+	{ pinmux[2], 8, 1 },
+	{ pinmux[2], 8, 2 },
+	{ pinmux[2], 8, 3 },
+	{ pinmux[2], 8, 4 },
+	{ pinmux[2], 8, 5 },
+	{ pinmux[2], 8, 6 },
+	{ pinmux[2], 8, 7 },
+	{ pinmux[3], 8, 0 },
+	{ pinmux[3], 8, 1 },
+	{ pinmux[3], 8, 2 },
+	{ pinmux[3], 8, 3 },
+	{ pinmux[3], 8, 4 },
+	{ pinmux[3], 8, 5 },
+	{ pinmux[3], 8, 6 },
+	{ pinmux[3], 8, 7 },
+#endif /* CONFIG_DRIVER_TI_EMAC_USE_RMII */
+	{ pinmux[4], 8, 0 },
+	{ pinmux[4], 8, 1 }
+};
+#endif /* CONFIG_DRIVER_TI_EMAC */
+
+/* I2C pin muxer settings */
+const struct pinmux_config i2c_pins[] = {
+	{ pinmux[4], 2, 2 },
+	{ pinmux[4], 2, 3 }
+};
+
+#ifdef CONFIG_USE_NAND
+const struct pinmux_config aemif_pins[] = {
+	{ pinmux[7], 1, 1 },
+	{ pinmux[7], 1, 2 },
+	{ pinmux[7], 1, 4 },
+	{ pinmux[7], 1, 5 },
+	{ pinmux[9], 1, 0 },
+	{ pinmux[9], 1, 1 },
+	{ pinmux[9], 1, 2 },
+	{ pinmux[9], 1, 3 },
+	{ pinmux[9], 1, 4 },
+	{ pinmux[9], 1, 5 },
+	{ pinmux[9], 1, 6 },
+	{ pinmux[9], 1, 7 },
+	{ pinmux[12], 1, 5 },
+	{ pinmux[12], 1, 6 }
+};
+#elif defined(CONFIG_SYS_USE_NOR)
+const struct pinmux_config nor_pins[] = {
+	/* GP0[11] is required for SD to work on Rev 3 EVMs */
+	{ pinmux[0], 8, 4 },   /* GP0[11] */
+	{ pinmux[5], 1, 6 },
+	{ pinmux[6], 1, 6 },
+	{ pinmux[7], 1, 0 },
+	{ pinmux[7], 1, 4 },
+	{ pinmux[7], 1, 5 },
+	{ pinmux[8], 1, 0 },
+	{ pinmux[8], 1, 1 },
+	{ pinmux[8], 1, 2 },
+	{ pinmux[8], 1, 3 },
+	{ pinmux[8], 1, 4 },
+	{ pinmux[8], 1, 5 },
+	{ pinmux[8], 1, 6 },
+	{ pinmux[8], 1, 7 },
+	{ pinmux[9], 1, 0 },
+	{ pinmux[9], 1, 1 },
+	{ pinmux[9], 1, 2 },
+	{ pinmux[9], 1, 3 },
+	{ pinmux[9], 1, 4 },
+	{ pinmux[9], 1, 5 },
+	{ pinmux[9], 1, 6 },
+	{ pinmux[9], 1, 7 },
+	{ pinmux[10], 1, 0 },
+	{ pinmux[10], 1, 1 },
+	{ pinmux[10], 1, 2 },
+	{ pinmux[10], 1, 3 },
+	{ pinmux[10], 1, 4 },
+	{ pinmux[10], 1, 5 },
+	{ pinmux[10], 1, 6 },
+	{ pinmux[10], 1, 7 },
+	{ pinmux[11], 1, 0 },
+	{ pinmux[11], 1, 1 },
+	{ pinmux[11], 1, 2 },
+	{ pinmux[11], 1, 3 },
+	{ pinmux[11], 1, 4 },
+	{ pinmux[11], 1, 5 },
+	{ pinmux[11], 1, 6 },
+	{ pinmux[11], 1, 7 },
+	{ pinmux[12], 1, 0 },
+	{ pinmux[12], 1, 1 },
+	{ pinmux[12], 1, 2 },
+	{ pinmux[12], 1, 3 },
+	{ pinmux[12], 1, 4 },
+	{ pinmux[12], 1, 5 },
+	{ pinmux[12], 1, 6 },
+	{ pinmux[12], 1, 7 }
+};
+#endif
+
+int board_init(void)
+{
+	unsigned int temp;
+#ifndef CONFIG_USE_IRQ
+	/*
+	 * Mask all IRQs by clearing the global enable and setting
+	 * the enable clear for all the 90 interrupts.
+	 */
+
+	writel(0, &davinci_aintc_regs->ger);
+
+	writel(0, &davinci_aintc_regs->hier);
+
+	writel(0xffffffff, &davinci_aintc_regs->ecr1);
+	writel(0xffffffff, &davinci_aintc_regs->ecr2);
+	writel(0xffffffff, &davinci_aintc_regs->ecr3);
+#endif
+
+	/* arch number of the board */
+	gd->bd->bi_arch_number = MACH_TYPE_DAVINCI_DA850_SDI;
+
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = LINUX_BOOT_PARAM_ADDR;
+
+	/*
+	 * Power on required peripherals
+	 * ARM does not have access by default to PSC0 and PSC1
+	 * assuming here that the DSP bootloader has set the IOPU
+	 * such that PSC access is available to ARM
+	 */
+	lpsc_on(DAVINCI_LPSC_AEMIF);    /* NAND, NOR */
+	lpsc_on(DAVINCI_LPSC_SPI1);     /* Serial Flash */
+	lpsc_on(DAVINCI_LPSC_EMAC);     /* image download */
+	lpsc_on(DAVINCI_LPSC_UART2);    /* console */
+	lpsc_on(DAVINCI_LPSC_GPIO);
+#ifdef CONFIG_DAVINCI_MMC
+	lpsc_on(DAVINCI_LPSC_MMC_SD);
+#endif
+
+	/* setup the SUSPSRC for ARM to control emulation suspend */
+	writel(readl(&davinci_syscfg_regs->suspsrc) &
+	       ~(DAVINCI_SYSCFG_SUSPSRC_EMAC | DAVINCI_SYSCFG_SUSPSRC_I2C |
+		 DAVINCI_SYSCFG_SUSPSRC_SPI1 | DAVINCI_SYSCFG_SUSPSRC_TIMER0 |
+		 DAVINCI_SYSCFG_SUSPSRC_UART2),
+	       &davinci_syscfg_regs->suspsrc);
+
+#ifdef CONFIG_SPI_FLASH
+	if (davinci_configure_pin_mux(spi1_pins, ARRAY_SIZE(spi1_pins)) != 0)
+		return 1;
+#endif
+
+#ifdef CONFIG_DAVINCI_MMC
+	if (davinci_configure_pin_mux(mmc0_pins, ARRAY_SIZE(mmc0_pins)) != 0)
+		return 1;
+
+	/* Set the GPIO direction as output */
+	temp = REG(GPIO_BANK0_REG_DIR_ADDR);
+	temp &= ~(0x01 << 11);
+	REG(GPIO_BANK0_REG_DIR_ADDR) = temp;
+
+	/* Set the output as high */
+	temp = REG(GPIO_BANK0_REG_SET_ADDR);
+	temp |= (0x01 << 11);
+	REG(GPIO_BANK0_REG_SET_ADDR) = temp;
+#endif
+
+	if (davinci_configure_pin_mux(uart_pins, ARRAY_SIZE(uart_pins)) != 0)
+		return 1;
+
+	if (davinci_configure_pin_mux(i2c_pins, ARRAY_SIZE(i2c_pins)) != 0)
+		return 1;
+	
+#ifdef CONFIG_DRIVER_TI_EMAC
+	if (davinci_configure_pin_mux(emac_pins, ARRAY_SIZE(emac_pins)) != 0)
+		return 1;
+#ifdef CONFIG_DRIVER_TI_EMAC_USE_RMII
+	REG(CFGCHIP3) |= (1 << 8);
+#else
+	/* set cfgchip3 to selct MII */
+	REG(CFGCHIP3) &= ~(1 << 8);
+#endif /* CONFIG_DRIVER_TI_EMAC_USE_RMII */
+
+#endif /* CONFIG_DRIVER_TI_EMAC */
+
+#ifdef CONFIG_USE_NAND
+	if (davinci_configure_pin_mux(aemif_pins, ARRAY_SIZE(aemif_pins)) != 0)
+		return 1;
+#elif defined(CONFIG_SYS_USE_NOR)
+	if (davinci_configure_pin_mux(nor_pins, ARRAY_SIZE(nor_pins)) != 0)
+		return 1;
+
+	/* Set the GPIO direction as output */
+	temp = REG(GPIO_BANK0_REG_DIR_ADDR);
+	temp &= ~(0x01 << 11);
+	REG(GPIO_BANK0_REG_DIR_ADDR) = temp;
+
+	/* Set the output as low */
+	temp = REG(GPIO_BANK0_REG_SET_ADDR);
+	temp |= (0x01 << 11);
+	REG(GPIO_BANK0_REG_CLR_ADDR) = temp;
+#endif
+
+	/* enable the console UART */
+	writel((DAVINCI_UART_PWREMU_MGMT_FREE | DAVINCI_UART_PWREMU_MGMT_URRST |
+		DAVINCI_UART_PWREMU_MGMT_UTRST),
+	       &davinci_uart2_ctrl_regs->pwremu_mgmt);
+
+	return(0);
+}
+
+#define CFG_MAC_ADDR_SPI_BUS	0
+#define CFG_MAC_ADDR_SPI_CS	0
+#define CFG_MAC_ADDR_SPI_MAX_HZ	CONFIG_SF_DEFAULT_SPEED
+#define CFG_MAC_ADDR_SPI_MODE	SPI_MODE_3
+
+#define CFG_MAC_ADDR_OFFSET	(flash->size - SZ_64K)
+
+static int  get_mac_addr(u8 *addr)
+{
+	int ret;
+	struct spi_flash *flash;
+
+	flash = spi_flash_probe(CFG_MAC_ADDR_SPI_BUS, CFG_MAC_ADDR_SPI_CS,
+			CFG_MAC_ADDR_SPI_MAX_HZ, CFG_MAC_ADDR_SPI_MODE);
+	if (!flash) {
+		printf(" Error - unable to probe SPI flash.\n");
+		goto err_probe;
+	}
+
+	ret = spi_flash_read(flash, CFG_MAC_ADDR_OFFSET, 6, addr);
+	if (ret) {
+		printf("Error - unable to read MAC address from SPI flash.\n");
+		goto err_read;
+	}
+
+err_read:
+	/* cannot call free currently since the free function calls free() for
+	 * spi_flash structure though it is not directly allocated through
+	 * malloc()
+	 */
+	/* spi_flash_free(flash); */
+err_probe:
+	return ret;
+}
+
+void dsp_lpsc_on(unsigned domain, unsigned int id)
+{
+	dv_reg_p mdstat, mdctl, ptstat, ptcmd;
+	struct davinci_psc_regs *psc_regs;
+
+	psc_regs = davinci_psc0_regs;
+	mdstat = &psc_regs->psc0.mdstat[id];
+	mdctl = &psc_regs->psc0.mdctl[id];
+	ptstat = &psc_regs->ptstat;
+	ptcmd = &psc_regs->ptcmd;
+
+	while (*ptstat & (0x1 << domain)) {;}
+
+	if ((*mdstat & 0x1f) == 0x03)
+		return;                 /* Already on and enabled */
+
+	*mdctl |= 0x03;
+
+	*ptcmd = 0x1 << domain;
+
+	while (*ptstat & (0x1 << domain)) {;}
+	while ((*mdstat & 0x1f) != 0x03) {;}    /* Probably an overkill... */
+}
+
+static void dspwake(void)
+{
+	unsigned *resetvect = (unsigned *)DAVINCI_L3CBARAM_BASE;
+
+	/* if the device is ARM only, return */
+	if ((REG(CHIP_REV_ID_REG) & 0x3f) == 0x10)
+		return;
+
+	if (!strcmp(getenv("dspwake"), "no"))
+		return;
+
+	*resetvect++ = 0x1E000; /* DSP Idle */
+	/* clear out the next 10 words as NOP */
+	memset(resetvect, 0, sizeof(unsigned) * 10);
+
+	/* setup the DSP reset vector */
+	REG(HOST1CFG) = DAVINCI_L3CBARAM_BASE;
+
+	dsp_lpsc_on(1, DAVINCI_LPSC_GEM);
+	REG(PSC0_MDCTL + (15 * 4)) |= 0x100;
+}
+
+int misc_init_r(void)
+{
+	uint8_t tmp[20], addr[10];
+
+	printf ("ARM Clock : %d Hz\n", clk_get(DAVINCI_ARM_CLKID));
+	printf ("DDR Clock : %d Hz\n", clk_get(DAVINCI_DDR_CLKID)/2);
+
+	if (getenv("ethaddr") == NULL) {
+		/* Set Ethernet MAC address from EEPROM */
+		get_mac_addr(addr);
+
+		if(is_multicast_ether_addr(addr) || is_zero_ether_addr(addr)) {
+			printf("Invalid MAC address read.\n");
+			return -EINVAL;
+		}
+		sprintf((char *)tmp, "%02x:%02x:%02x:%02x:%02x:%02x", addr[0],
+				addr[1], addr[2], addr[3], addr[4], addr[5]);
+
+		setenv("ethaddr", (char *)tmp);
+	}
+
+	// NB: accessing mux on I2C gpio expander at this point since I2C access
+	// depends on udelay which depends on a functioning timer. However the timer
+	// isn't initialized until after board_init (lib_arm/board.c) which is where
+	// this setting would be ideally.
+#ifdef CONFIG_DRIVER_TI_EMAC_USE_RMII
+	{
+	    u_int8_t buf[2];
+	    int ret;
+
+	    buf[0] = 0xEF;
+	    ret = i2c_write(0x21, 6, 1, buf, 1);
+	    if (ret) {
+		printf("\nI2C 0x%02x (7) write FAILED!!!\n", 0x21);
+		return ret;
+	    }
+
+	    buf[0] = 0xFF;
+	    ret = i2c_write(0x21, 2, 1, buf, 1);
+	    if (ret) {
+		printf("\nI2C 0x%02x (2) write FAILED!!!\n", 0x21);
+		return ret;
+	    }
+
+	}
+#else
+	{
+	    u_int8_t buf[2];
+	    int ret;
+
+	    buf[0] = 0xEF;
+	    ret = i2c_write(0x21, 6, 1, buf, 1);
+	    if (ret) {
+		printf("\nI2C 0x%02x (7) write FAILED!!!\n", 0x21);
+		return ret;
+	    }
+
+	    buf[0] = 0;
+	    ret = i2c_write(0x21, 2, 1, buf, 1);
+	    if (ret) {
+		printf("\nI2C 0x%02x (2) write FAILED!!!\n", 0x21);
+		return ret;
+	    }
+
+	}
+#endif
+
+	dspwake();	
+
+	return (0);
+}
+
+#ifdef CONFIG_NAND_DAVINCI
+int board_nand_init(struct nand_chip *nand)
+{
+       davinci_nand_init(nand);
+
+       return 0;
+}
+#endif
+
+#ifdef CONFIG_DAVINCI_MMC
+static struct davinci_mmc mmc_sd0 = {
+	.reg_base = (struct davinci_mmc_regs *)DAVINCI_MMC_SD0_BASE,
+	.host_caps = MMC_MODE_4BIT,	/* DA850 supports only 4-bit SD/MMC */
+	.voltages = MMC_VDD_32_33 | MMC_VDD_33_34,
+	.version = MMC_CTLR_VERSION_2,
+};
+
+int board_mmc_init(bd_t *bis)
+{
+	mmc_sd0.input_clk = clk_get(DAVINCI_MMCSD_CLKID);
+
+	/* Add slot-0 to mmc subsystem */
+	return davinci_mmc_init(bis, &mmc_sd0);
+}
+#endif
+
+
diff --git a/drivers/mtd/spi/winbond.c b/drivers/mtd/spi/winbond.c
index b8da923..0135d11 100644
--- a/drivers/mtd/spi/winbond.c
+++ b/drivers/mtd/spi/winbond.c
@@ -27,6 +27,7 @@
 #define WINBOND_ID_W25X16		0x3015
 #define WINBOND_ID_W25X32		0x3016
 #define WINBOND_ID_W25X64		0x3017
+#define WINBOND_ID_W25Q64		0x4017
 
 #define WINBOND_SR_WIP		(1 << 0)	/* Write-in-Progress */
 
@@ -77,6 +78,14 @@ static const struct winbond_spi_flash_params winbond_spi_flash_table[] = {
 		.nr_blocks		= 128,
 		.name			= "W25X64",
 	},
+	{
+		.id			= WINBOND_ID_W25Q64,
+		.l2_page_size		= 8,
+		.pages_per_sector	= 16,
+		.sectors_per_block	= 16,
+		.nr_blocks		= 128,
+		.name			= "W25Q64",
+	},
 };
 
 static int winbond_wait_ready(struct spi_flash *flash, unsigned long timeout)
diff --git a/include/asm-arm/mach-types.h b/include/asm-arm/mach-types.h
index f1f7d93..21e305a 100644
--- a/include/asm-arm/mach-types.h
+++ b/include/asm-arm/mach-types.h
@@ -2547,6 +2547,8 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_BCMRING_SP_WQVGA     2564
 #define MACH_TYPE_BCMRING_CUSTOM       2565
 #define MACH_TYPE_ACER_S200            2566
+//#define MACH_TYPE_DAVINCI_DA850_SDI         2567
+#define MACH_TYPE_DAVINCI_DA850_SDI         2596
 
 #ifdef CONFIG_ARCH_EBSA110
 # ifdef machine_arch_type
@@ -32968,6 +32970,18 @@ extern unsigned int __machine_arch_type;
 # define machine_is_acer_s200()	(0)
 #endif
 
+#ifdef CONFIG_MACH_DAVINCI_DA850_SDI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DA850_SDI
+# endif
+# define machine_is_davinci_da850_sdi()	(machine_arch_type == MACH_TYPE_DAVINCI_DA850_SDI)
+#else
+# define machine_is_davinci_da850_sdi()	(0)
+#endif
+
 /*
  * These have not yet been registered
  */
diff --git a/include/configs/da850sdi.h b/include/configs/da850sdi.h
new file mode 100644
index 0000000..be361be
--- /dev/null
+++ b/include/configs/da850sdi.h
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) 2008 Texas Instruments, Inc <www.ti.com>
+ *
+ * Based on davinci_dvevm.h. Original Copyrights follow:
+ *
+ * Copyright (C) 2007 Sergey Kubushyn <ksi@koi8.net>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * Board
+ */
+#define	CONFIG_USE_SPIFLASH
+#undef	CONFIG_USE_NAND
+#undef	CONFIG_SYS_USE_NOR
+
+/*
+ * SoC Configuration
+ */
+#define CONFIG_MACH_DAVINCI_DA850_SDI
+#define CONFIG_ARM926EJS		/* arm926ejs CPU core */
+#define CONFIG_SOC_DA8XX		/* TI DA8xx SoC */
+#define CONFIG_SYS_CLK_FREQ		clk_get(DAVINCI_ARM_CLKID)
+#define CONFIG_SYS_OSCIN_FREQ		24000000
+#define CONFIG_SYS_TIMERBASE		DAVINCI_TIMER0_BASE
+#define CONFIG_SYS_HZ_CLOCK		clk_get(DAVINCI_AUXCLK_CLKID)
+#define CONFIG_SYS_HZ			1000
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_SKIP_RELOCATE_UBOOT	/* to a proper address, init done */
+
+/*
+ * Memory Info
+ */
+#define CONFIG_SYS_MALLOC_LEN	(0x10000 + 1*1024*1024) /* malloc() len */
+#define CONFIG_SYS_GBL_DATA_SIZE	128 /* reserved for initial data */
+#define PHYS_SDRAM_1		DAVINCI_DDR_EMIF_DATA_BASE /* DDR Start */
+#define PHYS_SDRAM_1_SIZE	(64 << 20) /* SDRAM size 64MB */
+#define CONFIG_SYS_MEMTEST_START	PHYS_SDRAM_1 + 0x2000000 /* memtest start addr */
+#define CONFIG_SYS_MEMTEST_END 	(PHYS_SDRAM_1 + 0x2000000 + 32*1024*1024) /* 32MB test */
+#define CONFIG_NR_DRAM_BANKS	1 /* we have 1 bank of DRAM */
+#define CONFIG_STACKSIZE	(256*1024) /* regular stack */
+
+/*
+ * Serial Driver info
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	-4	/* NS16550 register size */
+#define CONFIG_SYS_NS16550_COM1	DAVINCI_UART2_BASE /* Base address of UART2 */
+#define CONFIG_SYS_NS16550_CLK	clk_get(DAVINCI_UART2_CLKID)
+#define CONFIG_CONS_INDEX	1		/* use UART0 for console */
+#define CONFIG_BAUDRATE		115200		/* Default baud rate */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_SPI
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_WINBOND
+#define CONFIG_DAVINCI_SPI
+#define CONFIG_SYS_SPI_BASE		DAVINCI_SPI1_BASE
+#define CONFIG_SYS_SPI_CLK		clk_get(DAVINCI_SPI1_CLKID)
+#define CONFIG_SF_DEFAULT_SPEED		30000000
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+
+/*
+ * I2C Configuration
+ */
+#define CONFIG_HARD_I2C
+#define CONFIG_DRIVER_DAVINCI_I2C
+#define CONFIG_SYS_I2C_SPEED		25000 /* 100Kbps won't work, H/W bug */
+#define CONFIG_SYS_I2C_SLAVE		10 /* Bogus, master-only in U-Boot */
+
+/*
+ * I2C EEPROM definitions for catalyst 24W256 EEPROM chip
+ */
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	2
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x50
+#define CONFIG_SYS_I2C_EXPANDER_ADDR	0x20
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS	6
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS	20
+
+/*
+ * Network & Ethernet Configuration
+ */
+#define	CONFIG_DRIVER_TI_EMAC
+#ifdef CONFIG_DRIVER_TI_EMAC
+#define CONFIG_MII
+#define CONFIG_DRIVER_TI_EMAC_USE_RMII
+#define CONFIG_BOOTP_DEFAULT
+#define CONFIG_BOOTP_DNS
+#define CONFIG_BOOTP_DNS2
+#define CONFIG_BOOTP_SEND_HOSTNAME
+#define CONFIG_NET_RETRY_COUNT	10
+#define CONFIG_NET_MULTI
+#endif
+
+/*
+ * Flash & Environment
+ */
+#ifdef CONFIG_USE_NAND
+#undef CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_NAND_DAVINCI
+#define CONFIG_SYS_NO_FLASH
+#define CONFIG_ENV_IS_IN_NAND		/* U-Boot env in NAND Flash  */
+#define CONFIG_ENV_OFFSET		0x0 /* Block 0--not used by bootcode */
+#define CONFIG_ENV_SIZE			(128 << 10)
+#define	CONFIG_SYS_NAND_USE_FLASH_BBT
+#define CONFIG_SYS_NAND_4BIT_HW_ECC_OOBFIRST
+#define	CONFIG_SYS_NAND_PAGE_2K
+#define CONFIG_SYS_NAND_CS		3
+#define CONFIG_SYS_NAND_BASE		DAVINCI_ASYNC_EMIF_DATA_CE3_BASE
+#define CONFIG_SYS_CLE_MASK		0x10
+#define CONFIG_SYS_ALE_MASK		0x8
+#undef CONFIG_SYS_NAND_HW_ECC
+#define CONFIG_SYS_MAX_NAND_DEVICE	1 /* Max number of NAND devices */
+#define NAND_MAX_CHIPS			1
+#define DEF_BOOTM			""
+#endif
+
+#ifdef CONFIG_SYS_USE_NOR
+#define CONFIG_ENV_IS_IN_FLASH
+#undef CONFIG_SYS_NO_FLASH
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_PROTECTION
+#define CONFIG_SYS_MAX_FLASH_BANKS	1 /* max number of flash banks */
+#define CONFIG_SYS_FLASH_SECT_SZ	(128 << 10) /* 128KB */
+#define CONFIG_ENV_OFFSET		(CONFIG_SYS_FLASH_SECT_SZ * 3)
+#define CONFIG_SYS_FLASH_BASE		DAVINCI_ASYNC_EMIF_DATA_CE2_BASE
+#define PHYS_FLASH_SIZE			(8 << 20) /* Flash size 8MB */
+#define CONFIG_SYS_MAX_FLASH_SECT	(PHYS_FLASH_SIZE/CONFIG_SYS_FLASH_SECT_SZ) + 3
+#define CONFIG_ENV_SECT_SIZE		CONFIG_SYS_FLASH_SECT_SZ
+#endif
+
+#ifdef CONFIG_USE_SPIFLASH
+#undef CONFIG_ENV_IS_IN_FLASH
+#undef CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SIZE			(64 << 10)
+#define CONFIG_ENV_OFFSET		(256 << 10)
+#define CONFIG_ENV_SECT_SIZE		(64 << 10)	
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+/* SD/MMC */
+#define CONFIG_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_DAVINCI_MMC
+#define CONFIG_MMC_MBLOCK
+
+#ifdef CONFIG_MMC
+#define CONFIG_DOS_PARTITION
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_MMC
+#undef CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+#undef CONFIG_ENV_SIZE
+#undef CONFIG_ENV_OFFSET
+#define CONFIG_ENV_SIZE		(16 << 10)	/* 16 KiB */
+#define CONFIG_ENV_OFFSET	(51 << 9)	/* Sector 51 */
+#undef CONFIG_ENV_IS_IN_FLASH
+#undef CONFIG_ENV_IS_IN_NAND
+#undef CONFIG_ENV_IS_IN_SPI_FLASH
+#endif
+
+
+/*
+ * USB  configuration
+ */
+#define CONFIG_USB_DA8XX      /* Platform hookup to MUSB controller */
+#define CONFIG_MUSB_HCD
+
+/*
+ * U-Boot general configuration
+ */
+#undef CONFIG_USE_IRQ			/* No IRQ/FIQ in U-Boot */
+#define CONFIG_MISC_INIT_R
+#undef CONFIG_BOOTDELAY
+#define CONFIG_BOOTFILE		"uImage" /* Boot file name */
+#define CONFIG_SYS_PROMPT	"U-Boot > " /* Command Prompt */
+#define CONFIG_SYS_CBSIZE	1024 /* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE	(CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS	16 /* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE /* Boot Args Buffer Size */
+#define CONFIG_SYS_LOAD_ADDR	(PHYS_SDRAM_1 + 0x700000)
+#define CONFIG_VERSION_VARIABLE
+#define CONFIG_AUTO_COMPLETE	/* Won't work with hush so far, may be later */
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_CRC32_VERIFY
+#define CONFIG_MX_CYCLIC
+
+/*
+ * Linux Information
+ */
+#define LINUX_BOOT_PARAM_ADDR	(PHYS_SDRAM_1 + 0x100)
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_BOOTARGS		"mem=32M console=ttyS2,115200n8 root=/dev/mmcblk0p2 rw rootwait ip=off"
+#define CONFIG_BOOTCOMMAND	"if mmc rescan 0; then if fatload mmc 0 0xc0600000 boot.scr; then source 0xc0600000; else fatload mmc 0 0xc0700000 uImage; bootm c0700000; fi; else sf probe 0; sf read 0xc0700000 0x80000 0x220000; bootm 0xc0700000; fi"
+#define CONFIG_BOOTDELAY	3
+/*
+ * U-Boot commands
+ */
+#include <config_cmd_default.h>
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_DIAG
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_SAVES
+#define CONFIG_CMD_MEMORY
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_SETGETDCR
+#undef CONFIG_CMD_EEPROM
+
+#ifndef CONFIG_DRIVER_TI_EMAC
+#undef CONFIG_CMD_NET
+#undef CONFIG_CMD_DHCP
+#undef CONFIG_CMD_MII
+#undef CONFIG_CMD_PING
+#endif
+
+#ifdef CONFIG_USE_NAND
+#undef CONFIG_CMD_FLASH
+#undef CONFIG_CMD_IMLS
+#define CONFIG_CMD_NAND
+#endif
+
+#ifdef CONFIG_USE_SPIFLASH
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_FLASH
+#define CONFIG_CMD_SPI
+#define CONFIG_CMD_SF
+#define CONFIG_CMD_SAVEENV
+#endif
+
+#if !defined(CONFIG_USE_NAND) && \
+	!defined(CONFIG_SYS_USE_NOR) && \
+	!defined(CONFIG_USE_SPIFLASH)
+#define CONFIG_ENV_IS_NOWHERE
+#define CONFIG_SYS_NO_FLASH
+#define CONFIG_ENV_SIZE		(16 << 10)
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_FLASH
+#undef CONFIG_CMD_ENV
+#endif
+
+#ifdef CONFIG_USB_DA8XX
+
+#ifdef CONFIG_MUSB_HCD
+#define CONFIG_CMD_USB		/* inclue support for usb       */
+
+#define CONFIG_USB_STORAGE	/* MSC class support */
+#define CONFIG_CMD_STORAGE	/* inclue support for usb       */
+#define CONFIG_CMD_FAT		/* inclue support for FAT/storage*/
+#define CONFIG_DOS_PARTITION	/* inclue support for FAT/storage*/
+
+#ifdef CONFIG_USB_KEYBOARD
+#define CONFIG_SYS_USB_EVENT_POLL
+#define CONFIG_PREBOOT "usb start"
+#endif /* CONFIG_USB_KEYBOARD */
+
+#endif /* CONFIG_MUSB_HCD */
+
+#ifdef CONFIG_MUSB_UDC
+/* USB device configuration */
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	1
+/* Change these to suit your needs */
+#define CONFIG_USBD_VENDORID		0x0451
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Texas Instruments"
+#define CONFIG_USBD_PRODUCT_NAME	"DA850EVM"
+#endif /* CONFIG_MUSB_UDC */
+
+#endif /* CONFIG_USB_DA8XX */
+
+#endif /* __CONFIG_H */
-- 
1.7.1

