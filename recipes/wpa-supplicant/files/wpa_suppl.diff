diff -BNcr wpa_supplicant-0.5.7/.config wpa_view/wpa_suppl/.config
*** wpa_supplicant-0.5.7/.config	Thu Jan  1 02:00:00 1970
--- wpa_view/wpa_suppl/.config	Wed Jun  9 13:29:35 2010
***************
*** 0 ****
--- 1,308 ----
+ # Example wpa_supplicant build time configuration
+ #
+ # This file lists the configuration options that are used when building the
+ # hostapd binary. All lines starting with # are ignored. Configuration option
+ # lines must be commented out complete, if they are not to be included, i.e.,
+ # just setting VARIABLE=n is not disabling that variable.
+ #
+ # This file is included in Makefile, so variables like CFLAGS and LIBS can also
+ # be modified from here. In most cases, these lines should use += in order not
+ # to override previous values of the variables.
+ 
+ # Some Red Hat versions seem to include kerberos header files from OpenSSL, but
+ # the kerberos files are not in the default include path. Following line can be
+ # used to fix build issues on such systems (krb5.h not found).
+ #CFLAGS += -I/usr/include/kerberos
+ 
+ # Example configuration for various cross-compilation platforms
+ 
+ #### sveasoft (e.g., for Linksys WRT54G) ######################################
+ #CC=mipsel-uclibc-gcc
+ #CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+ #CFLAGS += -Os
+ #CPPFLAGS += -I../src/include -I../../src/router/openssl/include
+ #LIBS += -L/opt/brcm/hndtools-mipsel-uclibc-0.9.19/lib -lssl
+ ###############################################################################
+ 
+ #### openwrt (e.g., for Linksys WRT54G) #######################################
+ #CC=mipsel-uclibc-gcc
+ #CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+ #CFLAGS += -Os
+ #CPPFLAGS=-I../src/include -I../openssl-0.9.7d/include \
+ #	-I../WRT54GS/release/src/include
+ #LIBS = -lssl
+ ###############################################################################
+ 
+ 
+ # Driver interface for Host AP driver
+ #CONFIG_DRIVER_HOSTAP=y
+ 
+ # Driver interface for Agere driver
+ #CONFIG_DRIVER_HERMES=y
+ # Change include directories to match with the local setup
+ #CFLAGS += -I../../hcf -I../../include -I../../include/hcf
+ #CFLAGS += -I../../include/wireless
+ 
+ # Driver interface for madwifi driver
+ #CONFIG_DRIVER_MADWIFI=y
+ # Change include directories to match with the local setup
+ #CFLAGS += -I../madwifi/wpa
+ 
+ # Driver interface for Prism54 driver
+ # (Note: Prism54 is not yet supported, i.e., this will not work as-is and is
+ # for developers only)
+ #CONFIG_DRIVER_PRISM54=y
+ 
+ # Driver interface for ndiswrapper
+ #CONFIG_DRIVER_NDISWRAPPER=y
+ 
+ # Driver interface for Atmel driver
+ #CONFIG_DRIVER_ATMEL=y
+ 
+ # Driver interface for Broadcom driver
+ #CONFIG_DRIVER_BROADCOM=y
+ # Example path for wlioctl.h; change to match your configuration
+ #CFLAGS += -I/opt/WRT54GS/release/src/include
+ 
+ # Driver interface for Intel ipw2100/2200 driver
+ #CONFIG_DRIVER_IPW=y
+ 
+ # Driver interface for generic Linux wireless extensions
+ CONFIG_DRIVER_WEXT=y
+ 
+ # Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
+ #CONFIG_DRIVER_BSD=y
+ #CFLAGS += -I/usr/local/include
+ #LIBS += -L/usr/local/lib
+ 
+ # Driver interface for Windows NDIS
+ #CONFIG_DRIVER_NDIS=y
+ #CFLAGS += -I/usr/include/w32api/ddk
+ #LIBS += -L/usr/local/lib
+ # For native build using mingw
+ #CONFIG_NATIVE_WINDOWS=y
+ # Additional directories for cross-compilation on Linux host for mingw target
+ #CFLAGS += -I/opt/mingw/mingw32/include/ddk
+ #LIBS += -L/opt/mingw/mingw32/lib
+ #CC=mingw32-gcc
+ # By default, driver_ndis uses WinPcap for low-level operations. This can be
+ # replaced with the following option which replaces WinPcap calls with NDISUIO.
+ # However, this requires that WZC is disabled (net stop wzcsvc) before starting
+ # wpa_supplicant.
+ # CONFIG_USE_NDISUIO=y
+ 
+ # Driver interface for development testing
+ #CONFIG_DRIVER_TEST=y
+ 
+ # Driver interface for wired Ethernet drivers
+ #CONFIG_DRIVER_WIRED=y
+ 
+ # Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
+ # included)
+ CONFIG_IEEE8021X_EAPOL=y
+ 
+ # EAP-MD5
+ CONFIG_EAP_MD5=y
+ 
+ # EAP-MSCHAPv2
+ CONFIG_EAP_MSCHAPV2=y
+ 
+ # EAP-TLS
+ CONFIG_EAP_TLS=y
+ 
+ # EAL-PEAP
+ CONFIG_EAP_PEAP=y
+ 
+ # EAP-TTLS
+ CONFIG_EAP_TTLS=y
+ 
+ # EAP-GTC
+ #CONFIG_EAP_GTC=y
+ 
+ # EAP-OTP
+ #CONFIG_EAP_OTP=y
+ 
+ # EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
+ CONFIG_EAP_SIM=y
+ 
+ # EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
+ #CONFIG_EAP_PSK=y
+ 
+ # EAP-PAX
+ #CONFIG_EAP_PAX=y
+ 
+ # LEAP
+ #CONFIG_EAP_LEAP=y
+ 
+ # EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
+ #CONFIG_EAP_AKA=y
+ 
+ # EAP-SAKE
+ #CONFIG_EAP_SAKE=y
+ 
+ # EAP-GPSK
+ #CONFIG_EAP_GPSK=y
+ # Include support for optional SHA256 cipher suite in EAP-GPSK
+ #CONFIG_EAP_GPSK_SHA256=y
+ 
+ # PKCS#12 (PFX) support (used to read private key and certificate file from
+ # a file that usually has extension .p12 or .pfx)
+ #CONFIG_PKCS12=y
+ 
+ # Smartcard support (i.e., private key on a smartcard), e.g., with openssl
+ # engine.
+ #CONFIG_SMARTCARD=y
+ 
+ # PC/SC interface for smartcards (USIM, GSM SIM)
+ # Enable this if EAP-SIM or EAP-AKA is included
+ #CONFIG_PCSC=y
+ 
+ # Development testing
+ #CONFIG_EAPOL_TEST=y
+ 
+ # Select control interface backend for external programs, e.g, wpa_cli:
+ # unix = UNIX domain sockets (default for Linux/*BSD)
+ # udp = UDP sockets using localhost (127.0.0.1)
+ # named_pipe = Windows Named Pipe (default for Windows)
+ # y = use default (backwards compatibility)
+ # If this option is commented out, control interface is not included in the
+ # build.
+ CONFIG_CTRL_IFACE=y
+ 
+ # Include support for GNU Readline and History Libraries in wpa_cli.
+ # When building a wpa_cli binary for distribution, please note that these
+ # libraries are licensed under GPL and as such, BSD license may not apply for
+ # the resulting binary.
+ #CONFIG_READLINE=y
+ 
+ # Remove debugging code that is printing out debug message to stdout.
+ # This can be used to reduce the size of the wpa_supplicant considerably
+ # if debugging code is not needed. The size reduction can be around 35%
+ # (e.g., 90 kB).
+ #CONFIG_NO_STDOUT_DEBUG=y
+ 
+ # Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
+ # 35-50 kB in code size.
+ #CONFIG_NO_WPA=y
+ 
+ # Remove WPA2 support. This allows WPA to be used, but removes WPA2 code to
+ # save about 1 kB in code size when building only WPA-Personal (no EAP support)
+ # or 6 kB if building for WPA-Enterprise.
+ #CONFIG_NO_WPA2=y
+ 
+ # Remove AES extra functions. This can be used to reduce code size by about
+ # 1.5 kB by removing extra AES modes that are not needed for commonly used
+ # client configurations (they are needed for some EAP types).
+ #CONFIG_NO_AES_EXTRAS=y
+ 
+ # Select configuration backend:
+ # file = text file (e.g., wpa_supplicant.conf)
+ # winreg = Windows registry (see win_example.reg for an example)
+ CONFIG_BACKEND=file
+ 
+ # Select program entry point implementation:
+ # main = UNIX/POSIX like main() function (default)
+ # main_winsvc = Windows service (read parameters from registry)
+ # main_none = Very basic example (development use only)
+ #CONFIG_MAIN=main
+ 
+ # Select wrapper for operatins system and C library specific functions
+ # unix = UNIX/POSIX like systems (default)
+ # win32 = Windows systems
+ # none = Empty template
+ #CONFIG_OS=unix
+ 
+ # Select event loop implementation
+ # eloop = select() loop (default)
+ # eloop_win = Windows events and WaitForMultipleObject() loop
+ # eloop_none = Empty template
+ #CONFIG_ELOOP=eloop
+ 
+ # Select layer 2 packet implementation
+ # linux = Linux packet socket (default)
+ # pcap = libpcap/libdnet/WinPcap
+ # freebsd = FreeBSD libpcap
+ # winpcap = WinPcap with receive thread
+ # ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
+ # none = Empty template
+ #CONFIG_L2_PACKET=linux
+ 
+ # PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
+ #CONFIG_PEERKEY=y
+ 
+ # IEEE 802.11w (management frame protection)
+ # This version is an experimental implementation based on IEEE 802.11w/D1.0
+ # draft and is subject to change since the standard has not yet been finalized.
+ # Driver support is also needed for IEEE 802.11w.
+ #CONFIG_IEEE80211W=y
+ 
+ # Select TLS implementation
+ # openssl = OpenSSL (default)
+ # gnutls = GnuTLS (needed for TLS/IA, see also CONFIG_GNUTLS_EXTRA)
+ # internal = Internal TLSv1 implementation (experimental)
+ # none = Empty template
+ #CONFIG_TLS=internal
+ CONFIG_TLS=openssl
+ 
+ # Whether to enable TLS/IA support, which is required for EAP-TTLSv1.
+ # You need CONFIG_TLS=gnutls for this to have any effect. Please note that
+ # even though the core GnuTLS library is released under LGPL, this extra
+ # library uses GPL and as such, the terms of GPL apply to the combination
+ # of wpa_supplicant and GnuTLS if this option is enabled. BSD license may not
+ # apply for distribution of the resulting binary.
+ #CONFIG_GNUTLS_EXTRA=y
+ 
+ # If CONFIG_TLS=internal is used, additional library and include paths are
+ # needed for LibTomMath. Alternatively, an integrated, minimal version of
+ # LibTomMath can be used. See beginning of libtommath.c for details on benefits
+ # and drawbacks of this option.
+ CONFIG_INTERNAL_LIBTOMMATH=y
+ #ifndef CONFIG_INTERNAL_LIBTOMMATH
+ #LTM_PATH=libtommath-0.39
+ #CFLAGS += -I$(LTM_PATH)
+ #LIBS += -L$(LTM_PATH)
+ #LIBS_p += -L$(LTM_PATH)
+ #endif
+ 
+ # Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
+ # This is only for Windows builds and requires WMI-related header files and
+ # WbemUuid.Lib from Platform SDK even when building with MinGW.
+ #CONFIG_NDIS_EVENTS_INTEGRATED=y
+ #PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
+ 
+ # Add support for DBus control interface
+ #CONFIG_CTRL_IFACE_DBUS=y
+ 
+ # Add support for loading EAP methods dynamically as shared libraries.
+ # When this option is enabled, each EAP method can be either included
+ # statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
+ # Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
+ # be loaded in the beginning of the wpa_supplicant configuration file
+ # (see load_dynamic_eap parameter in the example file) before being used in
+ # the network blocks.
+ #
+ # Note that some shared parts of EAP methods are included in the main program
+ # and in order to be able to use dynamic EAP methods using these parts, the
+ # main program must have been build with the EAP method enabled (=y or =dyn).
+ # This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
+ # unless at least one of them was included in the main build to force inclusion
+ # of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
+ # in the main build to be able to load these methods dynamically.
+ #
+ # Please also note that using dynamic libraries will increase the total binary
+ # size. Thus, it may not be the best option for targets that have limited
+ # amount of memory/flash.
+ #CONFIG_DYNAMIC_EAP_METHODS=y
+ 
+ # Include client MLME (management frame processing).
+ # This can be used to move MLME processing of Devicescape IEEE 802.11 stack
+ # into user space.
+ #CONFIG_CLIENT_MLME=y
+ # Currently, driver_devicescape.c build requires some additional parameters
+ # to be able to include some of the kernel header files. Following lines can
+ # be used to set these (WIRELESS_DEV must point to the root directory of the
+ # wireless-dev.git tree).
+ #WIRELESS_DEV=/usr/src/wireless-dev
+ #CFLAGS += -I$(WIRELESS_DEV)/include
+ #CFLAGS += -I$(WIRELESS_DEV)/net/d80211
+ #CFLAGS += -D_LINUX_TYPES_H
diff -BNcr wpa_supplicant-0.5.7/.cvsignore wpa_view/wpa_suppl/.cvsignore
*** wpa_supplicant-0.5.7/.cvsignore	Sat Feb 12 06:29:55 2005
--- wpa_view/wpa_suppl/.cvsignore	Thu Jan  1 02:00:00 1970
***************
*** 1,7 ****
- *.d
- .config
- eapol_test
- preauth_test
- wpa_cli
- wpa_passphrase
- wpa_supplicant
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/COPYING wpa_view/wpa_suppl/COPYING
*** wpa_supplicant-0.5.7/COPYING	Sun Dec 31 23:41:44 2006
--- wpa_view/wpa_suppl/COPYING	Thu Jan  1 02:00:00 1970
***************
*** 1,340 ****
- 		    GNU GENERAL PUBLIC LICENSE
- 		       Version 2, June 1991
- 
-  Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-                        51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-  Everyone is permitted to copy and distribute verbatim copies
-  of this license document, but changing it is not allowed.
- 
- 			    Preamble
- 
-   The licenses for most software are designed to take away your
- freedom to share and change it.  By contrast, the GNU General Public
- License is intended to guarantee your freedom to share and change free
- software--to make sure the software is free for all its users.  This
- General Public License applies to most of the Free Software
- Foundation's software and to any other program whose authors commit to
- using it.  (Some other Free Software Foundation software is covered by
- the GNU Library General Public License instead.)  You can apply it to
- your programs, too.
- 
-   When we speak of free software, we are referring to freedom, not
- price.  Our General Public Licenses are designed to make sure that you
- have the freedom to distribute copies of free software (and charge for
- this service if you wish), that you receive source code or can get it
- if you want it, that you can change the software or use pieces of it
- in new free programs; and that you know you can do these things.
- 
-   To protect your rights, we need to make restrictions that forbid
- anyone to deny you these rights or to ask you to surrender the rights.
- These restrictions translate to certain responsibilities for you if you
- distribute copies of the software, or if you modify it.
- 
-   For example, if you distribute copies of such a program, whether
- gratis or for a fee, you must give the recipients all the rights that
- you have.  You must make sure that they, too, receive or can get the
- source code.  And you must show them these terms so they know their
- rights.
- 
-   We protect your rights with two steps: (1) copyright the software, and
- (2) offer you this license which gives you legal permission to copy,
- distribute and/or modify the software.
- 
-   Also, for each author's protection and ours, we want to make certain
- that everyone understands that there is no warranty for this free
- software.  If the software is modified by someone else and passed on, we
- want its recipients to know that what they have is not the original, so
- that any problems introduced by others will not reflect on the original
- authors' reputations.
- 
-   Finally, any free program is threatened constantly by software
- patents.  We wish to avoid the danger that redistributors of a free
- program will individually obtain patent licenses, in effect making the
- program proprietary.  To prevent this, we have made it clear that any
- patent must be licensed for everyone's free use or not licensed at all.
- 
-   The precise terms and conditions for copying, distribution and
- modification follow.
- 
- 		    GNU GENERAL PUBLIC LICENSE
-    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
- 
-   0. This License applies to any program or other work which contains
- a notice placed by the copyright holder saying it may be distributed
- under the terms of this General Public License.  The "Program", below,
- refers to any such program or work, and a "work based on the Program"
- means either the Program or any derivative work under copyright law:
- that is to say, a work containing the Program or a portion of it,
- either verbatim or with modifications and/or translated into another
- language.  (Hereinafter, translation is included without limitation in
- the term "modification".)  Each licensee is addressed as "you".
- 
- Activities other than copying, distribution and modification are not
- covered by this License; they are outside its scope.  The act of
- running the Program is not restricted, and the output from the Program
- is covered only if its contents constitute a work based on the
- Program (independent of having been made by running the Program).
- Whether that is true depends on what the Program does.
- 
-   1. You may copy and distribute verbatim copies of the Program's
- source code as you receive it, in any medium, provided that you
- conspicuously and appropriately publish on each copy an appropriate
- copyright notice and disclaimer of warranty; keep intact all the
- notices that refer to this License and to the absence of any warranty;
- and give any other recipients of the Program a copy of this License
- along with the Program.
- 
- You may charge a fee for the physical act of transferring a copy, and
- you may at your option offer warranty protection in exchange for a fee.
- 
-   2. You may modify your copy or copies of the Program or any portion
- of it, thus forming a work based on the Program, and copy and
- distribute such modifications or work under the terms of Section 1
- above, provided that you also meet all of these conditions:
- 
-     a) You must cause the modified files to carry prominent notices
-     stating that you changed the files and the date of any change.
- 
-     b) You must cause any work that you distribute or publish, that in
-     whole or in part contains or is derived from the Program or any
-     part thereof, to be licensed as a whole at no charge to all third
-     parties under the terms of this License.
- 
-     c) If the modified program normally reads commands interactively
-     when run, you must cause it, when started running for such
-     interactive use in the most ordinary way, to print or display an
-     announcement including an appropriate copyright notice and a
-     notice that there is no warranty (or else, saying that you provide
-     a warranty) and that users may redistribute the program under
-     these conditions, and telling the user how to view a copy of this
-     License.  (Exception: if the Program itself is interactive but
-     does not normally print such an announcement, your work based on
-     the Program is not required to print an announcement.)
- 
- These requirements apply to the modified work as a whole.  If
- identifiable sections of that work are not derived from the Program,
- and can be reasonably considered independent and separate works in
- themselves, then this License, and its terms, do not apply to those
- sections when you distribute them as separate works.  But when you
- distribute the same sections as part of a whole which is a work based
- on the Program, the distribution of the whole must be on the terms of
- this License, whose permissions for other licensees extend to the
- entire whole, and thus to each and every part regardless of who wrote it.
- 
- Thus, it is not the intent of this section to claim rights or contest
- your rights to work written entirely by you; rather, the intent is to
- exercise the right to control the distribution of derivative or
- collective works based on the Program.
- 
- In addition, mere aggregation of another work not based on the Program
- with the Program (or with a work based on the Program) on a volume of
- a storage or distribution medium does not bring the other work under
- the scope of this License.
- 
-   3. You may copy and distribute the Program (or a work based on it,
- under Section 2) in object code or executable form under the terms of
- Sections 1 and 2 above provided that you also do one of the following:
- 
-     a) Accompany it with the complete corresponding machine-readable
-     source code, which must be distributed under the terms of Sections
-     1 and 2 above on a medium customarily used for software interchange; or,
- 
-     b) Accompany it with a written offer, valid for at least three
-     years, to give any third party, for a charge no more than your
-     cost of physically performing source distribution, a complete
-     machine-readable copy of the corresponding source code, to be
-     distributed under the terms of Sections 1 and 2 above on a medium
-     customarily used for software interchange; or,
- 
-     c) Accompany it with the information you received as to the offer
-     to distribute corresponding source code.  (This alternative is
-     allowed only for noncommercial distribution and only if you
-     received the program in object code or executable form with such
-     an offer, in accord with Subsection b above.)
- 
- The source code for a work means the preferred form of the work for
- making modifications to it.  For an executable work, complete source
- code means all the source code for all modules it contains, plus any
- associated interface definition files, plus the scripts used to
- control compilation and installation of the executable.  However, as a
- special exception, the source code distributed need not include
- anything that is normally distributed (in either source or binary
- form) with the major components (compiler, kernel, and so on) of the
- operating system on which the executable runs, unless that component
- itself accompanies the executable.
- 
- If distribution of executable or object code is made by offering
- access to copy from a designated place, then offering equivalent
- access to copy the source code from the same place counts as
- distribution of the source code, even though third parties are not
- compelled to copy the source along with the object code.
- 
-   4. You may not copy, modify, sublicense, or distribute the Program
- except as expressly provided under this License.  Any attempt
- otherwise to copy, modify, sublicense or distribute the Program is
- void, and will automatically terminate your rights under this License.
- However, parties who have received copies, or rights, from you under
- this License will not have their licenses terminated so long as such
- parties remain in full compliance.
- 
-   5. You are not required to accept this License, since you have not
- signed it.  However, nothing else grants you permission to modify or
- distribute the Program or its derivative works.  These actions are
- prohibited by law if you do not accept this License.  Therefore, by
- modifying or distributing the Program (or any work based on the
- Program), you indicate your acceptance of this License to do so, and
- all its terms and conditions for copying, distributing or modifying
- the Program or works based on it.
- 
-   6. Each time you redistribute the Program (or any work based on the
- Program), the recipient automatically receives a license from the
- original licensor to copy, distribute or modify the Program subject to
- these terms and conditions.  You may not impose any further
- restrictions on the recipients' exercise of the rights granted herein.
- You are not responsible for enforcing compliance by third parties to
- this License.
- 
-   7. If, as a consequence of a court judgment or allegation of patent
- infringement or for any other reason (not limited to patent issues),
- conditions are imposed on you (whether by court order, agreement or
- otherwise) that contradict the conditions of this License, they do not
- excuse you from the conditions of this License.  If you cannot
- distribute so as to satisfy simultaneously your obligations under this
- License and any other pertinent obligations, then as a consequence you
- may not distribute the Program at all.  For example, if a patent
- license would not permit royalty-free redistribution of the Program by
- all those who receive copies directly or indirectly through you, then
- the only way you could satisfy both it and this License would be to
- refrain entirely from distribution of the Program.
- 
- If any portion of this section is held invalid or unenforceable under
- any particular circumstance, the balance of the section is intended to
- apply and the section as a whole is intended to apply in other
- circumstances.
- 
- It is not the purpose of this section to induce you to infringe any
- patents or other property right claims or to contest validity of any
- such claims; this section has the sole purpose of protecting the
- integrity of the free software distribution system, which is
- implemented by public license practices.  Many people have made
- generous contributions to the wide range of software distributed
- through that system in reliance on consistent application of that
- system; it is up to the author/donor to decide if he or she is willing
- to distribute software through any other system and a licensee cannot
- impose that choice.
- 
- This section is intended to make thoroughly clear what is believed to
- be a consequence of the rest of this License.
- 
-   8. If the distribution and/or use of the Program is restricted in
- certain countries either by patents or by copyrighted interfaces, the
- original copyright holder who places the Program under this License
- may add an explicit geographical distribution limitation excluding
- those countries, so that distribution is permitted only in or among
- countries not thus excluded.  In such case, this License incorporates
- the limitation as if written in the body of this License.
- 
-   9. The Free Software Foundation may publish revised and/or new versions
- of the General Public License from time to time.  Such new versions will
- be similar in spirit to the present version, but may differ in detail to
- address new problems or concerns.
- 
- Each version is given a distinguishing version number.  If the Program
- specifies a version number of this License which applies to it and "any
- later version", you have the option of following the terms and conditions
- either of that version or of any later version published by the Free
- Software Foundation.  If the Program does not specify a version number of
- this License, you may choose any version ever published by the Free Software
- Foundation.
- 
-   10. If you wish to incorporate parts of the Program into other free
- programs whose distribution conditions are different, write to the author
- to ask for permission.  For software which is copyrighted by the Free
- Software Foundation, write to the Free Software Foundation; we sometimes
- make exceptions for this.  Our decision will be guided by the two goals
- of preserving the free status of all derivatives of our free software and
- of promoting the sharing and reuse of software generally.
- 
- 			    NO WARRANTY
- 
-   11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
- FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
- OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
- PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
- OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
- TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
- PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
- REPAIR OR CORRECTION.
- 
-   12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
- WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
- REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
- INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
- OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
- TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
- YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
- PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
- POSSIBILITY OF SUCH DAMAGES.
- 
- 		     END OF TERMS AND CONDITIONS
- 
- 	    How to Apply These Terms to Your New Programs
- 
-   If you develop a new program, and you want it to be of the greatest
- possible use to the public, the best way to achieve this is to make it
- free software which everyone can redistribute and change under these terms.
- 
-   To do so, attach the following notices to the program.  It is safest
- to attach them to the start of each source file to most effectively
- convey the exclusion of warranty; and each file should have at least
- the "copyright" line and a pointer to where the full notice is found.
- 
-     <one line to give the program's name and a brief idea of what it does.>
-     Copyright (C) 19yy  <name of author>
- 
-     This program is free software; you can redistribute it and/or modify
-     it under the terms of the GNU General Public License as published by
-     the Free Software Foundation; either version 2 of the License, or
-     (at your option) any later version.
- 
-     This program is distributed in the hope that it will be useful,
-     but WITHOUT ANY WARRANTY; without even the implied warranty of
-     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-     GNU General Public License for more details.
- 
-     You should have received a copy of the GNU General Public License
-     along with this program; if not, write to the Free Software
-     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- 
- 
- Also add information on how to contact you by electronic and paper mail.
- 
- If the program is interactive, make it output a short notice like this
- when it starts in an interactive mode:
- 
-     Gnomovision version 69, Copyright (C) 19yy name of author
-     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-     This is free software, and you are welcome to redistribute it
-     under certain conditions; type `show c' for details.
- 
- The hypothetical commands `show w' and `show c' should show the appropriate
- parts of the General Public License.  Of course, the commands you use may
- be called something other than `show w' and `show c'; they could even be
- mouse-clicks or menu items--whatever suits your program.
- 
- You should also get your employer (if you work as a programmer) or your
- school, if any, to sign a "copyright disclaimer" for the program, if
- necessary.  Here is a sample; alter the names:
- 
-   Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-   `Gnomovision' (which makes passes at compilers) written by James Hacker.
- 
-   <signature of Ty Coon>, 1 April 1989
-   Ty Coon, President of Vice
- 
- This General Public License does not permit incorporating your program into
- proprietary programs.  If your program is a subroutine library, you may
- consider it more useful to permit linking proprietary applications with the
- library.  If this is what you want to do, use the GNU Library General
- Public License instead of this License.
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/ChangeLog wpa_view/wpa_suppl/ChangeLog
*** wpa_supplicant-0.5.7/ChangeLog	Sun Dec 31 23:31:58 2006
--- wpa_view/wpa_suppl/ChangeLog	Thu Jan  1 02:00:00 1970
***************
*** 1,971 ****
- ChangeLog for wpa_supplicant
- 
- 2006-12-31 - v0.5.7
- 	* updated EAP-SAKE to RFC 4763 and the IANA-allocated EAP type 48
- 	* updated EAP-PSK to use the IANA-allocated EAP type 47
- 	* fixed EAP-PAX key derivation
- 	* fixed EAP-PSK bit ordering of the Flags field
- 	* fixed EAP-PEAP/TTLS/FAST to use the correct EAP identifier in
- 	  tunnelled identity request (previously, the identifier from the outer
- 	  method was used, not the tunnelled identifier which could be
- 	  different)
- 	* fixed EAP-TTLS AVP parser processing for too short AVP lengths
- 	* added support for EAP-FAST authentication with inner methods that
- 	  generate MSK (e.g., EAP-MSCHAPv2 that was previously only supported
- 	  for PAC provisioning)
- 	* fixed dbus ctrl_iface to validate message interface before
- 	  dispatching to avoid a possible segfault [Bug 190]
- 	* fixed PeerKey key derivation to use the correct PRF label
- 	* updated Windows binary build to link against OpenSSL 0.9.8d and
- 	  added support for EAP-FAST
- 
- 2006-11-24 - v0.5.6
- 	* added experimental, integrated TLSv1 client implementation with the
- 	  needed X.509/ASN.1/RSA/bignum processing (this can be enabled by
- 	  setting CONFIG_TLS=internal and CONFIG_INTERNAL_LIBTOMMATH=y in
- 	  .config); this can be useful, e.g., if the target system does not
- 	  have a suitable TLS library and a minimal code size is required
- 	  (total size of this internal TLS/crypto code is bit under 50 kB on
- 	  x86 and the crypto code is shared by rest of the supplicant so some
- 	  of it was already required; TLSv1/X.509/ASN.1/RSA added about 25 kB)
- 	* removed STAKey handshake since PeerKey handshake has replaced it in
- 	  IEEE 802.11ma and there are no known deployments of STAKey
- 	* updated EAP Generalized Pre-Shared Key (EAP-GPSK) to use the latest
- 	  draft (draft-ietf-emu-eap-gpsk-01.txt)
- 	* added preliminary implementation of IEEE 802.11w/D1.0 (management
- 	  frame protection)
- 	  (Note: this requires driver support to work properly.)
- 	  (Note2: IEEE 802.11w is an unapproved draft and subject to change.)
- 	* fixed Windows named pipes ctrl_iface to not stop listening for
- 	  commands if client program opens a named pipe and closes it
- 	  immediately without sending a command
- 	* fixed USIM PIN status determination for the case that PIN is not
- 	  needed (this allows EAP-AKA to be used with USIM cards that do not
- 	  use PIN)
- 	* added support for reading 3G USIM AID from EF_DIR to allow EAP-AKA to
- 	  be used with cards that do not support file selection based on
- 	  partial AID
- 	* added support for matching the subjectAltName of the authentication
- 	  server certificate against multiple name components (e.g.,
- 	  altsubject_match="DNS:server.example.com;DNS:server2.example.com")
- 	* fixed EAP-SIM/AKA key derivation for re-authentication case (only
- 	  affects IEEE 802.1X with dynamic WEP keys)
- 	* changed ctrl_iface network configuration 'get' operations to not
- 	  return password/key material; if these fields are requested, "*"
- 	  will be returned if the password/key is set, but the value of the
- 	  parameter is not exposed
- 
- 2006-08-27 - v0.5.5
- 	* added support for building Windows version with UNICODE defined
- 	  (wide-char functions)
- 	* driver_ndis: fixed static WEP configuration to avoid race condition
- 	  issues with some NDIS drivers between association and setting WEP
- 	  keys
- 	* driver_ndis: added validation for IELength value in scan results to
- 	  avoid crashes when using buggy NDIS drivers [Bug 165]
- 	* fixed Release|Win32 target in the Visual Studio project files
- 	  (previously, only Debug|Win32 target was set properly)
- 	* changed control interface API call wpa_ctrl_pending() to allow it to
- 	  return -1 on error (e.g., connection lost); control interface clients
- 	  will need to make sure that they verify that the value is indeed >0
- 	  when determining whether there are pending messages
- 	* added an alternative control interface backend for Windows targets:
- 	  Named Pipe (CONFIG_CTRL_IFACE=named_pipe); this is now the default
- 	  control interface mechanism for Windows builds (previously, UDP to
- 	  localhost was used)
- 	* changed ctrl_interface configuration for UNIX domain sockets:
- 	  - deprecated ctrl_interface_group variable (it may be removed in
- 	    future versions)
- 	  - allow both directory and group be configured with ctrl_interface
- 	    in following format: DIR=/var/run/wpa_supplicant GROUP=wheel
- 	  - ctrl_interface=/var/run/wpa_supplicant is still supported for the
- 	    case when group is not changed
- 	* added support for controlling more than one interface per process in
- 	  Windows version
- 	* added a workaround for a case where the AP is using unknown address
- 	  (e.g., MAC address of the wired interface) as the source address for
- 	  EAPOL-Key frames; previously, that source address was used as the
- 	  destination for EAPOL-Key frames and in key derivation; now, BSSID is
- 	  used even if the source address does not match with it
- 	  (this resolves an interoperability issue with Thomson SpeedTouch 580)
- 	* added a workaround for UDP-based control interface (which was used in
- 	  Windows builds before this release) to prevent packets with forged
- 	  addresses from being accepted as local control requests
- 	* removed ndis_events.cpp and possibility of using external
- 	  ndis_events.exe; C version (ndis_events.c) is fully functional and
- 	  there is no desire to maintain two separate versions of this
- 	  implementation
- 	* ndis_events: Changed NDIS event notification design to use WMI to
- 	  learn the adapter description through Win32_PnPEntity class; this
- 	  should fix some cases where the adapter name was not recognized
- 	  correctly (e.g., with some USB WLAN adapters, e.g., Ralink RT2500
- 	  USB) [Bug 113]
- 	* fixed selection of the first network in ap_scan=2 mode; previously,
- 	  wpa_supplicant could get stuck in SCANNING state when only the first
- 	  network for enabled (e.g., after 'wpa_cli select_network 0')
- 	* winsvc: added support for configuring ctrl_interface parameters in
- 	  registry (ctrl_interface string value in
- 	  HKLM\SOFTWARE\wpa_supplicant\interfaces\0000 key); this new value is
- 	  required to enable control interface (previously, this was hardcoded
- 	  to be enabled)
- 	* allow wpa_gui subdirectory to be built with both Qt3 and Qt4
- 	* converted wpa_gui-qt4 subdirectory to use Qt4 specific project format
- 
- 2006-06-20 - v0.5.4
- 	* fixed build with CONFIG_STAKEY=y [Bug 143]
- 	* added support for doing MLME (IEEE 802.11 management frame
- 	  processing) in wpa_supplicant when using Devicescape IEEE 802.11
- 	  stack (wireless-dev.git tree)
- 	* added a new network block configuration option, fragment_size, to
- 	  configure the maximum EAP fragment size
- 	* driver_ndis: Disable WZC automatically for the selected interface to
- 	  avoid conflicts with two programs trying to control the radio; WZC
- 	  will be re-enabled (if it was enabled originally) when wpa_supplicant
- 	  is terminated
- 	* added an experimental TLSv1 client implementation
- 	  (CONFIG_TLS=internal) that can be used instead of an external TLS
- 	  library, e.g., to reduce total size requirement on systems that do
- 	  not include any TLS library by default (this is not yet complete;
- 	  basic functionality is there, but certificate validation is not yet
- 	  included)
- 	* added PeerKey handshake implementation for IEEE 802.11e
- 	  direct link setup (DLS) to replace STAKey handshake
- 	* fixed WPA PSK update through ctrl_iface for the case where the old
- 	  PSK was derived from an ASCII passphrase and the new PSK is set as
- 	  a raw PSK (hex string)
- 	* added new configuration option for identifying which network block
- 	  was used (id_str in wpa_supplicant.conf; included on
- 	  WPA_EVENT_CONNECT monitor event and as WPA_ID_STR environmental
- 	  variable in wpa_cli action scripts; in addition WPA_ID variable is
- 	  set to the current unique identifier that wpa_supplicant assigned
- 	  automatically for the network and that can be used with
- 	  GET_NETWORK/SET_NETWORK ctrl_iface commands)
- 	* wpa_cli action script is now called only when the connect/disconnect
- 	  status changes or when associating with a different network
- 	* fixed configuration parser not to remove CCMP from group cipher list
- 	  if WPA-None (adhoc) is used (pairwise=NONE in that case)
- 	* fixed integrated NDIS events processing not to hang the process due
- 	  to a missed change in eloop_win.c API in v0.5.3 [Bug 155]
- 	* added support for EAP Generalized Pre-Shared Key (EAP-GPSK,
- 	  draft-clancy-emu-eap-shared-secret-00.txt)
- 	* added Microsoft Visual Studio 2005 solution and project files for
- 	  build wpa_supplicant for Windows (see vs2005 subdirectory)
- 	* eloop_win: fixed unregistration of Windows events
- 	* l2_packet_winpcap: fixed a deadlock in deinitializing l2_packet
- 	  at the end of RSN pre-authentication and added unregistration of
- 	  a Windows event to avoid getting eloop_win stuck with an invalid
- 	  handle
- 	* driver_ndis: added support for selecting AP based on BSSID
- 	* added new environmental variable for wpa_cli action scripts:
- 	  WPA_CTRL_DIR is the current control interface directory
- 	* driver_ndis: added support for using NDISUIO instead of WinPcap for
- 	  OID set/query operations (CONFIG_USE_NDISUIO=y in .config); with new
- 	  l2_packet_ndis (CONFIG_L2_PACKET=ndis), this can be used to build
- 	  wpa_supplicant without requiring WinPcap; note that using NDISUIO
- 	  requires that WZC is disabled (net stop wzcsvc) since NDISUIO allows
- 	  only one application to open the device
- 	* changed NDIS driver naming to only include device GUID, e.g.,
- 	  {7EE3EFE5-C165-472F-986D-F6FBEDFE8C8D}, instead of including WinPcap
- 	  specific \Device\NPF_ prefix before the GUID; the prefix is still
- 	  allowed for backwards compatibility, but it is not required anymore
- 	  when specifying the interface
- 	* driver_ndis: re-initialize driver interface is the adapter is removed
- 	  and re-inserted [Bug 159]
- 	* driver_madwifi: fixed TKIP and CCMP sequence number configuration on
- 	  big endian hosts [Bug 146]
- 
- 2006-04-27 - v0.5.3
- 	* fixed EAP-GTC response to include correct user identity when run as
- 	  phase 2 method of EAP-FAST (i.e., EAP-FAST did not work in v0.5.2)
- 	* driver_ndis: Fixed encryption mode configuration for unencrypted
- 	  networks (some NDIS drivers ignored this, but others, e.g., Broadcom,
- 	  refused to associate with open networks) [Bug 106]
- 	* driver_ndis: use BSSID OID polling to detect when IBSS network is
- 	  formed even when ndis_events code is included since some NDIS drivers
- 	  do not generate media connect events in IBSS mode
- 	* config_winreg: allow global ctrl_interface parameter to be configured
- 	  in Windows registry
- 	* config_winreg: added support for saving configuration data into
- 	  Windows registry
- 	* added support for controlling network device operational state
- 	  (dormant/up) for Linux 2.6.17 to improve DHCP processing (see
- 	  http://www.flamewarmaster.de/software/dhcpclient/ for a DHCP client
- 	  that can use this information)
- 	* driver_wext: added support for WE-21 change to SSID configuration
- 	* driver_wext: fixed privacy configuration for static WEP keys mode
- 	  [Bug 140]
- 	* added an optional driver_ops callback for MLME-SETPROTECTION.request
- 	  primitive
- 	* added support for EAP-SAKE (no EAP method number allocated yet, so
- 	  this is using the same experimental type 255 as EAP-PSK)
- 	* added support for dynamically loading EAP methods (.so files) instead
- 	  of requiring them to be statically linked in; this is disabled by
- 	  default (see CONFIG_DYNAMIC_EAP_METHODS in defconfig for information
- 	  on how to use this)
- 
- 2006-03-19 - v0.5.2
- 	* do not try to use USIM APDUs when initializing PC/SC for SIM card
- 	  access for a network that has not enabled EAP-AKA
- 	* fixed EAP phase 2 Nak for EAP-{PEAP,TTLS,FAST} (this was broken in
- 	  v0.5.1 due to the new support for expanded EAP types)
- 	* added support for generating EAP Expanded Nak
- 	* try to fetch scan results once before requesting new scan when
- 	  starting up in ap_scan=1 mode (this can speed up initial association
- 	  a lot with, e.g., madwifi-ng driver)
- 	* added support for receiving EAPOL frames from a Linux bridge
- 	  interface (-bbr0 on command line)
- 	* fixed EAPOL re-authentication for sessions that used PMKSA caching
- 	* changed EAP method registration to use a dynamic list of methods
- 	  instead of a static list generated at build time
- 	* fixed PMKSA cache deinitialization not to use freed memory when
- 	  removing PMKSA entries
- 	* fixed a memory leak in EAP-TTLS re-authentication
- 	* reject WPA/WPA2 message 3/4 if it does not include any valid
- 	  WPA/RSN IE
- 	* driver_wext: added fallback to use SIOCSIWENCODE for setting auth_alg
- 	  if the driver does not support SIOCSIWAUTH
- 
- 2006-01-29 - v0.5.1
- 	* driver_test: added better support for multiple APs and STAs by using
- 	  a directory with sockets that include MAC address for each device in
- 	  the name (driver_param=test_dir=/tmp/test)
- 	* added support for EAP expanded type (vendor specific EAP methods)
- 	* added AP_SCAN command into ctrl_iface so that ap_scan configuration
- 	  option can be changed if needed
- 	* wpa_cli/wpa_gui: skip non-socket files in control directory when
- 	  using UNIX domain sockets; this avoids selecting an incorrect
- 	  interface (e.g., a PID file could be in this directory, even though
- 	  use of this directory for something else than socket files is not
- 	  recommended)
- 	* fixed TLS library deinitialization after RSN pre-authentication not
- 	  to disable TLS library for normal authentication
- 	* driver_wext: Remove null-termination from SSID length if the driver
- 	  used it; some Linux drivers do this and they were causing problems in
- 	  wpa_supplicant not finding matching configuration block. This change
- 	  would break a case where the SSID actually ends in '\0', but that is
- 	  not likely to happen in real use.
- 	* fixed PMKSA cache processing not to trigger deauthentication if the
- 	  current PMKSA cache entry is replaced with a valid new entry
- 	* fixed PC/SC initialization for ap_scan != 1 modes (this fixes
- 	  EAP-SIM and EAP-AKA with real SIM/USIM card when using ap_scan=0 or
- 	  ap_scan=2)
- 
- 2005-12-18 - v0.5.0 (beginning of 0.5.x development releases)
- 	* added experimental STAKey handshake implementation for IEEE 802.11e
- 	  direct link setup (DLS); note: this is disabled by default in both
- 	  build and runtime configuration (can be enabled with CONFIG_STAKEY=y
- 	  and stakey=1)
- 	* fixed EAP-SIM and EAP-AKA pseudonym and fast re-authentication to
- 	  decrypt AT_ENCR_DATA attributes correctly
- 	* fixed EAP-AKA to allow resynchronization within the same session
- 	* made code closer to ANSI C89 standard to make it easier to port to
- 	  other C libraries and compilers
- 	* started moving operating system or C library specific functions into
- 	  wrapper functions defined in os.h and implemented in os_*.c to make
- 	  code more portable
- 	* wpa_supplicant can now be built with Microsoft Visual C++
- 	  (e.g., with the freely available Toolkit 2003 version or Visual
- 	  C++ 2005 Express Edition and Platform SDK); see nmake.mak for an
- 	  example makefile for nmake
- 	* added support for using Windows registry for command line parameters
- 	  (CONFIG_MAIN=main_winsvc) and configuration data
- 	  (CONFIG_BACKEND=winreg); see win_example.reg for an example registry
- 	  contents; this version can be run both as a Windows service and as a
- 	  normal application; 'wpasvc.exe app' to start as applicant,
- 	  'wpasvc.exe reg <full path to wpasvc.exe>' to register a service,
- 	  'net start wpasvc' to start the service, 'wpasvc.exe unreg' to
- 	  unregister a service
- 	* made it possible to link ndis_events.exe functionality into
- 	  wpa_supplicant.exe by defining CONFIG_NDIS_EVENTS_INTEGRATED
- 	* added better support for multiple control interface backends
- 	  (CONFIG_CTRL_IFACE option); currently, 'unix' and 'udp' are supported
- 	* fixed PC/SC code to use correct length for GSM AUTH command buffer
- 	  and to not use pioRecvPci with SCardTransmit() calls; these were not
- 	  causing visible problems with pcsc-lite, but Windows Winscard.dll
- 	  refused the previously used parameters; this fixes EAP-SIM and
- 	  EAP-AKA authentication using SIM/USIM card under Windows
- 	* added new event loop implementation for Windows using
- 	  WaitForMultipleObject() instead of select() in order to allow waiting
- 	  for non-socket objects; this can be selected with
- 	  CONFIG_ELOOP=eloop_win in .config
- 	* added support for selecting l2_packet implementation in .config
- 	  (CONFIG_L2_PACKET; following options are available now: linux, pcap,
- 	  winpcap, freebsd, none)
- 	* added new l2_packet implementation for WinPcap
- 	  (CONFIG_L2_PACKET=winpcap) that uses a separate receive thread to
- 	  reduce latency in EAPOL receive processing from about 100 ms to about
- 	  3 ms
- 	* added support for EAP-FAST key derivation using other ciphers than
- 	  RC4-128-SHA for authentication and AES128-SHA for provisioning
- 	* added support for configuring CA certificate as DER file and as a
- 	  configuration blob
- 	* fixed private key configuration as configuration blob and added
- 	  support for using PKCS#12 as a blob
- 	* tls_gnutls: added support for using PKCS#12 files; added support for
- 	  session resumption
- 	* added support for loading trusted CA certificates from Windows
- 	  certificate store: ca_cert="cert_store://<name>", where <name> is
- 	  likely CA (Intermediate CA certificates) or ROOT (root certificates)
- 	* added C version of ndis_events.cpp and made it possible to build this
- 	  with MinGW so that CONFIG_NDIS_EVENTS_INTEGRATED can be used more
- 	  easily on cross-compilation builds
- 	* added wpasvc.exe into Windows binary release; this is an alternative
- 	  version of wpa_supplicant.exe with configuration backend using
- 	  Windows registry and with the entry point designed to run as a
- 	  Windows service
- 	* integrated ndis_events.exe functionality into wpa_supplicant.exe and
- 	  wpasvc.exe and removed this additional tool from the Windows binary
- 	  release since it is not needed anymore
- 	* load winscard.dll functions dynamically when building with MinGW
- 	  since MinGW does not yet include winscard library
- 
- 2005-11-20 - v0.4.7 (beginning of 0.4.x stable releases)
- 	* l2_packet_pcap: fixed wired IEEE 802.1X authentication with libpcap
- 	  and WinPcap to receive frames sent to PAE group address
- 	* disable EAP state machine when IEEE 802.1X authentication is not used
- 	  in order to get rid of bogus "EAP failed" messages
- 	* fixed OpenSSL error reporting to go through all pending errors to
- 	  avoid confusing reports of old errors being reported at later point
- 	  during handshake
- 	* fixed configuration file updating to not write empty variables
- 	  (e.g., proto or key_mgmt) that the file parser would not accept
- 	* fixed ADD_NETWORK ctrl_iface command to use the same default values
- 	  for variables as empty network definitions read from config file
- 	  would get
- 	* fixed EAP state machine to not discard EAP-Failure messages in many
- 	  cases (e.g., during TLS handshake)
- 	* fixed a infinite loop in private key reading if the configured file
- 	  cannot be parsed successfully
- 	* driver_madwifi: added support for madwifi-ng
- 	* wpa_gui: do not display password/PSK field contents
- 	* wpa_gui: added CA certificate configuration
- 	* driver_ndis: fixed scan request in ap_scan=2 mode not to change SSID
- 	* driver_ndis: include Beacon IEs in AssocInfo in order to notice if
- 	  the new AP is using different WPA/RSN IE
- 	* use longer timeout for IEEE 802.11 association to avoid problems with
- 	  drivers that may take more than five second to associate
- 
- 2005-10-27 - v0.4.6
- 	* allow fallback to WPA, if mixed WPA+WPA2 networks have mismatch in
- 	  RSN IE, but WPA IE would match with wpa_supplicant configuration
- 	* added support for named configuration blobs in order to avoid having
- 	  to use file system for external files (e.g., certificates);
- 	  variables can be set to "blob://<blob name>" instead of file path to
- 	  use a named blob; supported fields: pac_file, client_cert,
- 	  private_key
- 	* fixed RSN pre-authentication (it was broken in the clean up of WPA
- 	  state machine interface in v0.4.5)
- 	* driver_madwifi: set IEEE80211_KEY_GROUP flag for group keys to make
- 	  sure the driver configures broadcast decryption correctly
- 	* added ca_path (and ca_path2) configuration variables that can be used
- 	  to configure OpenSSL CA path, e.g., /etc/ssl/certs, for using the
- 	  system-wide trusted CA list
- 	* added support for starting wpa_supplicant without a configuration
- 	  file (-C argument must be used to set ctrl_interface parameter for
- 	  this case; in addition, -p argument can be used to provide
- 	  driver_param; these new arguments can also be used with a
- 	  configuration to override the values from the configuration)
- 	* added global control interface that can be optionally used for adding
- 	  and removing network interfaces dynamically (-g command line argument
- 	  for both wpa_supplicant and wpa_cli) without having to restart
- 	  wpa_supplicant process
- 	* wpa_gui:
- 	  - try to save configuration whenever something is modified
- 	  - added WEP key configuration
- 	  - added possibility to edit the current network configuration
- 	* driver_ndis: fixed driver polling not to increase frequency on each
- 	  received EAPOL frame due to incorrectly cancelled timeout
- 	* added simple configuration file examples (in examples subdirectory)
- 	* fixed driver_wext.c to filter wireless events based on ifindex to
- 	  avoid interfaces receiving events from other interfaces
- 	* delay sending initial EAPOL-Start couple of seconds to speed up
- 	  authentication for the most common case of Authenticator starting
- 	  EAP authentication immediately after association
- 
- 2005-09-25 - v0.4.5
- 	* added a workaround for clearing keys with ndiswrapper to allow
- 	  roaming from WPA enabled AP to plaintext one
- 	* added docbook documentation (doc/docbook) that can be used to
- 	  generate, e.g., man pages
- 	* l2_packet_linux: use socket type SOCK_DGRAM instead of SOCK_RAW for
- 	  PF_PACKET in order to prepare for network devices that do not use
- 	  Ethernet headers (e.g., network stack with native IEEE 802.11 frames)
- 	* use receipt of EAPOL-Key frame as a lower layer success indication
- 	  for EAP state machine to allow recovery from dropped EAP-Success
- 	  frame
- 	* cleaned up internal EAPOL frame processing by not including link
- 	  layer (Ethernet) header during WPA and EAPOL/EAP processing; this
- 	  header is added only when transmitted the frame; this makes it easier
- 	  to use wpa_supplicant on link layers that use different header than
- 	  Ethernet
- 	* updated EAP-PSK to use draft 9 by default since this can now be
- 	  tested with hostapd; removed support for draft 3, including
- 	  server_nai configuration option from network blocks
- 	* driver_wired: add PAE address to the multicast address list in order
- 	  to be able to receive EAPOL frames with drivers that do not include
- 	  these multicast addresses by default
- 	* driver_wext: add support for WE-19
- 	* added support for multiple configuration backends (CONFIG_BACKEND
- 	  option); currently, only 'file' is supported (i.e., the format used
- 	  in wpa_supplicant.conf)
- 	* added support for updating configuration ('wpa_cli save_config');
- 	  this is disabled by default and can be enabled with global
- 	  update_config=1 variable in wpa_supplicant.conf; this allows wpa_cli
- 	  and wpa_gui to store the configuration changes in a permanent store
- 	* added GET_NETWORK ctrl_iface command
- 	  (e.g., 'wpa_cli get_network 0 ssid')
- 
- 2005-08-21 - v0.4.4
- 	* replaced OpenSSL patch for EAP-FAST support
- 	  (openssl-tls-extensions.patch) with a more generic and correct
- 	  patch (the new patch is not compatible with the previous one, so the
- 	  OpenSSL library will need to be patched with the new patch in order
- 	  to be able to build wpa_supplicant with EAP-FAST support)
- 	* added support for using Windows certificate store (through CryptoAPI)
- 	  for client certificate and private key operations (EAP-TLS)
- 	  (see wpa_supplicant.conf for more information on how to configure
- 	  this with private_key)
- 	* ported wpa_gui to Windows
- 	* added Qt4 version of wpa_gui (wpa_gui-qt4 directory); this can be
- 	  built with the open source version of the Qt4 for Windows
- 	* allow non-WPA modes (e.g., IEEE 802.1X with dynamic WEP) to be used
- 	  with drivers that do not support WPA
- 	* ndis_events: fixed Windows 2000 support
- 	* added support for enabling/disabling networks from the list of all
- 	  configured networks ('wpa_cli enable_network <network id>' and
- 	  'wpa_cli disable_network <network id>')
- 	* added support for adding and removing network from the current
- 	  configuration ('wpa_cli add_network' and 'wpa_cli remove_network
- 	  <network id>'); added networks are disabled by default and they can
- 	  be enabled with enable_network command once the configuration is done
- 	  for the new network; note: configuration file is not yet updated, so
- 	  these new networks are lost when wpa_supplicant is restarted
- 	* added support for setting network configuration parameters through
- 	  the control interface, for example:
- 	  wpa_cli set_network 0 ssid "\"my network\""
- 	* fixed parsing of strings that include both " and # within double
- 	  quoted area (e.g., "start"#end")
- 	* added EAP workaround for PEAP session resumption: allow outer,
- 	  i.e., not tunneled, EAP-Success to terminate session since; this can
- 	  be disabled with eap_workaround=0
- 	  (this was allowed for PEAPv1 before, but now it is also allowed for
- 	  PEAPv0 since at least one RADIUS authentication server seems to be
- 	  doing this for PEAPv0, too)
- 	* wpa_gui: added preliminary support for adding new networks to the
- 	  wpa_supplicant configuration (double click on the scan results to
- 	  open network configuration)
- 
- 2005-06-26 - v0.4.3
- 	* removed interface for external EAPOL/EAP supplicant (e.g.,
- 	  Xsupplicant), (CONFIG_XSUPPLICANT_IFACE) since it is not required
- 	  anymore and is unlikely to be used by anyone
- 	* driver_ndis: fixed WinPcap 3.0 support
- 	* fixed build with CONFIG_DNET_PCAP=y on Linux
- 	* l2_packet: moved different implementations into separate files
- 	  (l2_packet_*.c)
- 
- 2005-06-12 - v0.4.2
- 	* driver_ipw: updated driver structures to match with ipw2200-1.0.4
- 	  (note: ipw2100-1.1.0 is likely to require an update to work with
- 	  this)
- 	* added support for using ap_scan=2 mode with multiple network blocks;
- 	  wpa_supplicant will go through the networks one by one until the
- 	  driver reports a successful association; this uses the same order for
- 	  networks as scan_ssid=1 scans, i.e., the priority field is ignored
- 	  and the network block order in the file is used instead
- 	* fixed a potential issue in RSN pre-authentication ending up using
- 	  freed memory if pre-authentication times out
- 	* added support for matching alternative subject name extensions of the
- 	  authentication server certificate; new configuration variables
- 	  altsubject_match and altsubject_match2
- 	* driver_ndis: added support for IEEE 802.1X authentication with wired
- 	  NDIS drivers
- 	* added support for querying private key password (EAP-TLS) through the
- 	  control interface (wpa_cli/wpa_gui) if one is not included in the
- 	  configuration file
- 	* driver_broadcom: fixed couple of memory leaks in scan result
- 	  processing
- 	* EAP-PAX is now registered as EAP type 46
- 	* fixed EAP-PAX MAC calculation
- 	* fixed EAP-PAX CK and ICK key derivation
- 	* added support for using password with EAP-PAX (as an alternative to
- 	  entering key with eappsk); SHA-1 hash of the password will be used as
- 	  the key in this case
- 	* added support for arbitrary driver interface parameters through the
- 	  configuration file with a new driver_param field; this adds a new
- 	  driver_ops function set_param()
- 	* added possibility to override l2_packet module with driver interface
- 	  API (new send_eapol handler); this can be used to implement driver
- 	  specific TX/RX functions for EAPOL frames
- 	* fixed ctrl_interface_group processing for the case where gid is
- 	  entered as a number, not group name
- 	* driver_test: added support for testing hostapd with wpa_supplicant
- 	  by using test driver interface without any kernel drivers or network
- 	  cards
- 
- 2005-05-22 - v0.4.1
- 	* driver_madwifi: fixed WPA/WPA2 mode configuration to allow EAPOL
- 	  packets to be encrypted; this was apparently broken by the changed
- 	  ioctl order in v0.4.0
- 	* driver_madwifi: added preliminary support for compiling against 'BSD'
- 	  branch of madwifi CVS tree
- 	* added support for EAP-MSCHAPv2 password retries within the same EAP
- 	  authentication session
- 	* added support for password changes with EAP-MSCHAPv2 (used when the
- 	  password has expired)
- 	* added support for reading additional certificates from PKCS#12 files
- 	  and adding them to the certificate chain
- 	* fixed association with IEEE 802.1X (no WPA) when dynamic WEP keys
- 	  were used
- 	* fixed a possible double free in EAP-TTLS fast-reauthentication when
- 	  identity or password is entered through control interface
- 	* display EAP Notification messages to user through control interface
- 	  with "CTRL-EVENT-EAP-NOTIFICATION" prefix
- 	* added GUI version of wpa_cli, wpa_gui; this is not build
- 	  automatically with 'make'; use 'make wpa_gui' to build (this requires
- 	  Qt development tools)
- 	* added 'disconnect' command to control interface for setting
- 	  wpa_supplicant in state where it will not associate before
- 	  'reassociate' command has been used
- 	* added support for selecting a network from the list of all configured
- 	  networks ('wpa_cli select_network <network id>'; this disabled all
- 	  other networks; to re-enable, 'wpa_cli select_network any')
- 	* added support for getting scan results through control interface
- 	* added EAP workaround for PEAPv1 session resumption: allow outer,
- 	  i.e., not tunneled, EAP-Success to terminate session since; this can
- 	  be disabled with eap_workaround=0
- 
- 2005-04-25 - v0.4.0 (beginning of 0.4.x development releases)
- 	* added a new build time option, CONFIG_NO_STDOUT_DEBUG, that can be
- 	  used to reduce the size of the wpa_supplicant considerably if
- 	  debugging code is not needed
- 	* fixed EAPOL-Key validation to drop packets with invalid Key Data
- 	  Length; such frames could have crashed wpa_supplicant due to buffer
- 	  overflow
- 	* added support for wired authentication (IEEE 802.1X on wired
- 	  Ethernet); driver interface 'wired'
- 	* obsoleted set_wpa() handler in the driver interface API (it can be
- 	  replaced by moving enable/disable functionality into init()/deinit())
- 	  (calls to set_wpa() are still present for backwards compatibility,
- 	  but they may be removed in the future)
- 	* driver_madwifi: fixed association in plaintext mode
- 	* modified the EAP workaround that accepts EAP-Success with incorrect
- 	  Identifier to be even less strict about verification in order to
- 	  interoperate with some authentication servers
- 	* added support for sending TLS alerts
- 	* added support for 'any' SSID wildcard; if ssid is not configured or
- 	  is set to an empty string, any SSID will be accepted for non-WPA AP
- 	* added support for asking PIN (for SIM) from frontends (e.g.,
- 	  wpa_cli); if a PIN is needed, but not included in the configuration
- 	  file, a control interface request is sent and EAP processing is
- 	  delayed until the PIN is available
- 	* added support for using external devices (e.g., a smartcard) for
- 	  private key operations in EAP-TLS (CONFIG_SMARTCARD=y in .config);
- 	  new wpa_supplicant.conf variables:
- 	  - global: opensc_engine_path, pkcs11_engine_path, pkcs11_module_path
- 	  - network: engine, engine_id, key_id
- 	* added experimental support for EAP-PAX
- 	* added monitor mode for wpa_cli (-a<path to a program to run>) that
- 	  allows external commands (e.g., shell scripts) to be run based on
- 	  wpa_supplicant events, e.g., when authentication has been completed
- 	  and data connection is ready; other related wpa_cli arguments:
- 	  -B (run in background), -P (write PID file); wpa_supplicant has a new
- 	  command line argument (-W) that can be used to make it wait until a
- 	  control interface command is received in order to avoid missing
- 	  events
- 	* added support for opportunistic WPA2 PMKSA key caching (disabled by
- 	  default, can be enabled with proactive_key_caching=1)
- 	* fixed RSN IE in 4-Way Handshake message 2/4 for the case where
- 	  Authenticator rejects PMKSA caching attempt and the driver is not
- 	  using assoc_info events
- 	* added -P<pid file> argument for wpa_supplicant to write the current
- 	  process id into a file
- 
- 2005-02-12 - v0.3.7 (beginning of 0.3.x stable releases)
- 	* added new phase1 option parameter, include_tls_length=1, to force
- 	  wpa_supplicant to add TLS Message Length field to all TLS messages
- 	  even if the packet is not fragmented; this may be needed with some
- 	  authentication servers
- 	* fixed WPA/RSN IE verification in message 3 of 4-Way Handshake when
- 	  using drivers that take care of AP selection (e.g., when using
- 	  ap_scan=2)
- 	* fixed reprocessing of pending request after ctrl_iface requests for
- 	  identity/password/otp
- 	* fixed ctrl_iface requests for identity/password/otp in Phase 2 of
- 	  EAP-PEAP and EAP-TTLS
- 	* all drivers using driver_wext: set interface up and select Managed
- 	  mode when starting wpa_supplicant; set interface down when exiting
- 	* renamed driver_ipw2100.c to driver_ipw.c since it now supports both
- 	  ipw2100 and ipw2200; please note that this also changed the
- 	  configuration variable in .config to CONFIG_DRIVER_IPW
- 
- 2005-01-24 - v0.3.6
- 	* fixed a busy loop introduced in v0.3.5 for scan result processing
- 	  when no matching AP is found
- 
- 2005-01-23 - v0.3.5
- 	* added a workaround for an interoperability issue with a Cisco AP
- 	  when using WPA2-PSK
- 	* fixed non-WPA IEEE 802.1X to use the same authentication timeout as
- 	  WPA with IEEE 802.1X (i.e., timeout 10 -> 70 sec to allow
- 	  retransmission of dropped frames)
- 	* fixed issues with 64-bit CPUs and SHA1 cleanup in previous version
- 	  (e.g., segfault when processing EAPOL-Key frames)
- 	* fixed EAP workaround and fast reauthentication configuration for
- 	  RSN pre-authentication; previously these were disabled and
- 	  pre-authentication would fail if the used authentication server
- 	  requires EAP workarounds
- 	* added support for blacklisting APs that fail or timeout
- 	  authentication in ap_scan=1 mode so that all APs are tried in cases
- 	  where the ones with strongest signal level are failing authentication
- 	* fixed CA certificate loading after a failed EAP-TLS/PEAP/TTLS
- 	  authentication attempt
- 	* allow EAP-PEAP/TTLS fast reauthentication only if Phase 2 succeeded
- 	  in the previous authentication (previously, only Phase 1 success was
- 	  verified)
- 
- 2005-01-09 - v0.3.4
- 	* added preliminary support for IBSS (ad-hoc) mode configuration
- 	  (mode=1 in network block); this included a new key_mgmt mode
- 	  WPA-NONE, i.e., TKIP or CCMP with a fixed key (based on psk) and no
- 	  key management; see wpa_supplicant.conf for more details and an
- 	  example on how to configure this (note: this is currently implemented
- 	  only for driver_hostapd.c, but the changes should be trivial to add
- 	  in associate() handler for other drivers, too (assuming the driver
- 	  supports WPA-None)
- 	* added preliminary port for native Windows (i.e., no cygwin) using
- 	  mingw
- 
- 2005-01-02 - v0.3.3
- 	* added optional support for GNU Readline and History Libraries for
- 	  wpa_cli (CONFIG_READLINE)
- 	* cleaned up EAP state machine <-> method interface and number of
- 	  small problems with error case processing not terminating on
- 	  EAP-Failure but waiting for timeout
- 	* added couple of workarounds for interoperability issues with a
- 	  Cisco AP when using WPA2
- 	* added support for EAP-FAST (draft-cam-winget-eap-fast-00.txt);
- 	  Note: This requires a patch for openssl to add support for TLS
- 	  extensions and number of workarounds for operations without
- 	  certificates. Proof of concept type of experimental patch is
- 	  included in openssl-tls-extensions.patch.
- 
- 2004-12-19 - v0.3.2
- 	* fixed private key loading for cases where passphrase is not set
- 	* fixed Windows/cygwin L2 packet handler freeing; previous version
- 	  could cause a segfault when RSN pre-authentication was completed
- 	* added support for PMKSA caching with drivers that generate RSN IEs
- 	  (e.g., NDIS); currently, this is only implemented in driver_ndis.c,
- 	  but similar code can be easily added to driver_ndiswrapper.c once
- 	  ndiswrapper gets full support for RSN PMKSA caching
- 	* improved recovery from PMKID mismatches by requesting full EAP
- 	  authentication in case of failed PMKSA caching attempt
- 	* driver_ndis: added support for NDIS NdisMIncidateStatus() events
- 	  (this requires that ndis_events is ran while wpa_supplicant is
- 	  running)
- 	* driver_ndis: use ADD_WEP/REMOVE_WEP when configuring WEP keys
- 	* added support for driver interfaces to replace the interface name
- 	  based on driver/OS specific mapping, e.g., in case of driver_ndis,
- 	  this allows the beginning of the adapter description to be used as
- 	  the interface name
- 	* added support for CR+LF (Windows-style) line ends in configuration
- 	  file
- 	* driver_ndis: enable radio before starting scanning, disable radio
- 	  when exiting
- 	* modified association event handler to set portEnabled = FALSE before
- 	  clearing port Valid in order to reset EAP state machine and avoid
- 	  problems with new authentication getting ignored because of state
- 	  machines ending up in AUTHENTICATED/SUCCESS state based on old
- 	  information
- 	* added support for driver events to add PMKID candidates in order to
- 	  allow drivers to give priority to most likely roaming candidates
- 	* driver_hostap: moved PrivacyInvoked configuration to associate()
- 	  function so that this will not be set for plaintext connections
- 	* added KEY_MGMT_802_1X_NO_WPA as a new key_mgmt type so that driver
- 	  interface can distinguish plaintext and IEEE 802.1X (no WPA)
- 	  authentication
- 	* fixed static WEP key configuration to use broadcast/default type for
- 	  all keys (previously, the default TX key was configured as pairwise/
- 	  unicast key)
- 	* driver_ndis: added legacy WPA capability detection for non-WPA2
- 	  drivers
- 	* added support for setting static WEP keys for IEEE 802.1X without
- 	  dynamic WEP keying (eapol_flags=0)
- 
- 2004-12-12 - v0.3.1
- 	* added support for reading PKCS#12 (PFX) files (as a replacement for
- 	  PEM/DER) to get certificate and private key (CONFIG_PKCS12)
- 	* fixed compilation with CONFIG_PCSC=y
- 	* added new ap_scan mode, ap_scan=2, for drivers that take care of
- 	  association, but need to be configured with security policy and SSID,
- 	  e.g., ndiswrapper and NDIS driver; this mode should allow such
- 	  drivers to work with hidden SSIDs and optimized roaming; when
- 	  ap_scan=2 is used, only the first network block in the configuration
- 	  file is used and this configuration should have explicit security
- 	  policy (i.e., only one option in the lists) for key_mgmt, pairwise,
- 	  group, proto variables
- 	* added experimental port of wpa_supplicant for Windows
- 	  - driver_ndis.c driver interface (NDIS OIDs)
- 	  - currently, this requires cygwin and WinPcap
- 	  - small utility, win_if_list, can be used to get interface name
- 	* control interface can now be removed at build time; add
- 	  CONFIG_CTRL_IFACE=y to .config to maintain old functionality
- 	* optional Xsupplicant interface can now be removed at build time;
- 	  (CONFIG_XSUPPLICANT_IFACE=y in .config to bring it back)
- 	* added auth_alg to driver interface associate() parameters to make it
- 	  easier for drivers to configure authentication algorithm as part of
- 	  the association
- 
- 2004-12-05 - v0.3.0 (beginning of 0.3.x development releases)
- 	* driver_broadcom: added new driver interface for Broadcom wl.o driver
- 	  (a generic driver for Broadcom IEEE 802.11a/g cards)
- 	* wpa_cli: fixed parsing of -p <path> command line argument
- 	* PEAPv1: fixed tunneled EAP-Success reply handling to reply with TLS
- 	  ACK, not tunneled EAP-Success (of which only the first byte was
- 	  actually send due to a bug in previous code); this seems to
- 	  interoperate with most RADIUS servers that implements PEAPv1
- 	* PEAPv1: added support for terminating PEAP authentication on tunneled
- 	  EAP-Success message; this can be configured by adding
- 	  peap_outer_success=0 on phase1 parameters in wpa_supplicant.conf
- 	  (some RADIUS servers require this whereas others require a tunneled
- 	  reply
- 	* PEAPv1: changed phase1 option peaplabel to use default to 0, i.e., to
- 	  the old label for key derivation; previously, the default was 1,
- 	  but it looks like most existing PEAPv1 implementations use the old
- 	  label which is thus more suitable default option
- 	* added support for EAP-PSK (draft-bersani-eap-psk-03.txt)
- 	* fixed parsing of wep_tx_keyidx
- 	* added support for configuring list of allowed Phase 2 EAP types
- 	  (for both EAP-PEAP and EAP-TTLS) instead of only one type
- 	* added support for configuring IEEE 802.11 authentication algorithm
- 	  (auth_alg; mainly for using Shared Key authentication with static
- 	  WEP keys)
- 	* added support for EAP-AKA (with UMTS SIM)
- 	* fixed couple of errors in PCSC handling that could have caused
- 	  random-looking errors for EAP-SIM
- 	* added support for EAP-SIM pseudonyms and fast re-authentication
- 	* added support for EAP-TLS/PEAP/TTLS fast re-authentication (TLS
- 	  session resumption)
- 	* added support for EAP-SIM with two challanges
- 	  (phase1="sim_min_num_chal=3" can be used to require three challenges)
- 	* added support for configuring DH/DSA parameters for an ephemeral DH
- 	  key exchange (EAP-TLS/PEAP/TTLS) using new configuration parameters
- 	  dh_file and dh_file2 (phase 2); this adds support for using DSA keys
- 	  and optional DH key exchange to achieve forward secracy with RSA keys
- 	* added support for matching subject of the authentication server
- 	  certificate with a substring when using EAP-TLS/PEAP/TTLS; new
- 	  configuration variables subject_match and subject_match2
- 	* changed SSID configuration in driver_wext.c (used by many driver
- 	  interfaces) to use ssid_len+1 as the length for SSID since some Linux
- 	  drivers expect this
- 	* fixed couple of unaligned reads in scan result parsing to fix WPA
- 	  connection on some platforms (e.g., ARM)
- 	* added driver interface for Intel ipw2100 driver
- 	* added support for LEAP with WPA
- 	* added support for larger scan results report (old limit was 4 kB of
- 	  data, i.e., about 35 or so APs) when using Linux wireless extensions
- 	  v17 or newer
- 	* fixed a bug in PMKSA cache processing: skip sending of EAPOL-Start
- 	  only if there is a PMKSA cache entry for the current AP
- 	* fixed error handling for case where reading of scan results fails:
- 	  must schedule a new scan or wpa_supplicant will remain waiting
- 	  forever
- 	* changed debug output to remove shared password/key material by
- 	  default; all key information can be included with -K command line
- 	  argument to match the previous behavior
- 	* added support for timestamping debug log messages (disabled by
- 	  default, can be enabled with -t command line argument)
- 	* set pairwise/group cipher suite for non-WPA IEEE 802.1X to WEP-104
- 	  if keys are not configured to be used; this fixes IEEE 802.1X mode
- 	  with drivers that use this information to configure whether Privacy
- 	  bit can be in Beacon frames (e.g., ndiswrapper)
- 	* avoid clearing driver keys if no keys have been configured since last
- 	  key clear request; this seems to improve reliability of group key
- 	  handshake for ndiswrapper & NDIS driver which seems to be suffering
- 	  of some kind of timing issue when the keys are cleared again after
- 	  association
- 	* changed driver interface API:
- 	  - WPA_SUPPLICANT_DRIVER_VERSION define can be used to determine which
- 	    version is being used (now, this is set to 2; previously, it was
- 	    not defined)
- 	  - pass pointer to private data structure to all calls
- 	  - the new API is not backwards compatible; all in-tree driver
- 	    interfaces has been converted to the new API
- 	* added support for controlling multiple interfaces (radios) per
- 	  wpa_supplicant process; each interface needs to be listed on the
- 	  command line (-c, -i, -D arguments) with -N as a separator
- 	  (-cwpa1.conf -iwlan0 -Dhostap -N -cwpa2.conf -iath0 -Dmadwifi)
- 	* added a workaround for EAP servers that incorrectly use same Id for
- 	  sequential EAP packets
- 	* changed libpcap/libdnet configuration to use .config variable,
- 	  CONFIG_DNET_PCAP, instead of requiring Makefile modification
- 	* improved downgrade attack detection in IE verification of msg 3/4:
- 	  verify both WPA and RSN IEs, if present, not only the selected one;
- 	  reject the AP if an RSN IE is found in msg 3/4, but not in Beacon or
- 	  Probe Response frame, and RSN is enabled in wpa_supplicant
- 	  configuration
- 	* fixed WPA msg 3/4 processing to allow Key Data field contain other
- 	  IEs than just one WPA IE
- 	* added support for FreeBSD and driver interface for the BSD net80211
- 	  layer (CONFIG_DRIVER_BSD=y in .config); please note that some of the
- 	  required kernel mods have not yet been committed
- 	* made EAP workarounds configurable; enabled by default, can be
- 	  disabled with network block option eap_workaround=0
- 
- 2004-07-17 - v0.2.4 (beginning of 0.2.x stable releases)
- 	* resolved couple of interoperability issues with EAP-PEAPv1 and
- 	  Phase 2 (inner EAP) fragment reassembly
- 	* driver_madwifi: fixed WEP key configuration for IEEE 802.1X when the
- 	  AP is using non-zero key index for the unicast key and key index zero
- 	  for the broadcast key
- 	* driver_hostap: fixed IEEE 802.1X WEP key updates and
- 	  re-authentication by allowing unencrypted EAPOL frames when not using
- 	  WPA
- 	* added a new driver interface, 'wext', which uses only standard,
- 	  driver independent functionality in Linux wireless extensions;
- 	  currently, this can be used only for non-WPA IEEE 802.1X mode, but
- 	  eventually, this is to be extended to support full WPA/WPA2 once
- 	  Linux wireless extensions get support for this
- 	* added support for mode in which the driver is responsible for AP
- 	  scanning and selection; this is disabled by default and can be
- 	  enabled with global ap_scan=0 variable in wpa_supplicant.conf;
- 	  this mode can be used, e.g., with generic 'wext' driver interface to
- 	  use wpa_supplicant as IEEE 802.1X Supplicant with any Linux driver
- 	  supporting wireless extensions.
- 	* driver_madwifi: fixed WPA2 configuration and scan_ssid=1 (e.g.,
- 	  operation with an AP that does not include SSID in the Beacon frames)
- 	* added support for new EAP authentication methods:
- 	  EAP-TTLS/EAP-OTP, EAP-PEAPv0/OTP, EAP-PEAPv1/OTP, EAP-OTP
- 	* added support for asking one-time-passwords from frontends (e.g.,
- 	  wpa_cli); this 'otp' command works otherwise like 'password' command,
- 	  but the password is used only once and the frontend will be asked for
- 	  a new password whenever a request from authenticator requires a
- 	  password; this can be used with both EAP-OTP and EAP-GTC
- 	* changed wpa_cli to automatically re-establish connection so that it
- 	  does not need to be re-started when wpa_supplicant is terminated and
- 	  started again
- 	* improved user data (identity/password/otp) requests through
- 	  frontends: process pending EAPOL packets after getting new
- 	  information so that full authentication does not need to be
- 	  restarted; in addition, send pending requests again whenever a new
- 	  frontend is attached
- 	* changed control frontends to use a new directory for socket files to
- 	  make it easier for wpa_cli to automatically select between interfaces
- 	  and to provide access control for the control interface;
- 	  wpa_supplicant.conf: ctrl_interface is now a path
- 	  (/var/run/wpa_supplicant is the recommended path) and
- 	  ctrl_interface_group can be used to select which group gets access to
- 	  the control interface;
- 	  wpa_cli: by default, try to connect to the first interface available
- 	  in /var/run/wpa_supplicant; this path can be overriden with -p option
- 	  and an interface can be selected with -i option (i.e., in most common
- 	  cases, wpa_cli does not need to get any arguments)
- 	* added support for LEAP
- 	* added driver interface for Linux ndiswrapper
- 	* added priority option for network blocks in the configuration file;
- 	  this allows networks to be grouped based on priority (the scan
- 	  results are searched for matches with network blocks in this order)
- 
- 2004-06-20 - v0.2.3
- 	* sort scan results to improve AP selection
- 	* fixed control interface socket removal for some error cases
- 	* improved scan requesting and authentication timeout
- 	* small improvements/bug fixes for EAP-MSCHAPv2, EAP-PEAP, and
- 	  TLS processing
- 	* PEAP version can now be forced with phase1="peapver=<ver>"
- 	  (mostly for testing; by default, the highest version supported by
- 	  both the Supplicant and Authentication Server is selected
- 	  automatically)
- 	* added support for madwifi driver (Atheros ar521x)
- 	* added a workaround for cases where AP sets Install Tx/Rx bit for
- 	  WPA Group Key messages when pairwise keys are used (without this,
- 	  the Group Key would be used for Tx and the AP would drop frames
- 	  from the station)
- 	* added GSM SIM/USIM interface for GSM authentication algorithm for
- 	  EAP-SIM; this requires pcsc-lite
- 	* added support for ATMEL AT76C5XXx driver
- 	* fixed IEEE 802.1X WEP key derivation in the case where Authenticator
- 	  does not include key data in the EAPOL-Key frame (i.e., part of
- 	  EAP keying material is used as data encryption key)
- 	* added support for using plaintext and static WEP networks
- 	  (key_mgmt=NONE)
- 
- 2004-05-31 - v0.2.2
- 	* added support for new EAP authentication methods:
- 	  EAP-TTLS/EAP-MD5-Challenge
- 	  EAP-TTLS/EAP-GTC
- 	  EAP-TTLS/EAP-MSCHAPv2
- 	  EAP-TTLS/EAP-TLS
- 	  EAP-TTLS/MSCHAPv2
- 	  EAP-TTLS/MSCHAP
- 	  EAP-TTLS/PAP
- 	  EAP-TTLS/CHAP
- 	  EAP-PEAP/TLS
- 	  EAP-PEAP/GTC
- 	  EAP-PEAP/MD5-Challenge
- 	  EAP-GTC
- 	  EAP-SIM (not yet complete; needs GSM/SIM authentication interface)
- 	* added support for anonymous identity (to be used when identity is
- 	  sent in plaintext; real identity will be used within TLS protected
- 	  tunnel (e.g., with EAP-TTLS)
- 	* added event messages from wpa_supplicant to frontends, e.g., wpa_cli
- 	* added support for requesting identity and password information using
- 	  control interface; in other words, the password for EAP-PEAP or
- 	  EAP-TTLS does not need to be included in the configuration file since
- 	  a frontand (e.g., wpa_cli) can ask it from the user
- 	* improved RSN pre-authentication to use a candidate list and process
- 	  all candidates from each scan; not only one per scan
- 	* fixed RSN IE and WPA IE capabilities field parsing
- 	* ignore Tx bit in GTK IE when Pairwise keys are used
- 	* avoid making new scan requests during IEEE 802.1X negotiation
- 	* use openssl/libcrypto for MD5 and SHA-1 when compiling wpa_supplicant
- 	  with TLS support (this replaces the included implementation with
- 	  library code to save about 8 kB since the library code is needed
- 	  anyway for TLS)
- 	* fixed WPA-PSK only mode when compiled without IEEE 802.1X support
- 	  (i.e., without CONFIG_IEEE8021X_EAPOL=y in .config)
- 
- 2004-05-06 - v0.2.1
- 	* added support for internal IEEE 802.1X (actually, IEEE 802.1aa/D6.1)
- 	  Supplicant
- 	  - EAPOL state machines for Supplicant [IEEE 802.1aa/D6.1]
- 	  - EAP peer state machine [draft-ietf-eap-statemachine-02.pdf]
- 	  - EAP-MD5 (cannot be used with WPA-RADIUS)
- 	    [draft-ietf-eap-rfc2284bis-09.txt]
- 	  - EAP-TLS [RFC 2716]
- 	  - EAP-MSCHAPv2 (currently used only with EAP-PEAP)
- 	  - EAP-PEAP/MSCHAPv2 [draft-josefsson-pppext-eap-tls-eap-07.txt]
- 	    [draft-kamath-pppext-eap-mschapv2-00.txt]
- 	    (PEAP version 0, 1, and parts of 2; only 0 and 1 are enabled by
- 	    default; tested with FreeRADIUS, Microsoft IAS, and Funk Odyssey)
- 	  - new configuration file options: eap, identity, password, ca_cert,
- 	    client_cert, privatekey, private_key_passwd
- 	  - Xsupplicant is not required anymore, but it can be used by
- 	    disabling the internal IEEE 802.1X Supplicant with -e command line
- 	    option
- 	  - this code is not included in the default build; Makefile need to
- 	    be edited for this (uncomment lines for selected functionality)
- 	  - EAP-TLS and EAP-PEAP require openssl libraries
- 	* use module prefix in debug messages (WPA, EAP, EAP-TLS, ..)
- 	* added support for non-WPA IEEE 802.1X mode with dynamic WEP keys
- 	  (i.e., complete IEEE 802.1X/EAP authentication and use IEEE 802.1X
- 	   EAPOL-Key frames instead of WPA key handshakes)
- 	* added support for IEEE 802.11i/RSN (WPA2)
- 	  - improved PTK Key Handshake
- 	  - PMKSA caching, pre-authentication
- 	* fixed wpa_supplicant to ignore possible extra data after WPA
- 	  EAPOL-Key packets (this fixes 'Invalid EAPOL-Key MIC when using
- 	  TPTK' error from message 3 of 4-Way Handshake in case the AP
- 	  includes extra data after the EAPOL-Key)
- 	* added interface for external programs (frontends) to control
- 	  wpa_supplicant
- 	  - CLI example (wpa_cli) with interactive mode and command line
- 	    mode
- 	  - replaced SIGUSR1 status/statistics with the new control interface
- 	* made some feature compile time configurable
- 	  - .config file for make
- 	  - driver interfaces (hostap, hermes, ..)
- 	  - EAPOL/EAP functions
- 
- 2004-02-15 - v0.2.0
- 	* Initial version of wpa_supplicant
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/CipherWrapper.c wpa_view/wpa_suppl/CipherWrapper.c
*** wpa_supplicant-0.5.7/CipherWrapper.c	Thu Jan  1 02:00:00 1970
--- wpa_view/wpa_suppl/CipherWrapper.c	Wed Jun  9 13:29:36 2010
***************
*** 0 ****
--- 1,507 ----
+ /*
+  * CipherWrapper.c
+  *
+  * Copyright 2001-2009 Texas Instruments, Inc. - http://www.ti.com/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  * Alternatively, this software may be distributed under the terms of BSD
+  * license.
+  *
+  * See README and COPYING for more details.
+  */
+ 
+ #include "includes.h"
+ #include "common.h"
+ 
+ /* OpenSSL includes */
+ #include "ossl_typ.h"
+ #include "rand.h"
+ #include "bn.h"
+ #include "dh.h"
+ #include "err.h"
+ #include "sha.h"
+ #include "openssl-0.9.8e/include/openssl/evp.h"
+ #include "hmac.h"
+ 
+ 
+ 
+ #include "bufferObj.h"
+ #include "CipherWrapper.h"
+ #include "WscTypes.h"
+ #include <string.h>
+ 
+ 
+ 
+ 
+ 
+ static u8 DH_P_VALUE[BUF_SIZE_1536_BITS] = 
+ {
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+     0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
+     0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,
+     0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
+     0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,
+     0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
+     0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,
+     0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
+     0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,
+     0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
+     0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,
+     0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
+     0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,
+     0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
+     0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,
+     0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,
+     0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,
+     0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
+     0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,
+     0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,
+     0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,
+     0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,
+     0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x23, 0x73, 0x27,
+     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
+ };
+ 
+ static u32 DH_G_VALUE = 2;
+ 
+ 
+ 
+ /***************************************************************************/
+  
+ u32 cipherGenerateDHKeyPair(DH **DHKeyPair)
+ {
+     /* u8 temp[SIZE_PUB_KEY] = {0}; */
+ 	//int len = 0;
+ 	u32 g = 0;
+ 	//u8 * buffLoc = NULL;
+     
+ 	/* 1. Initialize the DH structure */
+ 	*DHKeyPair = DH_new();
+ 	if(*DHKeyPair == NULL)
+ 	{
+ 		wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: DH_new failed\n");
+ 		return NOK;
+ 	}
+ 	
+ 	(*DHKeyPair)->p = BN_new();
+ 	if((*DHKeyPair)->p == NULL)
+ 	{
+ 		wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: BN_new failed\n");
+ 		DH_free(*DHKeyPair);
+ 		return NOK;
+ 	}
+ 
+ 	(*DHKeyPair)->g = BN_new();
+ 	if((*DHKeyPair)->g == NULL)
+ 	{
+ 		wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: BN_new failed\n");
+ 		BN_free((*DHKeyPair)->p);
+ 		DH_free(*DHKeyPair);
+ 		return NOK;
+ 	}
+ 	
+ 	/* 2. load the value of P */
+ 	if(BN_bin2bn(DH_P_VALUE, 
+ 		BUF_SIZE_1536_BITS, 
+ 		(*DHKeyPair)->p)==NULL)
+ 	{
+ 		wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: BN_bin2bn P: %s", 
+ 			ERR_error_string(ERR_get_error(), NULL));
+ 		BN_free((*DHKeyPair)->p);
+ 		BN_free((*DHKeyPair)->g);
+ 		DH_free(*DHKeyPair);
+ 		return NOK;
+ 	}
+ 	
+ 	/* 3. load the value of G */
+ 	g = htonl(DH_G_VALUE);   
+ 	if(BN_bin2bn((u8 *)&g, 
+ 		4, 
+ 		(*DHKeyPair)->g)==NULL)
+ 	{
+ 		wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: BN_bin2bn G: %s", 
+ 			ERR_error_string(ERR_get_error(), NULL));
+ 		BN_free((*DHKeyPair)->p);
+ 		BN_free((*DHKeyPair)->g);
+ 		DH_free(*DHKeyPair);
+ 		return NOK;
+ 	}
+ 	
+ 	/* 4. generate the DH key */
+ 	if(DH_generate_key(*DHKeyPair) == 0)
+ 	{
+ 		wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: DH_generate_key: %s", 
+ 			ERR_error_string(ERR_get_error(), NULL));
+ 		BN_free((*DHKeyPair)->p);
+ 		BN_free((*DHKeyPair)->g);
+ 		DH_free(*DHKeyPair);
+ 		return NOK;
+ 	}
+ 	/*
+ 	5. extract the DH public key .
+ 	len = BN_bn2bin((*DHKeyPair)->pub_key, temp);
+ 	if(0 == len)
+ 	{
+ 		printf("%s: BN_bn2bin failed\n",__FUNCTION__);
+ 		return NOK;
+ 	}
+ 
+ 	buffLoc = bufferAppend(pubKey,SIZE_PUB_KEY,temp);
+ 	if (!buffLoc)
+ 	{
+ 		return NOK;
+ 	}*/
+ 	return OK;
+ }
+ 
+ 
+ u32 cipherGenerateSHA256Hash(bufferObj* inBuf, bufferObj* outBuf)
+ {
+ 	u8  * buffLoc = 0;
+ 	u8 Hash[SIZE_256_BITS] = {0};
+ 	if(SHA256(bufferGetBuf(inBuf), bufferLength(inBuf), Hash) == NULL)
+     {
+         wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: SHA256 calculation failed");
+         return NOK;
+     }
+ 	
+ 	buffLoc = bufferAppend(outBuf,SIZE_256_BITS,Hash);
+ 	if (!buffLoc)
+ 	{
+ 		return NOK;
+ 	}
+ 	return OK;
+ }
+ 
+ u32 cipherDeriveKey(bufferObj* KDK, bufferObj* prsnlString, u32 keyBits, bufferObj* key)
+ {
+ 	int i=0, iterations = 0, temp;
+     bufferObj input, output;    
+     u8 hmac[SIZE_256_BITS];
+     u32 hmacLen = 0;
+     u8 *inPtr = 0;
+ 	u8 * buffLoc = 0;
+ 
+ 	bufferCreateEmpty(&input, SIZE_256_BITS);
+ 	bufferCreateEmpty(&output, SIZE_256_BITS);
+ 
+     iterations = ((keyBits/8) + PRF_DIGEST_SIZE - 1)/PRF_DIGEST_SIZE;
+ 	temp = htonl(i);
+ 	
+ 	buffLoc = bufferAppend(&input,sizeof(i),(u8 *)&temp);
+ 	if (!buffLoc)
+ 	{
+ 		bufferFree(&input);
+ 		bufferFree(&output);
+ 		return NOK;
+ 	}	
+ 	buffLoc = bufferAppend(&input,bufferLength(prsnlString),bufferGetBuf(prsnlString));
+ 	if (!buffLoc)
+ 	{
+ 		bufferFree(&input);
+ 		bufferFree(&output);
+ 		return NOK;
+ 	}
+ 
+ 	temp = htonl(keyBits);
+ 	buffLoc = bufferAppend(&input,sizeof(keyBits),(u8 *)&temp);
+ 	if (!buffLoc)
+ 	{
+ 		bufferFree(&input);
+ 		bufferFree(&output);
+ 		return NOK;
+ 	}
+ 
+ 	inPtr = bufferGetBuf(&input);
+ 
+     for(i = 0; i < iterations; i++)
+     {
+         /* Set the current value of i at the start of the input buffer */
+         *(int *)inPtr = htonl(i+1);
+         if(HMAC(EVP_sha256(), bufferGetBuf(KDK), SIZE_256_BITS, bufferGetBuf(&input), 
+                 bufferLength(&input), hmac, &hmacLen) == NULL)
+         {
+ 			wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: cipherDeriveKey: HMAC failed");
+ 			bufferFree(&input);
+ 			bufferFree(&output);
+             return NOK;
+         }
+         
+ 		buffLoc = bufferAppend(&output,hmacLen,hmac);
+ 		if (!buffLoc)
+ 		{
+ 			bufferFree(&input);
+ 			bufferFree(&output);
+ 			return NOK;
+ 		}
+     }
+ 
+     /* Sanity check */
+     if(keyBits/8 > bufferLength(&output))
+     {
+ 		wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: cipherDeriveKey: Key derivation generated less bits than asked");
+ 		bufferFree(&input);
+ 		bufferFree(&output);
+ 		return NOK;
+     }
+ 
+     /* We now have at least the number of key bits requested. */
+     /* Return only the number of bits asked for. Discard the excess. */
+ 	buffLoc = bufferAppend(key,keyBits/8,bufferGetBuf(&output));
+ 	if (!buffLoc)
+ 	{
+ 		bufferFree(&input);
+ 		bufferFree(&output);
+ 		return NOK;
+ 	}
+ 	bufferFree(&input);
+ 	bufferFree(&output);
+ 	return OK;
+ }
+ 
+ 
+ u32 cipherEncrypt(	bufferObj* plainText, 
+ 						bufferObj* encrKey, 
+ 						bufferObj* authKey, 
+ 						bufferObj* cipherText, 
+ 						bufferObj* iv)
+ {
+ 	u8* buffLoc = 0;
+ 	bufferObj buf;
+     u8 ivBuf[SIZE_128_BITS];
+     EVP_CIPHER_CTX ctx;
+ 	int bufLen = 0;
+     u8 outBuf[1024];
+     int outLen, currentLength;
+ 	int blockSize; 
+     int length;
+ 	u8* bufPtr = NULL;
+ 
+     if(0 == bufferLength(plainText))
+ 	{
+         return NOK;
+ 	}
+ 
+     /* Generate a random iv */
+     RAND_bytes(ivBuf, SIZE_128_BITS);
+ 	bufferReset(iv);
+ 		
+    	buffLoc = bufferAppend(iv,SIZE_128_BITS,(u8 *)ivBuf);
+ 	
+ 	if (!buffLoc)
+ 	{
+ 		return NOK;
+ 	}
+ 
+ 	/* Now encrypt the plaintext and mac using the encryption key and IV. */
+ 
+ 	bufferCreateChunk(&buf);
+ 		
+ 	bufferReset(&buf);
+ 	buffLoc = bufferAppend(&buf,bufferLength(plainText),bufferGetBuf(plainText));
+ 		
+ 	if (!buffLoc)
+ 	{
+ 		bufferFree(&buf);
+ 		return NOK;
+ 	}
+ 	
+     if(0 == EVP_EncryptInit(&ctx, EVP_aes_128_cbc(), bufferGetBuf(encrKey), ivBuf))
+     {
+ 		wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: cipherEncrypt: EncryptInit failed");
+ 		bufferFree(&buf);
+         return NOK;
+     }
+ 	
+     bufLen = 1024;
+     /* block size = 1024 bytes - 128 bits, */
+     /* leave 128 bits at the end to accommodate any possible padding */
+     /* and avoid a buffer overflow */
+     blockSize = bufLen - SIZE_128_BITS;
+ 	
+     length = bufferLength(&buf);
+ 	
+     bufPtr = bufferGetBuf(&buf);
+ 	
+     while(length)
+     {
+ 		
+         if(length > blockSize)
+             currentLength = blockSize;
+         else
+ 			currentLength = length;
+ 		
+         if(0 == EVP_EncryptUpdate(&ctx, outBuf, &outLen, bufPtr, currentLength))
+         {
+ 			wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: cipherEncrypt: EncryptUpdate failed");
+ 			bufferFree(&buf);
+             return NOK;
+         }
+ 		
+ 		buffLoc = bufferAppend(cipherText,outLen,(u8 *)outBuf);
+ 		if (!buffLoc)
+ 		{
+ 			bufferFree(&buf);
+ 			return NOK;
+ 		}
+ 			
+ 		bufPtr = bufferAdvance(&buf,currentLength);
+ 		if (!bufPtr)
+ 		{
+ 			wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: cipherEncrypt: Internal Error: bufferAdvance failed");
+ 			bufferFree(&buf);
+ 			return NOK;
+ 		}
+         length -= currentLength;
+     }
+ 	
+     if(0 == EVP_EncryptFinal(&ctx, outBuf, &outLen))
+     {
+ 		wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: cipherEncrypt: EncryptFinal failed");
+ 		bufferFree(&buf);
+         return NOK;
+     }
+ 	
+     buffLoc = bufferAppend(cipherText,outLen,(u8 *)outBuf);
+ 	if (!buffLoc)
+ 	{
+ 		bufferFree(&buf);
+ 		return NOK;
+ 	}
+     bufferFree(&buf);
+ 	return OK;
+ }
+ 
+ u32 cipherDecrypt(	bufferObj* cipherText, 
+ 						bufferObj* iv,
+ 						bufferObj* encrKey, 
+ 						bufferObj* authKey, 
+ 						bufferObj* plainText)
+ {
+ 	EVP_CIPHER_CTX ctx;
+     bufferObj buf;
+ 	u8* buffLoc = 0;
+     int bufLen = 1024;
+     u8 outBuf[1024];
+     int outLen, currentLength;
+     /* block size = 1024 bytes - 128 bits, */
+     /* leave 128 bits at the end to accommodate any possible padding */
+     /* and avoid a buffer overflow */
+     int blockSize = bufLen - SIZE_128_BITS; 
+     int length = bufferLength(cipherText);
+ 
+     u8 *bufPtr = bufferGetBuf(cipherText);
+ 	bufferRewindStart(cipherText);
+ 	bufferRewindStart(iv);
+ 	bufferRewindStart(encrKey);
+ 	bufferRewindStart(authKey);
+ 	bufferRewindStart(plainText);
+ 	bufferCreateChunk(&buf);
+ 
+ 	if(0 == EVP_DecryptInit(&ctx, EVP_aes_128_cbc(), bufferGetBuf(encrKey), bufferGetBuf(iv)))
+     {
+ 		wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: cipherDecrypt: DecryptInit failed");
+ 		bufferFree(&buf);
+         return NOK;
+     }
+ 	
+     while(length)
+     {
+         if(length > blockSize)
+             currentLength = blockSize;
+         else
+             currentLength = length;
+ 
+ 		
+ 
+         if(0 == EVP_DecryptUpdate(&ctx, outBuf, &outLen, bufPtr, currentLength))
+         {
+ 			wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: cipherDecrypt: DecryptUpdate failed");
+ 			bufferFree(&buf);
+             return NOK;
+         }
+ 
+ 		if (outLen)
+ 		{
+         buffLoc = bufferAppend(&buf, outLen, (u8*)outBuf);
+ 
+ 		if (!buffLoc)
+ 		{
+ 			bufferFree(&buf);
+ 			return NOK;
+ 		}
+ 		}
+ 
+ 		bufPtr = bufferAdvance(cipherText, currentLength);
+ 
+ 		if (!bufPtr)
+ 		{
+ 			wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: cipherDecrypt: Internal Error: bufferAdvance failed");
+ 			bufferFree(&buf);
+ 			return NOK;
+ 		}
+ 
+         length -= currentLength;
+     }
+ 
+     if(0 == EVP_DecryptFinal(&ctx, outBuf, &outLen))
+     {
+ 		wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: cipherDecrypt: DecryptFinal failed");
+ 		bufferFree(&buf);
+         return NOK;
+     }
+ 
+ 	if (outLen)
+ 	{
+ 	buffLoc = bufferAppend(&buf, outLen, (u8*)outBuf);
+ 	if (!buffLoc)
+ 	{
+ 		bufferFree(&buf);
+ 		return NOK;
+ 	}
+ 	}
+    
+ 	if (bufferGetBuf(&buf) && bufferLength(&buf))
+ 	{
+ 	buffLoc = bufferAppend(plainText, bufferLength(&buf), bufferGetBuf(&buf));
+ 	if (!buffLoc)
+ 	{
+ 		bufferFree(&buf);
+ 		return NOK;
+ 	}
+ 	}
+ 
+ 	bufferFree(&buf);
+     return OK;
+ }
+ 
+ 
+ 
+ 
+ u8 cipherValidateMac(bufferObj *data, u8 *hmac, bufferObj *key)
+ {
+ 	
+ 	u8 dataMac[SIZE_256_BITS];
+ 
+ 	/* First calculate the hmac of the data */
+ 	if(HMAC(EVP_sha256(), bufferGetBuf(key), SIZE_256_BITS, bufferGetBuf(data), 
+ 	bufferLength(data), dataMac, NULL) == NULL)
+ 	{
+ 		wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: cipherValidateMac: HMAC failed");
+ 	return NOK;
+ 	}
+ 
+ 	/* next, compare it against the received hmac */
+ 	if(memcmp(dataMac, hmac, SIZE_256_BITS) != 0)
+ 	{
+ 		wpa_printf(MSG_ERROR, "CIPHER_WRAPPER: cipherValidateMac: HMAC results don't match");
+ 	return NOK;
+ 	}
+ 
+ 	return OK;
+ 	
+ }
+ 
diff -BNcr wpa_supplicant-0.5.7/CipherWrapper.h wpa_view/wpa_suppl/CipherWrapper.h
*** wpa_supplicant-0.5.7/CipherWrapper.h	Thu Jan  1 02:00:00 1970
--- wpa_view/wpa_suppl/CipherWrapper.h	Wed Jun  9 13:29:36 2010
***************
*** 0 ****
--- 1,39 ----
+ /*
+  * CipherWrapper.h
+  *
+  * Copyright 2001-2009 Texas Instruments, Inc. - http://www.ti.com/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  * Alternatively, this software may be distributed under the terms of BSD
+  * license.
+  *
+  * See README and COPYING for more details.
+  */
+ 
+ #ifndef _CIPHER_WRAPPER_
+ #define _CIPHER_WRAPPER_
+ 
+ u32 cipherGenerateDHKeyPair(DH **DHKeyPair);
+ 
+ u32 cipherGenerateSHA256Hash(bufferObj *inBuf, bufferObj *outBuf);
+ 
+ u32 cipherDeriveKey(bufferObj *KDK, bufferObj *prsnlString, u32 keyBits, bufferObj *key);
+ 
+ u32 cipherEncrypt(bufferObj *plainText, 
+ 				 bufferObj *encrKey, 
+ 				 bufferObj *authKey, 
+ 				 bufferObj *cipherText, 
+ 				 bufferObj *iv);
+ 
+ u32 cipherDecrypt(bufferObj *cipherText, 
+ 				 bufferObj *iv,
+ 				 bufferObj *encrKey, 
+ 				 bufferObj *authKey, 
+ 				 bufferObj *plainText);
+ u8 cipherValidateMac(bufferObj *data, u8 *hmac, bufferObj *key);
+ 
+ 
+ #endif /* _CIPHER_WRAPPER_ */
diff -BNcr wpa_supplicant-0.5.7/Makefile wpa_view/wpa_suppl/Makefile
*** wpa_supplicant-0.5.7/Makefile	Sun Dec 31 23:41:44 2006
--- wpa_view/wpa_suppl/Makefile	Wed Jun  9 13:31:27 2010
***************
*** 1,10 ****
- ifndef CC
- CC=gcc
- endif
  
! ifndef CFLAGS
! CFLAGS = -MMD -O2 -Wall -g
! endif
  
  # Include directories for CVS version
  CFLAGS += -I. -I../utils -I../hostapd
--- 1,7 ----
  
! CC = $(CROSS_COMPILE)gcc
! 
! CFLAGS = $(OPT) -fno-common -pipe -fno-builtin -Wall 
  
  # Include directories for CVS version
  CFLAGS += -I. -I../utils -I../hostapd
***************
*** 30,36 ****
  	echo CONFIG_DRIVER_HOSTAP=y >> .config
  	echo CONFIG_DRIVER_WEXT=y >> .config
  	echo CONFIG_WIRELESS_EXTENSION=y >> .config
! 
  install: all
  	mkdir -p $(DESTDIR)/usr/local/sbin/
  	for i in $(ALL); do cp $$i $(DESTDIR)/usr/local/sbin/$$i; done
--- 27,33 ----
  	echo CONFIG_DRIVER_HOSTAP=y >> .config
  	echo CONFIG_DRIVER_WEXT=y >> .config
  	echo CONFIG_WIRELESS_EXTENSION=y >> .config
! 	
  install: all
  	mkdir -p $(DESTDIR)/usr/local/sbin/
  	for i in $(ALL); do cp $$i $(DESTDIR)/usr/local/sbin/$$i; done
***************
*** 169,174 ****
--- 166,204 ----
  OBJS_d += driver_test.o
  endif
  
+ ifdef CONFIG_EAP_WSC
+ OBJS += wsc_supplicant.o bufferObj.o eap_wsc.o CipherWrapper.o
+ CFLAGS += -DCONFIG_EAP_WSC -Iopenssl-0.9.8e/include/openssl
+ LIBS += openssl-0.9.8e/libcrypto.a
+ endif
+ 
+ ifdef TI_WLAN_DRIVER
+ CFLAGS += -DTI_WLAN_DRIVER \
+ 			-D__BYTE_ORDER_LITTLE_ENDIAN \
+ 			-I ../../utils \
+ 			-I ../../platforms/os/linux/inc \
+ 		       	-I ../../stad/Export_Inc \
+ 			-I ../../stad/src/Application \
+ 			-I ../../TWD/TWDriver \
+ 			-I ../../TWD/FirmwareApi \
+          		-I ../../TWD/FW_Transfer/Export_Inc \
+                         -I ../../TWD/TwIf  \
+ 			-I ../../Txn  \
+ 			-I ../../platforms/os/common/inc \
+ 			-I ../../WiLink/utils \
+ 			-I ../../WiLink/platforms/os/linux/inc \
+ 		       	-I ../../WiLink/stad/Export_Inc \
+ 			-I ../../WiLink/stad/src/Application \
+ 			-I ../../WiLink/TWD/TWDriver \
+ 			-I ../../WiLink/TWD/FirmwareApi \
+          		-I ../../WiLink/TWD/FW_Transfer/Export_Inc \
+                         -I ../../WiLink/TWD/TwIf  \
+ 			-I ../../WiLink/Txn  \
+ 			-I ../../WiLink/platforms/os/common/inc 
+        	       
+       
+ endif
+ 
  ifndef CONFIG_L2_PACKET
  CONFIG_L2_PACKET=linux
  endif
***************
*** 463,472 ****
  CFLAGS += -DEAP_TLS_FUNCS
  OBJS += eap_tls_common.o
  ifeq ($(CONFIG_TLS), openssl)
! CFLAGS += -DEAP_TLS_OPENSSL
  OBJS += tls_openssl.o
! LIBS += -lssl -lcrypto
! LIBS_p += -lcrypto
  endif
  ifeq ($(CONFIG_TLS), gnutls)
  OBJS += tls_gnutls.o
--- 493,502 ----
  CFLAGS += -DEAP_TLS_FUNCS
  OBJS += eap_tls_common.o
  ifeq ($(CONFIG_TLS), openssl)
! CFLAGS += -DEAP_TLS_OPENSSL -Iopenssl-0.9.8e/include
  OBJS += tls_openssl.o
! LIBS += -lssl -lcrypto -Lopenssl-0.9.8e
! LIBS_p += -lcrypto -Lopenssl-0.9.8e
  endif
  ifeq ($(CONFIG_TLS), gnutls)
  OBJS += tls_gnutls.o
***************
*** 740,753 ****
  endif
  endif
  
  ifndef LDO
! LDO=$(CC)
  endif
  
  dynamic_eap_methods: $(EAPDYN)
  
  wpa_supplicant: .config $(OBJS)
! 	$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
  
  eapol_test: .config $(OBJS_t)
  	$(LDO) $(LDFLAGS) -o eapol_test $(OBJS_t) $(LIBS)
--- 770,785 ----
  endif
  endif
  
+ DEPS = $(OBJS:%.o=%.d)
+ 
  ifndef LDO
! LDO=$(CROSS_COMPILE)gcc
  endif
  
  dynamic_eap_methods: $(EAPDYN)
  
  wpa_supplicant: .config $(OBJS)
! 	$(LDO) $(LDFLAGS) -o wpa_supplicant --static $(OBJS) $(LIBS) $(EXTRALIBS)
  
  eapol_test: .config $(OBJS_t)
  	$(LDO) $(LDFLAGS) -o eapol_test $(OBJS_t) $(LIBS)
***************
*** 867,873 ****
  tests: test-ms_funcs test-sha1 test-aes test-eap_sim_common test-md4 test-md5
  
  clean:
! 	rm -f core *~ *.o *.d eap_*.so $(ALL) $(WINALL)
  
  %.eps: %.fig
  	fig2dev -L eps $*.fig $*.eps
--- 899,905 ----
  tests: test-ms_funcs test-sha1 test-aes test-eap_sim_common test-md4 test-md5
  
  clean:
! 	rm -f core *~ *.o *.d eap_*.so $(ALL) $(WINALL) .depend
  
  %.eps: %.fig
  	fig2dev -L eps $*.fig $*.eps
***************
*** 890,893 ****
  	rm -rf doc/latex doc/html
  	rm -f doc/wpa_supplicant.{eps,png} wpa_supplicant-devel.pdf
  
! -include $(OBJS:%.o=%.d)
--- 922,940 ----
  	rm -rf doc/latex doc/html
  	rm -f doc/wpa_supplicant.{eps,png} wpa_supplicant-devel.pdf
  
! ifeq ("$(findstring $(MAKECMDGOALS), clean cleanall)", "")
! -include .depend
! endif
! 
! %.o: %.c
! 	@echo $@
! 	$(CROSS_COMPILE)gcc -s $(CFLAGS) -c $< -o $@
! 
! %.d: %.c
! 	@echo $@
! 	@$(CROSS_COMPILE)gcc $< -MT$(^:%.c=%.o) -M $(CFLAGS) > $@
! 
! .depend: $(DEPS)
! 	rm -f $@
! 	for aa in $^; do cat $$aa >> $@; done
! 
diff -BNcr wpa_supplicant-0.5.7/README wpa_view/wpa_suppl/README
*** wpa_supplicant-0.5.7/README	Sun Dec 31 20:11:37 2006
--- wpa_view/wpa_suppl/README	Thu Jan  1 02:00:00 1970
***************
*** 1,964 ****
- WPA Supplicant
- ==============
- 
- Copyright (c) 2003-2006, Jouni Malinen <jkmaline@cc.hut.fi> and
- contributors
- All Rights Reserved.
- 
- This program is dual-licensed under both the GPL version 2 and BSD
- license. Either license may be used at your option.
- 
- 
- 
- License
- -------
- 
- GPL v2:
- 
- This program is free software; you can redistribute it and/or modify
- it under the terms of the GNU General Public License version 2 as
- published by the Free Software Foundation.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- 
- (this copy of the license is in COPYING file)
- 
- 
- Alternatively, this software may be distributed, used, and modified
- under the terms of BSD license:
- 
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions are
- met:
- 
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 
- 3. Neither the name(s) of the above-listed copyright holder(s) nor the
-    names of its contributors may be used to endorse or promote products
-    derived from this software without specific prior written permission.
- 
- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- 
- 
- 
- Features
- --------
- 
- Supported WPA/IEEE 802.11i features:
- - WPA-PSK ("WPA-Personal")
- - WPA with EAP (e.g., with RADIUS authentication server) ("WPA-Enterprise")
-   Following authentication methods are supported with an integrate IEEE 802.1X
-   Supplicant:
-   * EAP-TLS
-   * EAP-PEAP/MSCHAPv2 (both PEAPv0 and PEAPv1)
-   * EAP-PEAP/TLS (both PEAPv0 and PEAPv1)
-   * EAP-PEAP/GTC (both PEAPv0 and PEAPv1)
-   * EAP-PEAP/OTP (both PEAPv0 and PEAPv1)
-   * EAP-PEAP/MD5-Challenge (both PEAPv0 and PEAPv1)
-   * EAP-TTLS/EAP-MD5-Challenge
-   * EAP-TTLS/EAP-GTC
-   * EAP-TTLS/EAP-OTP
-   * EAP-TTLS/EAP-MSCHAPv2
-   * EAP-TTLS/EAP-TLS
-   * EAP-TTLS/MSCHAPv2
-   * EAP-TTLS/MSCHAP
-   * EAP-TTLS/PAP
-   * EAP-TTLS/CHAP
-   * EAP-SIM
-   * EAP-AKA
-   * EAP-PSK
-   * EAP-PAX
-   * EAP-SAKE
-   * EAP-GPSK
-   * LEAP (note: requires special support from the driver for IEEE 802.11
- 	  authentication)
-   (following methods are supported, but since they do not generate keying
-    material, they cannot be used with WPA or IEEE 802.1X WEP keying)
-   * EAP-MD5-Challenge 
-   * EAP-MSCHAPv2
-   * EAP-GTC
-   * EAP-OTP
- - key management for CCMP, TKIP, WEP104, WEP40
- - RSN/WPA2 (IEEE 802.11i)
-   * pre-authentication
-   * PMKSA caching
- 
- Supported TLS/crypto libraries:
- - OpenSSL (default)
- - GnuTLS
- 
- Internal TLS/crypto implementation (optional):
- - can be used in place of an external TLS/crypto library
- - TLSv1
- - X.509 certificate processing
- - PKCS #1
- - ASN.1
- - RSA
- - bignum
- - minimal size (ca. 50 kB binary, parts of which are already needed for WPA;
-   TLSv1/X.509/ASN.1/RSA/bignum parts are about 25 kB on x86)
- 
- 
- Requirements
- ------------
- 
- Current hardware/software requirements:
- - Linux kernel 2.4.x or 2.6.x with Linux Wireless Extensions v15 or newer
- - FreeBSD 6-CURRENT
- - NetBSD-current
- - Microsoft Windows with WinPcap (at least WinXP, may work with other versions)
- - drivers:
- 	Linux drivers that support WPA/WPA2 configuration with the generic
- 	Linux wireless extensions (WE-18 or newer). Even though there are
- 	number of driver specific interface included in wpa_supplicant, please
- 	note that Linux drivers are moving to use generic wireless extensions
- 	and driver_wext (-Dwext on wpa_supplicant command line) should be the
- 	default option to start with before falling back to driver specific
- 	interface.
- 
- 	Host AP driver for Prism2/2.5/3 (development snapshot/v0.2.x)
- 	(http://hostap.epitest.fi/)
- 	Driver need to be set in Managed mode ('iwconfig wlan0 mode managed').
- 	Please note that station firmware version needs to be 1.7.0 or newer
- 	to work in WPA mode.
- 
- 	Linuxant DriverLoader (http://www.linuxant.com/driverloader/)
- 	with Windows NDIS driver for your wlan card supporting WPA.
- 
- 	Agere Systems Inc. Linux Driver
- 	(http://www.agere.com/support/drivers/)
- 	Please note that the driver interface file (driver_hermes.c) and
- 	hardware specific include files are not included in the
- 	wpa_supplicant distribution. You will need to copy these from the
- 	source package of the Agere driver.
- 
- 	madwifi driver for cards based on Atheros chip set (ar521x)
- 	(http://sourceforge.net/projects/madwifi/)
- 	Please note that you will need to modify the wpa_supplicant .config
- 	file to use the correct path for the madwifi driver root directory
- 	(CFLAGS += -I../madwifi/wpa line in example defconfig).
- 
- 	ATMEL AT76C5XXx driver for USB and PCMCIA cards
- 	(http://atmelwlandriver.sourceforge.net/).
- 
- 	Linux ndiswrapper (http://ndiswrapper.sourceforge.net/) with
- 	Windows NDIS driver.
- 
- 	Broadcom wl.o driver
- 	This is a generic Linux driver for Broadcom IEEE 802.11a/g cards.
- 	However, it is proprietary driver that is not publicly available
- 	except for couple of exceptions, mainly Broadcom-based APs/wireless
- 	routers that use Linux. The driver binary can be downloaded, e.g.,
- 	from Linksys support site (http://www.linksys.com/support/gpl.asp)
- 	for Linksys WRT54G. The GPL tarball includes cross-compiler and
- 	the needed header file, wlioctl.h, for compiling wpa_supplicant.
- 	This driver support in wpa_supplicant is expected to work also with
- 	other devices based on Broadcom driver (assuming the driver includes
- 	client mode support).
- 
- 	Intel ipw2100 driver
- 	(http://sourceforge.net/projects/ipw2100/)
- 
- 	Intel ipw2200 driver
- 	(http://sourceforge.net/projects/ipw2200/)
- 
- 	In theory, any driver that supports Linux wireless extensions can be
- 	used with IEEE 802.1X (i.e., not WPA) when using ap_scan=0 option in
- 	configuration file.
- 
- 	Wired Ethernet drivers (with ap_scan=0)
- 
- 	BSD net80211 layer (e.g., Atheros driver)
- 	At the moment, this is for FreeBSD 6-CURRENT branch and NetBSD-current.
- 
- 	Windows NDIS
- 	The current Windows port requires WinPcap (http://winpcap.polito.it/).
- 	See README-Windows.txt for more information.
- 
- wpa_supplicant was designed to be portable for different drivers and
- operating systems. Hopefully, support for more wlan cards and OSes will be
- added in the future. See developer's documentation
- (http://hostap.epitest.fi/wpa_supplicant/devel/) for more information about the
- design of wpa_supplicant and porting to other drivers. One main goal
- is to add full WPA/WPA2 support to Linux wireless extensions to allow
- new drivers to be supported without having to implement new
- driver-specific interface code in wpa_supplicant.
- 
- Optional libraries for layer2 packet processing:
- - libpcap (tested with 0.7.2, most relatively recent versions assumed to work,
- 	this is likely to be available with most distributions,
- 	http://tcpdump.org/)
- - libdnet (tested with v1.4, most versions assumed to work,
- 	http://libdnet.sourceforge.net/)
- 
- These libraries are _not_ used in the default Linux build. Instead,
- internal Linux specific implementation is used. libpcap/libdnet are
- more portable and they can be used by adding CONFIG_L2_PACKET=pcap into
- .config. They may also be selected automatically for other operating
- systems. In case of Windows builds, WinPcap is used by default
- (CONFIG_L2_PACKET=winpcap).
- 
- 
- Optional libraries for EAP-TLS, EAP-PEAP, and EAP-TTLS:
- - openssl (tested with 0.9.7c and 0.9.7d, assumed to work with most
-   relatively recent versions; this is likely to be available with most
-   distributions, http://www.openssl.org/)
- - GnuTLS
- - internal TLSv1 implementation
- 
- One of these libraries is needed when EAP-TLS, EAP-PEAP, EAP-TTLS, or
- EAP-FAST support is enabled. WPA-PSK mode does not require this or EAPOL/EAP
- implementation. A configuration file, .config, for compilation is
- needed to enable IEEE 802.1X/EAPOL and EAP methods. Note that EAP-MD5,
- EAP-GTC, EAP-OTP, and EAP-MSCHAPV2 cannot be used alone with WPA, so
- they should only be enabled if testing the EAPOL/EAP state
- machines. However, there can be used as inner authentication
- algorithms with EAP-PEAP and EAP-TTLS.
- 
- See Building and installing section below for more detailed
- information about the wpa_supplicant build time configuration.
- 
- 
- 
- WPA
- ---
- 
- The original security mechanism of IEEE 802.11 standard was not
- designed to be strong and has proven to be insufficient for most
- networks that require some kind of security. Task group I (Security)
- of IEEE 802.11 working group (http://www.ieee802.org/11/) has worked
- to address the flaws of the base standard and has in practice
- completed its work in May 2004. The IEEE 802.11i amendment to the IEEE
- 802.11 standard was approved in June 2004 and published in July 2004.
- 
- Wi-Fi Alliance (http://www.wi-fi.org/) used a draft version of the
- IEEE 802.11i work (draft 3.0) to define a subset of the security
- enhancements that can be implemented with existing wlan hardware. This
- is called Wi-Fi Protected Access<TM> (WPA). This has now become a
- mandatory component of interoperability testing and certification done
- by Wi-Fi Alliance. Wi-Fi provides information about WPA at its web
- site (http://www.wi-fi.org/OpenSection/protected_access.asp).
- 
- IEEE 802.11 standard defined wired equivalent privacy (WEP) algorithm
- for protecting wireless networks. WEP uses RC4 with 40-bit keys,
- 24-bit initialization vector (IV), and CRC32 to protect against packet
- forgery. All these choices have proven to be insufficient: key space is
- too small against current attacks, RC4 key scheduling is insufficient
- (beginning of the pseudorandom stream should be skipped), IV space is
- too small and IV reuse makes attacks easier, there is no replay
- protection, and non-keyed authentication does not protect against bit
- flipping packet data.
- 
- WPA is an intermediate solution for the security issues. It uses
- Temporal Key Integrity Protocol (TKIP) to replace WEP. TKIP is a
- compromise on strong security and possibility to use existing
- hardware. It still uses RC4 for the encryption like WEP, but with
- per-packet RC4 keys. In addition, it implements replay protection,
- keyed packet authentication mechanism (Michael MIC).
- 
- Keys can be managed using two different mechanisms. WPA can either use
- an external authentication server (e.g., RADIUS) and EAP just like
- IEEE 802.1X is using or pre-shared keys without need for additional
- servers. Wi-Fi calls these "WPA-Enterprise" and "WPA-Personal",
- respectively. Both mechanisms will generate a master session key for
- the Authenticator (AP) and Supplicant (client station).
- 
- WPA implements a new key handshake (4-Way Handshake and Group Key
- Handshake) for generating and exchanging data encryption keys between
- the Authenticator and Supplicant. This handshake is also used to
- verify that both Authenticator and Supplicant know the master session
- key. These handshakes are identical regardless of the selected key
- management mechanism (only the method for generating master session
- key changes).
- 
- 
- 
- IEEE 802.11i / WPA2
- -------------------
- 
- The design for parts of IEEE 802.11i that were not included in WPA has
- finished (May 2004) and this amendment to IEEE 802.11 was approved in
- June 2004. Wi-Fi Alliance is using the final IEEE 802.11i as a new
- version of WPA called WPA2. This includes, e.g., support for more
- robust encryption algorithm (CCMP: AES in Counter mode with CBC-MAC)
- to replace TKIP and optimizations for handoff (reduced number of
- messages in initial key handshake, pre-authentication, and PMKSA caching).
- 
- 
- 
- wpa_supplicant
- --------------
- 
- wpa_supplicant is an implementation of the WPA Supplicant component,
- i.e., the part that runs in the client stations. It implements WPA key
- negotiation with a WPA Authenticator and EAP authentication with
- Authentication Server. In addition, it controls the roaming and IEEE
- 802.11 authentication/association of the wlan driver.
- 
- wpa_supplicant is designed to be a "daemon" program that runs in the
- background and acts as the backend component controlling the wireless
- connection. wpa_supplicant supports separate frontend programs and an
- example text-based frontend, wpa_cli, is included with wpa_supplicant.
- 
- Following steps are used when associating with an AP using WPA:
- 
- - wpa_supplicant requests the kernel driver to scan neighboring BSSes
- - wpa_supplicant selects a BSS based on its configuration
- - wpa_supplicant requests the kernel driver to associate with the chosen
-   BSS
- - If WPA-EAP: integrated IEEE 802.1X Supplicant completes EAP
-   authentication with the authentication server (proxied by the
-   Authenticator in the AP)
- - If WPA-EAP: master key is received from the IEEE 802.1X Supplicant
- - If WPA-PSK: wpa_supplicant uses PSK as the master session key
- - wpa_supplicant completes WPA 4-Way Handshake and Group Key Handshake
-   with the Authenticator (AP)
- - wpa_supplicant configures encryption keys for unicast and broadcast
- - normal data packets can be transmitted and received
- 
- 
- 
- Building and installing
- -----------------------
- 
- In order to be able to build wpa_supplicant, you will first need to
- select which parts of it will be included. This is done by creating a
- build time configuration file, .config, in the wpa_supplicant root
- directory. Configuration options are text lines using following
- format: CONFIG_<option>=y. Lines starting with # are considered
- comments and are ignored. See defconfig file for an example configuration
- and a list of available options and additional notes.
- 
- The build time configuration can be used to select only the needed
- features and limit the binary size and requirements for external
- libraries. The main configuration parts are the selection of which
- driver interfaces (e.g., hostap, madwifi, ..) and which authentication
- methods (e.g., EAP-TLS, EAP-PEAP, ..) are included.
- 
- Following build time configuration options are used to control IEEE
- 802.1X/EAPOL and EAP state machines and all EAP methods. Including
- TLS, PEAP, or TTLS will require linking wpa_supplicant with OpenSSL
- library for TLS implementation. Alternatively, GnuTLS or the internal
- TLSv1 implementation can be used for TLS functionaly.
- 
- CONFIG_IEEE8021X_EAPOL=y
- CONFIG_EAP_MD5=y
- CONFIG_EAP_MSCHAPV2=y
- CONFIG_EAP_TLS=y
- CONFIG_EAP_PEAP=y
- CONFIG_EAP_TTLS=y
- CONFIG_EAP_GTC=y
- CONFIG_EAP_OTP=y
- CONFIG_EAP_SIM=y
- CONFIG_EAP_AKA=y
- CONFIG_EAP_PSK=y
- CONFIG_EAP_SAKE=y
- CONFIG_EAP_GPSK=y
- CONFIG_EAP_PAX=y
- CONFIG_EAP_LEAP=y
- 
- Following option can be used to include GSM SIM/USIM interface for GSM/UMTS
- authentication algorithm (for EAP-SIM/EAP-AKA). This requires pcsc-lite
- (http://www.linuxnet.com/) for smart card access.
- 
- CONFIG_PCSC=y
- 
- Following options can be added to .config to select which driver
- interfaces are included. Hermes driver interface needs to be downloaded
- from Agere (see above). CONFIG_WIRELESS_EXTENSION will be used
- automatically if any of the selected drivers need it.
- 
- CONFIG_WIRELESS_EXTENSION=y
- CONFIG_DRIVER_HOSTAP=y
- CONFIG_DRIVER_HERMES=y
- CONFIG_DRIVER_MADWIFI=y
- CONFIG_DRIVER_ATMEL=y
- CONFIG_DRIVER_WEXT=y
- CONFIG_DRIVER_NDISWRAPPER=y
- CONFIG_DRIVER_BROADCOM=y
- CONFIG_DRIVER_IPW=y
- CONFIG_DRIVER_BSD=y
- CONFIG_DRIVER_NDIS=y
- 
- Following example includes all features and driver interfaces that are
- included in the wpa_supplicant package:
- 
- CONFIG_DRIVER_HOSTAP=y
- CONFIG_DRIVER_HERMES=y
- CONFIG_DRIVER_MADWIFI=y
- CONFIG_DRIVER_ATMEL=y
- CONFIG_DRIVER_WEXT=y
- CONFIG_DRIVER_NDISWRAPPER=y
- CONFIG_DRIVER_BROADCOM=y
- CONFIG_DRIVER_IPW=y
- CONFIG_DRIVER_BSD=y
- CONFIG_DRIVER_NDIS=y
- CONFIG_WIRELESS_EXTENSION=y
- CONFIG_IEEE8021X_EAPOL=y
- CONFIG_EAP_MD5=y
- CONFIG_EAP_MSCHAPV2=y
- CONFIG_EAP_TLS=y
- CONFIG_EAP_PEAP=y
- CONFIG_EAP_TTLS=y
- CONFIG_EAP_GTC=y
- CONFIG_EAP_OTP=y
- CONFIG_EAP_SIM=y
- CONFIG_EAP_AKA=y
- CONFIG_EAP_PSK=y
- CONFIG_EAP_SAKE=y
- CONFIG_EAP_GPSK=y
- CONFIG_EAP_PAX=y
- CONFIG_EAP_LEAP=y
- CONFIG_PCSC=y
- 
- EAP-PEAP and EAP-TTLS will automatically include configured EAP
- methods (MD5, OTP, GTC, MSCHAPV2) for inner authentication selection.
- 
- 
- After you have created a configuration file, you can build
- wpa_supplicant and wpa_cli with 'make' command. You may then install
- the binaries to a suitable system directory, e.g., /usr/local/bin.
- 
- Example commands:
- 
- # build wpa_supplicant and wpa_cli
- make
- # install binaries (this may need root privileges)
- cp wpa_cli wpa_supplicant /usr/local/bin
- 
- 
- You will need to make a configuration file, e.g.,
- /etc/wpa_supplicant.conf, with network configuration for the networks
- you are going to use. Configuration file section below includes
- explanation fo the configuration file format and includes various
- examples. Once the configuration is ready, you can test whether the
- configuration work by first running wpa_supplicant with following
- command to start it on foreground with debugging enabled:
- 
- wpa_supplicant -iwlan0 -c/etc/wpa_supplicant.conf -d
- 
- Assuming everything goes fine, you can start using following command
- to start wpa_supplicant on background without debugging:
- 
- wpa_supplicant -iwlan0 -c/etc/wpa_supplicant.conf -B
- 
- Please note that if you included more than one driver interface in the
- build time configuration (.config), you may need to specify which
- interface to use by including -D<driver name> option on the command
- line. See following section for more details on command line options
- for wpa_supplicant.
- 
- 
- 
- Command line options
- --------------------
- 
- usage:
-   wpa_supplicant [-BddehLqqvwW] [-P<pid file>] [-g<global ctrl>] \
-         -i<ifname> -c<config file> [-C<ctrl>] [-D<driver>] [-p<driver_param>] \
-         [-b<br_ifname> [-N -i<ifname> -c<conf> [-C<ctrl>] [-D<driver>] \
-         [-p<driver_param>] [-b<br_ifname>] ...]
- 
- options:
-   -b = optional bridge interface name
-   -B = run daemon in the background
-   -c = Configuration file
-   -C = ctrl_interface parameter (only used if -c is not)
-   -i = interface name
-   -d = increase debugging verbosity (-dd even more)
-   -D = driver name
-   -g = global ctrl_interface
-   -K = include keys (passwords, etc.) in debug output
-   -t = include timestamp in debug messages
-   -h = show this help text
-   -L = show license (GPL and BSD)
-   -p = driver parameters
-   -P = PID file
-   -q = decrease debugging verbosity (-qq even less)
-   -v = show version
-   -w = wait for interface to be added, if needed
-   -W = wait for a control interface monitor before starting
-   -N = start describing new interface
- 
- drivers:
-   hostap = Host AP driver (Intersil Prism2/2.5/3) [default]
- 	(this can also be used with Linuxant DriverLoader)
-   hermes = Agere Systems Inc. driver (Hermes-I/Hermes-II)
-   madwifi = MADWIFI 802.11 support (Atheros, etc.)
-   atmel = ATMEL AT76C5XXx (USB, PCMCIA)
-   wext = Linux wireless extensions (generic)
-   ndiswrapper = Linux ndiswrapper
-   broadcom = Broadcom wl.o driver
-   ipw = Intel ipw2100/2200 driver (old; use wext with Linux 2.6.13 or newer)
-   wired = wpa_supplicant wired Ethernet driver
-   bsd = BSD 802.11 support (Atheros, etc.)
-   ndis = Windows NDIS driver
- 
- In most common cases, wpa_supplicant is started with
- 
- wpa_supplicant -Bw -c/etc/wpa_supplicant.conf -iwlan0
- 
- This makes the process fork into background and wait for the wlan0
- interface if it is not available at startup time.
- 
- The easiest way to debug problems, and to get debug log for bug
- reports, is to start wpa_supplicant on foreground with debugging
- enabled:
- 
- wpa_supplicant -c/etc/wpa_supplicant.conf -iwlan0 -d
- 
- 
- wpa_supplicant can control multiple interfaces (radios) either by
- running one process for each interface separately or by running just
- one process and list of options at command line. Each interface is
- separated with -N argument. As an example, following command would
- start wpa_supplicant for two interfaces:
- 
- wpa_supplicant \
- 	-c wpa1.conf -i wlan0 -D hostap -N \
- 	-c wpa2.conf -i ath0 -D madwifi
- 
- 
- If the interface is added in a Linux bridge (e.g., br0), the bridge
- interface needs to be configured to wpa_supplicant in addition to the
- main interface:
- 
- wpa_supplicant -cw.conf -Dmadwifi -iath0 -bbr0
- 
- 
- Configuration file
- ------------------
- 
- wpa_supplicant is configured using a text file that lists all accepted
- networks and security policies, including pre-shared keys. See
- example configuration file, wpa_supplicant.conf, for detailed
- information about the configuration format and supported fields.
- 
- Changes to configuration file can be reloaded be sending SIGHUP signal
- to wpa_supplicant ('killall -HUP wpa_supplicant'). Similarly,
- reloading can be triggered with 'wpa_cli reconfigure' command.
- 
- Configuration file can include one or more network blocks, e.g., one
- for each used SSID. wpa_supplicant will automatically select the best
- betwork based on the order of network blocks in the configuration
- file, network security level (WPA/WPA2 is preferred), and signal
- strength.
- 
- Example configuration files for some common configurations:
- 
- 1) WPA-Personal (PSK) as home network and WPA-Enterprise with EAP-TLS as work
-    network
- 
- # allow frontend (e.g., wpa_cli) to be used by all users in 'wheel' group
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- #
- # home network; allow all valid ciphers
- network={
- 	ssid="home"
- 	scan_ssid=1
- 	key_mgmt=WPA-PSK
- 	psk="very secret passphrase"
- }
- #
- # work network; use EAP-TLS with WPA; allow only CCMP and TKIP ciphers
- network={
- 	ssid="work"
- 	scan_ssid=1
- 	key_mgmt=WPA-EAP
- 	pairwise=CCMP TKIP
- 	group=CCMP TKIP
- 	eap=TLS
- 	identity="user@example.com"
- 	ca_cert="/etc/cert/ca.pem"
- 	client_cert="/etc/cert/user.pem"
- 	private_key="/etc/cert/user.prv"
- 	private_key_passwd="password"
- }
- 
- 
- 2) WPA-RADIUS/EAP-PEAP/MSCHAPv2 with RADIUS servers that use old peaplabel
-    (e.g., Funk Odyssey and SBR, Meetinghouse Aegis, Interlink RAD-Series)
- 
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- network={
- 	ssid="example"
- 	scan_ssid=1
- 	key_mgmt=WPA-EAP
- 	eap=PEAP
- 	identity="user@example.com"
- 	password="foobar"
- 	ca_cert="/etc/cert/ca.pem"
- 	phase1="peaplabel=0"
- 	phase2="auth=MSCHAPV2"
- }
- 
- 
- 3) EAP-TTLS/EAP-MD5-Challenge configuration with anonymous identity for the
-    unencrypted use. Real identity is sent only within an encrypted TLS tunnel.
- 
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- network={
- 	ssid="example"
- 	scan_ssid=1
- 	key_mgmt=WPA-EAP
- 	eap=TTLS
- 	identity="user@example.com"
- 	anonymous_identity="anonymous@example.com"
- 	password="foobar"
- 	ca_cert="/etc/cert/ca.pem"
- 	phase2="auth=MD5"
- }
- 
- 
- 4) IEEE 802.1X (i.e., no WPA) with dynamic WEP keys (require both unicast and
-    broadcast); use EAP-TLS for authentication
- 
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- network={
- 	ssid="1x-test"
- 	scan_ssid=1
- 	key_mgmt=IEEE8021X
- 	eap=TLS
- 	identity="user@example.com"
- 	ca_cert="/etc/cert/ca.pem"
- 	client_cert="/etc/cert/user.pem"
- 	private_key="/etc/cert/user.prv"
- 	private_key_passwd="password"
- 	eapol_flags=3
- }
- 
- 
- 5) Catch all example that allows more or less all configuration modes. The
-    configuration options are used based on what security policy is used in the
-    selected SSID. This is mostly for testing and is not recommended for normal
-    use.
- 
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- network={
- 	ssid="example"
- 	scan_ssid=1
- 	key_mgmt=WPA-EAP WPA-PSK IEEE8021X NONE
- 	pairwise=CCMP TKIP
- 	group=CCMP TKIP WEP104 WEP40
- 	psk="very secret passphrase"
- 	eap=TTLS PEAP TLS
- 	identity="user@example.com"
- 	password="foobar"
- 	ca_cert="/etc/cert/ca.pem"
- 	client_cert="/etc/cert/user.pem"
- 	private_key="/etc/cert/user.prv"
- 	private_key_passwd="password"
- 	phase1="peaplabel=0"
- 	ca_cert2="/etc/cert/ca2.pem"
- 	client_cert2="/etc/cer/user.pem"
- 	private_key2="/etc/cer/user.prv"
- 	private_key2_passwd="password"
- }
- 
- 
- 6) Authentication for wired Ethernet. This can be used with 'wired' interface
-    (-Dwired on command line).
- 
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- ap_scan=0
- network={
- 	key_mgmt=IEEE8021X
- 	eap=MD5
- 	identity="user"
- 	password="password"
- 	eapol_flags=0
- }
- 
- 
- 
- Certificates
- ------------
- 
- Some EAP authentication methods require use of certificates. EAP-TLS
- uses both server side and client certificates whereas EAP-PEAP and
- EAP-TTLS only require the server side certificate. When client
- certificate is used, a matching private key file has to also be
- included in configuration. If the private key uses a passphrase, this
- has to be configured in wpa_supplicant.conf ("private_key_passwd").
- 
- wpa_supplicant supports X.509 certificates in PEM and DER
- formats. User certificate and private key can be included in the same
- file.
- 
- If the user certificate and private key is received in PKCS#12/PFX
- format, they need to be converted to suitable PEM/DER format for
- wpa_supplicant. This can be done, e.g., with following commands:
- 
- # convert client certificate and private key to PEM format
- openssl pkcs12 -in example.pfx -out user.pem -clcerts
- # convert CA certificate (if included in PFX file) to PEM format
- openssl pkcs12 -in example.pfx -out ca.pem -cacerts -nokeys
- 
- 
- 
- wpa_cli
- -------
- 
- wpa_cli is a text-based frontend program for interacting with
- wpa_supplicant. It is used to query current status, change
- configuration, trigger events, and request interactive user input.
- 
- wpa_cli can show the current authentication status, selected security
- mode, dot11 and dot1x MIBs, etc. In addition, it can configure some
- variables like EAPOL state machine parameters and trigger events like
- reassociation and IEEE 802.1X logoff/logon. wpa_cli provides a user
- interface to request authentication information, like username and
- password, if these are not included in the configuration. This can be
- used to implement, e.g., one-time-passwords or generic token card
- authentication where the authentication is based on a
- challenge-response that uses an external device for generating the
- response.
- 
- The control interface of wpa_supplicant can be configured to allow
- non-root user access (ctrl_interface_group in the configuration
- file). This makes it possible to run wpa_cli with a normal user
- account.
- 
- wpa_cli supports two modes: interactive and command line. Both modes
- share the same command set and the main difference is in interactive
- mode providing access to unsolicited messages (event messages,
- username/password requests).
- 
- Interactive mode is started when wpa_cli is executed without including
- the command as a command line parameter. Commands are then entered on
- the wpa_cli prompt. In command line mode, the same commands are
- entered as command line arguments for wpa_cli.
- 
- 
- Interactive authentication parameters request
- 
- When wpa_supplicant need authentication parameters, like username and
- password, which are not present in the configuration file, it sends a
- request message to all attached frontend programs, e.g., wpa_cli in
- interactive mode. wpa_cli shows these requests with
- "CTRL-REQ-<type>-<id>:<text>" prefix. <type> is IDENTITY, PASSWORD, or
- OTP (one-time-password). <id> is a unique identifier for the current
- network. <text> is description of the request. In case of OTP request,
- it includes the challenge from the authentication server.
- 
- The reply to these requests can be given with 'identity', 'password',
- and 'otp' commands. <id> needs to be copied from the the matching
- request. 'password' and 'otp' commands can be used regardless of
- whether the request was for PASSWORD or OTP. The main difference
- between these two commands is that values given with 'password' are
- remembered as long as wpa_supplicant is running whereas values given
- with 'otp' are used only once and then forgotten, i.e., wpa_supplicant
- will ask frontend for a new value for every use. This can be used to
- implement one-time-password lists and generic token card -based
- authentication.
- 
- Example request for password and a matching reply:
- 
- CTRL-REQ-PASSWORD-1:Password needed for SSID foobar
- > password 1 mysecretpassword
- 
- Example request for generic token card challenge-response:
- 
- CTRL-REQ-OTP-2:Challenge 1235663 needed for SSID foobar
- > otp 2 9876
- 
- 
- wpa_cli commands
- 
-   status = get current WPA/EAPOL/EAP status
-   mib = get MIB variables (dot1x, dot11)
-   help = show this usage help
-   interface [ifname] = show interfaces/select interface
-   level <debug level> = change debug level
-   license = show full wpa_cli license
-   logoff = IEEE 802.1X EAPOL state machine logoff
-   logon = IEEE 802.1X EAPOL state machine logon
-   set = set variables (shows list of variables when run without arguments)
-   pmksa = show PMKSA cache
-   reassociate = force reassociation
-   reconfigure = force wpa_supplicant to re-read its configuration file
-   preauthenticate <BSSID> = force preauthentication
-   identity <network id> <identity> = configure identity for an SSID
-   password <network id> <password> = configure password for an SSID
-   pin <network id> <pin> = configure pin for an SSID
-   otp <network id> <password> = configure one-time-password for an SSID
-   passphrase <network id> <passphrase> = configure private key passphrase
-     for an SSID
-   bssid <network id> <BSSID> = set preferred BSSID for an SSID
-   list_networks = list configured networks
-   select_network <network id> = select a network (disable others)
-   enable_network <network id> = enable a network
-   disable_network <network id> = disable a network
-   add_network = add a network
-   remove_network <network id> = remove a network
-   set_network <network id> <variable> <value> = set network variables (shows
-     list of variables when run without arguments)
-   get_network <network id> <variable> = get network variables
-   save_config = save the current configuration
-   disconnect = disconnect and wait for reassociate command before connecting
-   scan = request new BSS scan
-   scan_results = get latest scan results
-   get_capability <eap/pairwise/group/key_mgmt/proto/auth_alg> = get capabilies
-   terminate = terminate wpa_supplicant
-   quit = exit wpa_cli
- 
- 
- wpa_cli command line options
- 
- wpa_cli [-p<path to ctrl sockets>] [-i<ifname>] [-hvB] [-a<action file>] \
-         [-P<pid file>] [-g<global ctrl>]  [command..]
-   -h = help (show this usage text)
-   -v = shown version information
-   -a = run in daemon mode executing the action file based on events from
-        wpa_supplicant
-   -B = run a daemon in the background
-   default path: /var/run/wpa_supplicant
-   default interface: first interface found in socket path
- 
- 
- Using wpa_cli to run external program on connect/disconnect
- -----------------------------------------------------------
- 
- wpa_cli can used to run external programs whenever wpa_supplicant
- connects or disconnects from a network. This can be used, e.g., to
- update network configuration and/or trigget DHCP client to update IP
- addresses, etc.
- 
- One wpa_cli process in "action" mode needs to be started for each
- interface. For example, the following command starts wpa_cli for the
- default ingterface (-i can be used to select the interface in case of
- more than one interface being used at the same time):
- 
- wpa_cli -a/sbin/wpa_action.sh -B
- 
- The action file (-a option, /sbin/wpa_action.sh in this example) will
- be executed whenever wpa_supplicant completes authentication (connect
- event) or detects disconnection). The action script will be called
- with two command line arguments: interface name and event (CONNECTED
- or DISCONNECTED). If the action script needs to get more information
- about the current network, it can use 'wpa_cli status' to query
- wpa_supplicant for more information.
- 
- Following example can be used as a simple template for an action
- script:
- 
- #!/bin/sh
- 
- IFNAME=$1
- CMD=$2
- 
- if [ "$CMD" == "CONNECTED" ]; then
-     SSID=`wpa_cli -i$IFNAME status | grep ^ssid= | cut -f2- -d=`
-     # configure network, signal DHCP client, etc.
- fi
- 
- if [ "$CMD" == "DISCONNECTED" ]; then
-     # remove network configuration, if needed
- fi
- 
- 
- 
- Integrating with pcmcia-cs/cardmgr scripts
- ------------------------------------------
- 
- wpa_supplicant needs to be running when using a wireless network with
- WPA. It can be started either from system startup scripts or from
- pcmcia-cs/cardmgr scripts (when using PC Cards). WPA handshake must be
- completed before data frames can be exchanged, so wpa_supplicant
- should be started before DHCP client.
- 
- Command line option '-w' can be used if wpa_supplicant is started
- before the wireless LAN interface is present (e.g., before inserting
- the PC Card) or is not yet up.
- 
- For example, following small changes to pcmcia-cs scripts can be used
- to enable WPA support:
- 
- Add MODE="Managed" and WPA="y" to the network scheme in
- /etc/pcmcia/wireless.opts.
- 
- Add the following block to the end of 'start' action handler in
- /etc/pcmcia/wireless:
- 
-     if [ "$WPA" = "y" -a -x /usr/local/bin/wpa_supplicant ]; then
- 	/usr/local/bin/wpa_supplicant -Bw -c/etc/wpa_supplicant.conf \
- 		-i$DEVICE
-     fi
- 
- Add the following block to the end of 'stop' action handler (may need
- to be separated from other actions) in /etc/pcmcia/wireless:
- 
-     if [ "$WPA" = "y" -a -x /usr/local/bin/wpa_supplicant ]; then
- 	killall wpa_supplicant
-     fi
- 
- This will make cardmgr start wpa_supplicant when the card is plugged
- in. wpa_supplicant will wait until the interface is set up--either
- when a static IP address is configured or when DHCP client is
- started--and will then negotiate keys with the AP.
- 
- 
- 
- Dynamic interface add and operation without configuration files
- ---------------------------------------------------------------
- 
- wpa_supplicant can be started without any configuration files or
- network interfaces. When used in this way, a global (i.e., per
- wpa_supplicant process) control interface is used to add and remove
- network interfaces. Each network interface can then be configured
- through a per-network interface control interface. For example,
- following commands show how to start wpa_supplicant without any
- network interfaces and then add a network interface and configure a
- network (SSID):
- 
- # Start wpa_supplicant in the background
- wpa_supplicant -g/var/run/wpa_supplicant-global -B
- 
- # Add a new interface (wlan0, no configuration file, driver=wext, and
- # enable control interface)
- wpa_cli -g/var/run/wpa_supplicant-global interface_add wlan0 \
- 	"" wext /var/run/wpa_supplicant
- 
- # Configure a network using the newly added network interface:
- wpa_cli -iwlan0 add_network
- wpa_cli -iwlan0 set_network 0 ssid '"test"'
- wpa_cli -iwlan0 set_network 0 key_mgmt WPA-PSK
- wpa_cli -iwlan0 set_network 0 psk '"12345678"'
- wpa_cli -iwlan0 set_network 0 pairwise TKIP
- wpa_cli -iwlan0 set_network 0 group TKIP
- wpa_cli -iwlan0 set_network 0 proto WPA
- wpa_cli -iwlan0 enable_network 0
- 
- # At this point, the new network interface should start trying to associate
- # with the WPA-PSK network using SSID test.
- 
- # Remove network interface
- wpa_cli -g/var/run/wpa_supplicant-global interface_remove wlan0
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/README-Windows.txt wpa_view/wpa_suppl/README-Windows.txt
*** wpa_supplicant-0.5.7/README-Windows.txt	Sun Aug 27 02:22:02 2006
--- wpa_view/wpa_suppl/README-Windows.txt	Thu Jan  1 02:00:00 1970
***************
*** 1,431 ****
- wpa_supplicant for Windows
- ==========================
- 
- Copyright (c) 2003-2006, Jouni Malinen <jkmaline@cc.hut.fi> and
- contributors
- All Rights Reserved.
- 
- This program is dual-licensed under both the GPL version 2 and BSD
- license. Either license may be used at your option.
- 
- This product includes software developed by the OpenSSL Project
- for use in the OpenSSL Toolkit (http://www.openssl.org/)
- 
- 
- wpa_supplicant has support for being used as a WPA/WPA2/IEEE 802.1X
- Supplicant on Windows. The current port requires that WinPcap
- (http://winpcap.polito.it/) is installed for accessing packets and the
- driver interface. Both release versions 3.0 and 3.1 are supported.
- 
- The current port is still somewhat experimental. It has been tested
- mainly on Windows XP (SP2) with limited set of NDIS drivers. In
- addition, the current version has been reported to work with Windows
- 2000.
- 
- All security modes have been verified to work (at least complete
- authentication and successfully ping a wired host):
- - plaintext
- - static WEP / open system authentication
- - static WEP / shared key authentication
- - IEEE 802.1X with dynamic WEP keys
- - WPA-PSK, TKIP, CCMP, TKIP+CCMP
- - WPA-EAP, TKIP, CCMP, TKIP+CCMP
- - WPA2-PSK, TKIP, CCMP, TKIP+CCMP
- - WPA2-EAP, TKIP, CCMP, TKIP+CCMP
- 
- 
- Binary version
- --------------
- 
- Compiled binary version of the wpa_supplicant and additional tools is
- available from http://hostap.epitest.fi/wpa_supplicant/. These
- binaries can be used after installing WinPcap.
- 
- 
- Building wpa_supplicant with mingw
- ----------------------------------
- 
- The default build setup for wpa_supplicant is to use MinGW and
- cross-compiling from Linux to MinGW/Windows. It should also be
- possible to build this under Windows using the MinGW tools, but that
- is not tested nor supported and is likely to require some changes to
- the Makefile unless cygwin is used.
- 
- 
- Building wpa_supplicant with MSVC
- ---------------------------------
- 
- wpa_supplicant can be built with Microsoft Visual C++ compiler. This
- has been tested with Microsoft Visual C++ Toolkit 2003 and Visual
- Studio 2005 using the included nmake.mak as a Makefile for nmake. IDE
- can also be used by creating a project that includes the files and
- defines mentioned in nmake.mak. Example VS2005 solution and project
- files are included in vs2005 subdirectory. This can be used as a
- starting point for building the programs with VS2005 IDE.
- 
- WinPcap development package is needed for the build and this can be
- downloaded from http://www.winpcap.org/install/bin/WpdPack_3_1.zip. The
- default nmake.mak expects this to be unpacked into C:\dev\WpdPack so
- that Include and Lib directories are in this directory. The files can be
- stored elsewhere as long as the WINPCAPDIR in nmake.mak is updated to
- match with the selected directory. In case a project file in the IDE is
- used, these Include and Lib directories need to be added to project
- properties as additional include/library directories.
- 
- OpenSSL source package can be downloaded from
- http://www.openssl.org/source/openssl-0.9.8b.tar.gz and built and
- installed following instructions in INSTALL.W32. Note that if EAP-FAST
- support will be included in the wpa_supplicant, OpenSSL needs to be
- patched to# support it openssl-tls-extensions.patch. The example
- nmake.mak file expects OpenSSL to be installed into C:\dev\openssl, but
- this directory can be modified by changing OPENSSLDIR variable in
- nmake.mak.
- 
- If you do not need EAP-FAST support, you may also be able to use Win32
- binary installation package of OpenSSL from
- http://www.slproweb.com/products/Win32OpenSSL.html instead of building
- the library yourself. In this case, you will need to copy Include and
- Lib directories in suitable directory, e.g., C:\dev\openssl for the
- default nmake.mak. Copy {Win32OpenSSLRoot}\include into
- C:\dev\openssl\include and make C:\dev\openssl\lib subdirectory with
- files from {Win32OpenSSLRoot}\VC (i.e., libeay*.lib and ssleay*.lib).
- This will end up using dynamically linked OpenSSL (i.e., .dll files are
- needed) for it. Alternative, you can copy files from
- {Win32OpenSSLRoot}\VC\static to create a static build (no OpenSSL .dll
- files needed).
- 
- 
- Building wpa_supplicant for cygwin
- ----------------------------------
- 
- wpa_supplicant can be built for cygwin by installing the needed
- development packages for cygwin. This includes things like compiler,
- make, openssl development package, etc. In addition, developer's pack
- for WinPcap (WPdpack.zip) from
- http://winpcap.polito.it/install/default.htm is needed.
- 
- .config file should enable only one driver interface,
- CONFIG_DRIVER_NDIS. In addition, include directories may need to be
- added to match the system. An example configuration is available in
- defconfig. The library and include files for WinPcap will either need
- to be installed in compiler/linker default directories or their
- location will need to be adding to .config when building
- wpa_supplicant.
- 
- Othen than this, the build should be more or less identical to Linux
- version, i.e., just run make after having created .config file. An
- additional tool, win_if_list.exe, can be built by running "make
- win_if_list".
- 
- 
- Building wpa_gui
- ----------------
- 
- wpa_gui uses Qt application framework from Trolltech. It can be built
- with the open source version of Qt4 and MinGW. Following commands can
- be used to build the binary in the Qt 4 Command Prompt:
- 
- # go to the root directory of wpa_supplicant source code
- cd wpa_gui-qt4
- qmake -o Makefile wpa_gui.pro
- make
- # the wpa_gui.exe binary is created into 'release' subdirectory
- 
- 
- Using wpa_supplicant for Windows
- --------------------------------
- 
- wpa_supplicant and wpa_cli behave more or less identically to Linux
- version, so instructions in README and example wpa_supplicant.conf
- should be applicable for most parts. In addition, there is another
- version of wpa_supplicant, wpasvc.exe, which can be used as a Windows
- service and which reads its configuration from registry instead of
- text file.
- 
- When using access points in "hidden SSID" mode, ap_scan=2 mode need to
- be used (see wpa_supplicant.conf for more information).
- 
- Windows NDIS/WinPcap uses quite long interface names, so some care
- will be needed when starting wpa_supplicant. Alternatively, the
- adapter description can be used as the interface name which may be
- easier since it is usually in more human-readable
- format. win_if_list.exe can be used to find out the proper interface
- name.
- 
- Example steps in starting up wpa_supplicant:
- 
- # win_if_list.exe
- ifname: \Device\NPF_GenericNdisWanAdapter
- description: Generic NdisWan adapter
- 
- ifname: \Device\NPF_{769E012B-FD17-4935-A5E3-8090C38E25D2}
- description: Atheros Wireless Network Adapter (Microsoft's Packet Scheduler)
- 
- ifname: \Device\NPF_{732546E7-E26C-48E3-9871-7537B020A211}
- description: Intel 8255x-based Integrated Fast Ethernet (Microsoft's Packet Scheduler)
- 
- 
- Since the example configuration used Atheros WLAN card, the middle one
- is the correct interface in this case. The interface name for -i
- command line option is the full string following "ifname:" (the
- "\Device\NPF_" prefix can be removed). In other words, wpa_supplicant
- would be started with the following command:
- 
- # wpa_supplicant.exe -i'{769E012B-FD17-4935-A5E3-8090C38E25D2}' -c wpa_supplicant.conf -d
- 
- -d optional enables some more debugging (use -dd for even more, if
- needed). It can be left out if debugging information is not needed.
- 
- With the alternative mechanism for selecting the interface, this
- command has identical results in this case:
- 
- # wpa_supplicant.exe -iAtheros -c wpa_supplicant.conf -d
- 
- 
- Simple configuration example for WPA-PSK:
- 
- #ap_scan=2
- ctrl_interface=
- network={
- 	ssid="test"
- 	key_mgmt=WPA-PSK
- 	proto=WPA
- 	pairwise=TKIP
- 	psk="secret passphrase"
- }
- 
- (remove '#' from the comment out ap_scan line to enable mode in which
- wpa_supplicant tries to associate with the SSID without doing
- scanning; this allows APs with hidden SSIDs to be used)
- 
- 
- wpa_cli.exe and wpa_gui.exe can be used to interact with the
- wpa_supplicant.exe program in the same way as with Linux. Note that
- ctrl_interface is using UNIX domain sockets when built for cygwin, but
- the native build for Windows uses named pipes and the contents of the
- ctrl_interface configuration item is used to control access to the
- interface. Anyway, this variable has to be included in the configuration
- to enable the control interface.
- 
- 
- Example SDDL string formats:
- 
- (local admins group has permission, but nobody else):
- 
- ctrl_interface=SDDL=D:(A;;GA;;;BA)
- 
- ("A" == "access allowed", "GA" == GENERIC_ALL == all permissions, and
- "BA" == "builtin administrators" == the local admins.  The empty fields
- are for flags and object GUIDs, none of which should be required in this
- case.)
- 
- (local admins and the local "power users" group have permissions,
- but nobody else):
- 
- ctrl_interface=SDDL=D:(A;;GA;;;BA)(A;;GA;;;PU)
- 
- (One ACCESS_ALLOWED ACE for GENERIC_ALL for builtin administrators, and
- one ACCESS_ALLOWED ACE for GENERIC_ALL for power users.)
- 
- (close to wide open, but you have to be a valid user on
- the machine):
- 
- ctrl_interface=SDDL=D:(A;;GA;;;AU)
- 
- (One ACCESS_ALLOWED ACE for GENERIC_ALL for the "authenticated users"
- group.)
- 
- This one would allow absolutely everyone (including anonymous
- users) -- this is *not* recommended, since named pipes can be attached
- to from anywhere on the network (i.e. there's no "this machine only"
- like there is with 127.0.0.1 sockets):
- 
- ctrl_interface=SDDL=D:(A;;GA;;;BU)(A;;GA;;;AN)
- 
- (BU == "builtin users", "AN" == "anonymous")
- 
- See also [1] for the format of ACEs, and [2] for the possible strings
- that can be used for principal names.
- 
- [1]
- http://msdn.microsoft.com/library/default.asp?url=/library/en-us/secauthz/security/ace_strings.asp
- [2]
- http://msdn.microsoft.com/library/default.asp?url=/library/en-us/secauthz/security/sid_strings.asp
- 
- 
- Starting wpa_supplicant as a Windows service (wpasvc.exe)
- ---------------------------------------------------------
- 
- wpa_supplicant can be started as a Windows service by using wpasvc.exe
- program that is alternative build of wpa_supplicant.exe. Most of the
- core functionality of wpasvc.exe is identical to wpa_supplicant.exe,
- but it is using Windows registry for configuration information instead
- of a text file and command line parameters. In addition, it can be
- registered as a service that can be started automatically or manually
- like any other Windows service.
- 
- The root of wpa_supplicant configuration in registry is
- HKEY_LOCAL_MACHINE\SOFTWARE\wpa_supplicant. This level includes global
- parameters and a 'interfaces' subkey with all the interface configuration
- (adapter to confname mapping). Each such mapping is a subkey that has
- 'adapter', 'config', and 'ctrl_interface' values.
- 
- This program can be run either as a normal command line application,
- e.g., for debugging, with 'wpasvc.exe app' or as a Windows service.
- Service need to be registered with 'wpasvc.exe reg <full path to
- wpasvc.exe>'. Alternatively, 'wpasvc.exe reg' can be used to register
- the service with the current location of wpasvc.exe. After this, wpasvc
- can be started like any other Windows service (e.g., 'net start wpasvc')
- or it can be configured to start automatically through the Services tool
- in administrative tasks. The service can be unregistered with
- 'wpasvc.exe unreg'.
- 
- If the service is set to start during system bootup to make the
- network connection available before any user has logged in, there may
- be a long (half a minute or so) delay in starting up wpa_supplicant
- due to WinPcap needing a driver called "Network Monitor Driver" which
- is started by default on demand.
- 
- To speed up wpa_supplicant start during system bootup, "Network
- Monitor Driver" can be configured to be started sooner by setting its
- startup type to System instead of the default Demand. To do this, open
- up Device Manager, select Show Hidden Devices, expand the "Non
- Plug-and-Play devices" branch, double click "Network Monitor Driver",
- go to the Driver tab, and change the Demand setting to System instead.
- 
- Configuration data is in HKEY_LOCAL_MACHINE\SOFTWARE\wpa_supplicant\configs
- key. Each configuration profile has its own key under this. In terms of text
- files, each profile would map to a separate text file with possibly multiple
- networks. Under each profile, there is a networks key that lists all
- networks as a subkey. Each network has set of values in the same way as
- network block in the configuration file. In addition, blobs subkey has
- possible blobs as values.
- 
- HKEY_LOCAL_MACHINE\SOFTWARE\wpa_supplicant\configs\test\networks\0000
-    ssid="example"
-    key_mgmt=WPA-PSK
- 
- See win_example.reg for an example on how to setup wpasvc.exe
- parameters in registry. It can also be imported to registry as a
- starting point for the configuration.
- 
- 
- 
- License information for third party software used in this product:
- 
-   OpenSSL License
-   ---------------
- 
- /* ====================================================================
-  * Copyright (c) 1998-2004 The OpenSSL Project.  All rights reserved.
-  *
-  * Redistribution and use in source and binary forms, with or without
-  * modification, are permitted provided that the following conditions
-  * are met:
-  *
-  * 1. Redistributions of source code must retain the above copyright
-  *    notice, this list of conditions and the following disclaimer. 
-  *
-  * 2. Redistributions in binary form must reproduce the above copyright
-  *    notice, this list of conditions and the following disclaimer in
-  *    the documentation and/or other materials provided with the
-  *    distribution.
-  *
-  * 3. All advertising materials mentioning features or use of this
-  *    software must display the following acknowledgment:
-  *    "This product includes software developed by the OpenSSL Project
-  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
-  *
-  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
-  *    endorse or promote products derived from this software without
-  *    prior written permission. For written permission, please contact
-  *    openssl-core@openssl.org.
-  *
-  * 5. Products derived from this software may not be called "OpenSSL"
-  *    nor may "OpenSSL" appear in their names without prior written
-  *    permission of the OpenSSL Project.
-  *
-  * 6. Redistributions of any form whatsoever must retain the following
-  *    acknowledgment:
-  *    "This product includes software developed by the OpenSSL Project
-  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
-  *
-  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
-  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
-  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
-  * OF THE POSSIBILITY OF SUCH DAMAGE.
-  * ====================================================================
-  *
-  * This product includes cryptographic software written by Eric Young
-  * (eay@cryptsoft.com).  This product includes software written by Tim
-  * Hudson (tjh@cryptsoft.com).
-  *
-  */
- 
-  Original SSLeay License
-  -----------------------
- 
- /* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
-  * All rights reserved.
-  *
-  * This package is an SSL implementation written
-  * by Eric Young (eay@cryptsoft.com).
-  * The implementation was written so as to conform with Netscapes SSL.
-  * 
-  * This library is free for commercial and non-commercial use as long as
-  * the following conditions are aheared to.  The following conditions
-  * apply to all code found in this distribution, be it the RC4, RSA,
-  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
-  * included with this distribution is covered by the same copyright terms
-  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
-  * 
-  * Copyright remains Eric Young's, and as such any Copyright notices in
-  * the code are not to be removed.
-  * If this package is used in a product, Eric Young should be given attribution
-  * as the author of the parts of the library used.
-  * This can be in the form of a textual message at program startup or
-  * in documentation (online or textual) provided with the package.
-  * 
-  * Redistribution and use in source and binary forms, with or without
-  * modification, are permitted provided that the following conditions
-  * are met:
-  * 1. Redistributions of source code must retain the copyright
-  *    notice, this list of conditions and the following disclaimer.
-  * 2. Redistributions in binary form must reproduce the above copyright
-  *    notice, this list of conditions and the following disclaimer in the
-  *    documentation and/or other materials provided with the distribution.
-  * 3. All advertising materials mentioning features or use of this software
-  *    must display the following acknowledgement:
-  *    "This product includes cryptographic software written by
-  *     Eric Young (eay@cryptsoft.com)"
-  *    The word 'cryptographic' can be left out if the rouines from the library
-  *    being used are not cryptographic related :-).
-  * 4. If you include any Windows specific code (or a derivative thereof) from 
-  *    the apps directory (application code) you must include an acknowledgement:
-  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
-  * 
-  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
-  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
-  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-  * SUCH DAMAGE.
-  * 
-  * The licence and distribution terms for any publically available version or
-  * derivative of this code cannot be changed.  i.e. this code cannot simply be
-  * copied and put under another distribution licence
-  * [including the GNU Public Licence.]
-  */
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/WscTypes.h wpa_view/wpa_suppl/WscTypes.h
*** wpa_supplicant-0.5.7/WscTypes.h	Thu Jan  1 02:00:00 1970
--- wpa_view/wpa_suppl/WscTypes.h	Wed Jun  9 13:29:37 2010
***************
*** 0 ****
--- 1,241 ----
+ /*
+  * WscTypes.h
+  *
+  * Copyright 2001-2009 Texas Instruments, Inc. - http://www.ti.com/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  * Alternatively, this software may be distributed under the terms of BSD
+  * license.
+  *
+  * See README and COPYING for more details.
+  */
+ 
+ #ifndef _WSC_TYPES_H_
+ #define _WSC_TYPES_H_
+ 
+ /* defines */
+ /***********/
+ 
+ #define SIZE_1_BYTE         1
+ #define SIZE_2_BYTES        2
+ #define SIZE_4_BYTES        4
+ #define SIZE_6_BYTES        6
+ #define SIZE_8_BYTES        8
+ #define SIZE_16_BYTES       16
+ #define SIZE_20_BYTES       20
+ #define SIZE_32_BYTES       32
+ #define SIZE_64_BYTES       64
+ #define SIZE_80_BYTES       80
+ #define SIZE_128_BYTES      128
+ #define SIZE_192_BYTES      192
+ 
+ 
+ #define SIZE_64_BITS        8
+ #define SIZE_128_BITS       16
+ #define SIZE_160_BITS       20
+ #define SIZE_256_BITS       32
+ #define SIZE_512_BITS       64
+ 
+ #define SIZE_ENCR_IV            SIZE_128_BITS
+ #define ENCR_DATA_BLOCK_SIZE    SIZE_128_BITS
+ #define SIZE_DATA_HASH          SIZE_160_BITS
+ #define SIZE_PUB_KEY_HASH       SIZE_160_BITS
+ #define SIZE_UUID               SIZE_16_BYTES
+ #define SIZE_PUB_KEY            SIZE_192_BYTES /* 1536 BITS */
+ 
+ #define SIZE_VERSION            SIZE_1_BYTE
+ #define SIZE_MSG_TYPE           SIZE_1_BYTE
+ #define SIZE_ENROLLEE_NONCE     SIZE_128_BITS
+ #define SIZE_REGISTRAR_NONCE    SIZE_128_BITS
+ #define SIZE_PRIM_DEV_TYPE			SIZE_8_BYTES
+ #define SIZE_PRIM_DEV_CAT_ID		SIZE_2_BYTES
+ #define SIZE_PRIM_DEV_OUI			SIZE_4_BYTES
+ #define SIZE_PRIM_DEV_SUB_CAT_ID	SIZE_2_BYTES
+ #define SIZE_AUTH_TYPE_FLAGS    SIZE_2_BYTES
+ #define SIZE_ENCR_TYPE_FLAGS    SIZE_2_BYTES
+ #define SIZE_CONN_TYPE_FLAGS    SIZE_1_BYTE
+ #define SIZE_CONFIG_METHODS		SIZE_2_BYTES
+ #define SIZE_SC_STATE			SIZE_1_BYTE
+ #define SIZE_MANUFACTURER		SIZE_32_BYTES
+ #define SIZE_MODEL_NAME			SIZE_32_BYTES
+ #define SIZE_MODEL_NUMBER		SIZE_32_BYTES
+ #define SIZE_SERIAL_NUMBER		SIZE_32_BYTES
+ #define SIZE_DEVICE_NAME		SIZE_32_BYTES
+ #define SIZE_RF_BAND			SIZE_1_BYTE
+ #define SIZE_ASSOC_STATE		SIZE_2_BYTES
+ #define SIZE_DEVICE_PWD_ID		SIZE_2_BYTES
+ #define SIZE_CONFIG_ERROR		SIZE_2_BYTES
+ #define SIZE_OS_VERSION			SIZE_4_BYTES
+ #define SIZE_E_HASH			    SIZE_256_BITS
+ #define SIZE_AUTHENTICATOR		SIZE_64_BITS
+ #define SIZE_E_SNONCE			SIZE_128_BITS
+ #define SIZE_KEY_WRAP_AUTH		SIZE_64_BITS
+ #define SIZE_REQ_TYPE			SIZE_1_BYTE
+ 
+ #define MAX_ENROLLEE_NONCE		SIZE_128_BITS
+ #define MAX_REGISTRAR_NONCE		SIZE_128_BITS
+ #define MAX_UUID	            SIZE_128_BITS
+ #define MAX_PUB_KEY	            SIZE_192_BYTES /* 1536 BITS */
+ #define MAX_AUTHENTICATOR       SIZE_256_BITS
+ #define MAX_SSID	            SIZE_32_BYTES
+ #define MAX_MAC_ADDR            SIZE_6_BYTES
+ #define MAX_KEY_WRAP_AUTH       SIZE_64_BITS
+ #define MAX_R_HASH	            SIZE_256_BITS
+ #define MAX_R_SNONCE	        SIZE_128_BITS
+ #define MAX_NW_KEY	            SIZE_512_BITS
+ #define MAX_NEW_PWD	            SIZE_64_BYTES
+ 
+ #define PRF_DIGEST_SIZE         BUF_SIZE_256_BITS
+ #define KDF_KEY_BITS            640
+ 
+ #define BUF_SIZE_64_BITS    8
+ #define BUF_SIZE_128_BITS   16
+ #define BUF_SIZE_160_BITS   20
+ #define BUF_SIZE_256_BITS   32
+ #define BUF_SIZE_512_BITS   64
+ #define BUF_SIZE_1024_BITS  128
+ #define BUF_SIZE_1536_BITS  192
+ 
+ #define RANDOM_PIN_NUMBER "********"
+ #define RANDOM_SHORT_PIN_NUMBER "****"
+ 
+ /* Data Element Definitions */
+ #define WSC_ID_AP_CHANNEL         0x1001
+ #define WSC_ID_ASSOC_STATE        0x1002
+ #define WSC_ID_AUTH_TYPE          0x1003
+ #define WSC_ID_AUTH_TYPE_FLAGS    0x1004
+ #define WSC_ID_AUTHENTICATOR      0x1005
+ #define WSC_ID_CONFIG_METHODS     0x1008
+ #define WSC_ID_CONFIG_ERROR       0x1009
+ #define WSC_ID_CONF_URL4          0x100A
+ #define WSC_ID_CONF_URL6          0x100B
+ #define WSC_ID_CONN_TYPE          0x100C
+ #define WSC_ID_CONN_TYPE_FLAGS    0x100D
+ #define WSC_ID_CREDENTIAL         0x100E
+ #define WSC_ID_DEVICE_NAME        0x1011
+ #define WSC_ID_DEVICE_PWD_ID      0x1012
+ #define WSC_ID_E_HASH1            0x1014
+ #define WSC_ID_E_HASH2            0x1015
+ #define WSC_ID_E_SNONCE1          0x1016
+ #define WSC_ID_E_SNONCE2          0x1017
+ #define WSC_ID_ENCR_SETTINGS      0x1018
+ #define WSC_ID_ENCR_TYPE          0x100F
+ #define WSC_ID_ENCR_TYPE_FLAGS    0x1010
+ #define WSC_ID_ENROLLEE_NONCE     0x101A
+ #define WSC_ID_FEATURE_ID         0x101B
+ #define WSC_ID_IDENTITY           0x101C
+ #define WSC_ID_IDENTITY_PROOF     0x101D
+ #define WSC_ID_INIT_VECTOR        0x1060
+ #define WSC_ID_KEY_WRAP_AUTH      0x101E
+ #define WSC_ID_KEY_IDENTIFIER     0x101F
+ #define WSC_ID_MAC_ADDR           0x1020
+ #define WSC_ID_MANUFACTURER       0x1021
+ #define WSC_ID_MSG_TYPE           0x1022
+ #define WSC_ID_MODEL_NAME         0x1023
+ #define WSC_ID_MODEL_NUMBER       0x1024
+ #define WSC_ID_NW_INDEX           0x1026
+ #define WSC_ID_NW_KEY             0x1027
+ #define WSC_ID_NW_KEY_INDEX       0x1028
+ #define WSC_ID_NEW_DEVICE_NAME    0x1029
+ #define WSC_ID_NEW_PWD            0x102A        
+ #define WSC_ID_OOB_DEV_PWD        0x102C
+ #define WSC_ID_OS_VERSION         0x102D
+ #define WSC_ID_POWER_LEVEL        0x102F
+ #define WSC_ID_PSK_CURRENT        0x1030
+ #define WSC_ID_PSK_MAX            0x1031
+ #define WSC_ID_PUBLIC_KEY         0x1032
+ #define WSC_ID_RADIO_ENABLED      0x1033
+ #define WSC_ID_REBOOT             0x1034
+ #define WSC_ID_REGISTRAR_CURRENT  0x1035
+ #define WSC_ID_REGISTRAR_ESTBLSHD 0x1036
+ #define WSC_ID_REGISTRAR_LIST     0x1037
+ #define WSC_ID_REGISTRAR_MAX      0x1038
+ #define WSC_ID_REGISTRAR_NONCE    0x1039
+ #define WSC_ID_REQ_TYPE           0x103A
+ #define WSC_ID_RESP_TYPE          0x103B
+ #define WSC_ID_RF_BAND            0x103C
+ #define WSC_ID_R_HASH1            0x103D
+ #define WSC_ID_R_HASH2            0x103E
+ #define WSC_ID_R_SNONCE1          0x103F
+ #define WSC_ID_R_SNONCE2          0x1040
+ #define WSC_ID_SEL_REGISTRAR      0x1041
+ #define WSC_ID_SERIAL_NUM         0x1042
+ #define WSC_ID_SC_STATE           0x1044
+ #define WSC_ID_SSID               0x1045
+ #define WSC_ID_TOT_NETWORKS       0x1046
+ #define WSC_ID_UUID_E             0x1047
+ #define WSC_ID_UUID_R             0x1048
+ #define WSC_ID_VENDOR_EXT         0x1049
+ #define WSC_ID_VERSION            0x104A
+ #define WSC_ID_X509_CERT_REQ      0x104B
+ #define WSC_ID_X509_CERT          0x104C
+ #define WSC_ID_EAP_IDENTITY       0x104D
+ #define WSC_ID_MSG_COUNTER        0x104E
+ #define WSC_ID_PUBKEY_HASH        0x104F
+ #define WSC_ID_REKEY_KEY          0x1050
+ #define WSC_ID_KEY_LIFETIME       0x1051
+ #define WSC_ID_PERM_CFG_METHODS   0x1052
+ #define WSC_ID_SEL_REG_CFG_METHODS 0x0153
+ #define WSC_ID_PRIM_DEV_TYPE      0x1054
+ #define WSC_ID_SEC_DEV_TYPE_LIST  0x1055
+ #define WSC_ID_PORTABLE_DEVICE    0x1056
+ #define WSC_ID_AP_SETUP_LOCKED    0x1057
+ #define WSC_ID_APP_LIST           0x1058
+ 
+ #define WSC_ID_EAP_TYPE           0x1059
+ #define WSC_ID_INIT_VECTOR        0x1060
+ #define WSC_ID_KEY_PROVIDED_AUTO  0x1061
+ #define WSC_ID_802_1_X_ENABLED    0x1062  
+ #define WSC_ID_APP_SESSION_KEY    0x1063
+ #define WSC_ID_WEP_TRANSMIT_KEY   0x1064
+ 
+ /* Authentication types */
+ #define WSC_AUTHTYPE_OPEN        0x0001
+ #define WSC_AUTHTYPE_WPAPSK      0x0002
+ #define WSC_AUTHTYPE_SHARED      0x0004
+ #define WSC_AUTHTYPE_WPA         0x0008
+ #define WSC_AUTHTYPE_WPA2        0x0010
+ #define WSC_AUTHTYPE_WPA2PSK     0x0020
+ 
+ /* Encryption types */
+ #define WSC_ENCRTYPE_NONE        0x0001
+ #define WSC_ENCRTYPE_WEP         0x0002
+ #define WSC_ENCRTYPE_TKIP        0x0004
+ #define WSC_ENCRTYPE_AES         0x0008
+ 
+ /* Config methods */
+ #define WSC_CONFMET_USBA            	0x0001
+ #define WSC_CONFMET_ETHERNET        	0x0002
+ #define WSC_CONFMET_LABEL           	0x0004
+ #define WSC_CONFMET_DISPLAY         	0x0008
+ #define WSC_CONFMET_EXT_NFC_TOK     	0x0010
+ #define WSC_CONFMET_INT_NFC_TOK     	0x0020
+ #define WSC_CONFMET_NFC_INTF        	0x0040
+ #define WSC_CONFMET_PBC             	0x0080
+ #define WSC_CONFMET_KEYPAD          	0x0100
+ 
+ /* Device password ID */
+ #define WSC_DEVICEPWDID_DEFAULT      0x0000
+ #define WSC_DEVICEPWDID_USER_SPEC    0x0001
+ #define WSC_DEVICEPWDID_MACHINE_SPEC 0x0002
+ #define WSC_DEVICEPWDID_REKEY			0x0003
+ #define WSC_DEVICEPWDID_PUSH_BTN     0x0004
+ #define WSC_DEVICEPWDID_REG_SPEC     0x0005
+ 
+ 
+ 
+ 
+ 
+ 
+ /* types */
+ /*********/
+ 
+ 
+ /* functions */
+ /*************/
+ 
+ #endif  /* _WSC_TYPES_H_ */
+         
diff -BNcr wpa_supplicant-0.5.7/bufferObj.c wpa_view/wpa_suppl/bufferObj.c
*** wpa_supplicant-0.5.7/bufferObj.c	Thu Jan  1 02:00:00 1970
--- wpa_view/wpa_suppl/bufferObj.c	Wed Jun  9 13:29:39 2010
***************
*** 0 ****
--- 1,277 ----
+ /*
+  * bufferObj.c
+  *
+  * Copyright 2001-2009 Texas Instruments, Inc. - http://www.ti.com/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  * Alternatively, this software may be distributed under the terms of BSD
+  * license.
+  *
+  * See README and COPYING for more details.
+  */
+ 
+ #include "includes.h"
+ #include "common.h"
+ #include "bufferObj.h"
+ 
+ #define BUFFER_CHUNK 1024
+ 
+ void *memcpy(void *dest, const void *src, size_t n);
+ 
+ /* Default constructor for Serealizing operations */
+ STATUS bufferCreateChunk(bufferObj *buff)
+ {
+ 	buff->pBase = NULL; 
+     buff->bufLen = BUFFER_CHUNK;
+ 
+     buff->pBase = (u8 *) malloc(buff->bufLen);
+ 	if( buff->pBase == NULL ) 
+ 	{
+ 		wpa_printf(MSG_ERROR,"BUFFER_OBJ: bufferCreateChunk: ERROR: Insufficient available memory");
+ 		return NOK;
+ 	}
+ 
+     buff->currOffset = 0;
+     buff->dataLen = 0; 
+     buff->allocated = 1;
+     buff->pCurrPos = buff->pBase;
+     return OK;
+ }
+ 
+ STATUS bufferCreateEmpty(bufferObj *buff, u32 length)
+ {
+ 	buff->pBase = NULL; 
+     buff->bufLen = length;
+ 
+     buff->pBase = (u8 *) malloc(buff->bufLen);
+ 	if( buff->pBase == NULL ) 
+ 	{
+ 		wpa_printf(MSG_ERROR,"BUFFER_OBJ: bufferCreateEmpty: ERROR: Insufficient available memory");
+ 		return NOK;
+ 	}
+ 
+     buff->currOffset = 0;
+     buff->dataLen = 0; 
+     buff->allocated = 1;
+     buff->pCurrPos = buff->pBase;
+ 	return OK;
+ }
+ 
+ /*
+ * Overloaded constructor for Deserialize operations.
+ *  Once data is in this bufferObj, it's easier to parse it.
+ * Input: pointer to a previously-allocated data, and its length
+ */
+ STATUS bufferCreateFill(bufferObj *buff, u8 *ptr, u32 length)
+ {
+ 	buff->pBase = ptr; 
+     buff->pCurrPos = ptr;
+     buff->bufLen = length;
+     buff->currOffset = 0;
+     buff->dataLen = length; 
+     buff->allocated = 0;
+ 
+ 	return OK;
+ }
+ 
+ u8 *bufferAdvance(bufferObj *buff, u32 offset)
+ {
+     /* Advance the pCurrPos pointer. update current length */
+ 	/*	Don't disturb the dataLength variable here */
+ 	if(buff->currOffset + offset > buff->bufLen)
+ 	{
+ 		wpa_printf(MSG_ERROR,"BUFFER_OBJ: bufferAdvance: ERROR: overflow. returns NULL.");
+ 		return NULL;
+ 	}
+     
+     buff->currOffset += offset;
+     buff->pCurrPos += offset;
+     return buff->pCurrPos;
+ }
+ 
+ u8 *bufferAppend(bufferObj *buff, u32 length, u8 *pBuff)
+ {
+     if((pBuff == NULL) || (length == 0))
+ 	{
+ 		wpa_printf(MSG_DEBUG,"BUFFER_OBJ: bufferAppend: ERROR: (pBuff == NULL) || (length == 0)");
+ 		return buff->pCurrPos;
+ 	}
+ 
+     /* IMPORTANT: if this buffer was not allocated by us */
+     /*	and points to an existing buffer, then we should be extremely careful */
+     /*	how much data we append */
+     if((!buff->allocated) && (bufferRemaining(buff) < length))
+     {
+     	u8 *ptr;
+ 
+ 		wpa_printf(MSG_DEBUG,"BUFFER_OBJ: bufferAppend: Explicitly allocating memory");
+ 
+ 		/* now we need to explicitly allocate memory. */
+ 		/* while in the process, allocate some extra mem */
+ 		ptr = (u8 *) malloc(buff->bufLen+BUFFER_CHUNK);
+ 		if( ptr == NULL ) 
+ 		{
+ 			wpa_printf(MSG_ERROR,"BUFFER_OBJ: bufferAppend: ERROR: Insufficient available memory.");
+ 			return NULL;
+ 		}
+ 
+ 		/* copy the existing data */
+ 		memcpy(ptr, buff->pBase, buff->currOffset);
+ 
+ 		/* update internal variables */
+ 		buff->pBase = ptr;
+ 		buff->pCurrPos = buff->pBase + buff->currOffset;
+ 		buff->bufLen += BUFFER_CHUNK;
+ 		buff->allocated = 1;
+     }
+ 
+     if(buff->bufLen - buff->currOffset < length)
+     {
+ 		u32 tempLen = (length>BUFFER_CHUNK)?length:BUFFER_CHUNK;
+ 
+ 		wpa_printf(MSG_DEBUG,"BUFFER_OBJ: bufferAppend: Explicitly reallocating memory");
+ 
+ 		buff->pBase = (u8 *)realloc(buff->pBase, buff->currOffset+tempLen);
+ 		if( buff->pBase == NULL ) 
+ 		{
+ 			wpa_printf(MSG_ERROR,"BUFFER_OBJ: bufferAppend: ERROR: realloc failure.");
+ 			return NULL;
+ 		}
+ 
+ 		buff->bufLen = (buff->currOffset+tempLen);
+ 		buff->pCurrPos = buff->pBase + buff->currOffset;
+     }
+ 
+     memcpy(buff->pCurrPos, pBuff, length);
+ 
+     buff->pCurrPos += length;
+     buff->currOffset += length;
+ 
+     /* the data length needs to be updated based on the pointer locations, */
+     /*	since the pointers could have been moved around (using rewind and */
+     /*	advance) before the call to append. */
+     buff->dataLen = buff->pCurrPos - buff->pBase;
+ 
+     return buff->pCurrPos-length; /* return the location at which the data was copied */
+ }
+ 
+ u8 *bufferSet(bufferObj *buff, u8 *pos)
+ {
+ 	u32 offset;
+     if ((pos < buff->pBase) || (pos > (buff->pBase + buff->bufLen)))
+    	{
+ 		wpa_printf(MSG_ERROR,"BUFFER_OBJ: bufferSet: ERROR: Buffer underflow.");
+ 		return NULL;
+ 	}
+    
+     /* Perform operation as if pos lies before pCurrPos. */
+     /*	If it lies after pCurrPos, offset will be negative, so we'll be OK */
+     offset = (u32)(buff->pCurrPos-pos);
+     buff->pCurrPos = pos;
+     buff->currOffset -= offset;
+     return buff->pCurrPos;
+ }
+ 
+ u8 *bufferReset(bufferObj *buff)
+ {
+     buff->pCurrPos = buff->pBase;
+     buff->currOffset = buff->dataLen = 0;
+     return buff->pBase;
+ }
+ 
+ u8 *bufferRewindX(bufferObj *buff, u32 length)
+ {
+     if(length > buff->currOffset)
+ 	{
+ 		wpa_printf(MSG_ERROR,"BUFFER_OBJ: bufferRewindX: ERROR: Buffer underflow.");
+ 		return NULL;
+ 	}
+ 
+     buff->currOffset -= length;
+     buff->pCurrPos = buff->pBase + buff->currOffset;
+     return buff->pCurrPos;
+ }
+ 
+ u8 *bufferRewindStart(bufferObj *buff)
+ {
+     buff->currOffset = 0;
+     buff->pCurrPos = buff->pBase;
+     return buff->pCurrPos;
+ }
+ 
+ void bufferFree(bufferObj *buff)
+ {
+     if((buff->allocated) && (buff->pBase))
+     {
+ 		free(buff->pBase);
+ 		buff->allocated = 0;
+     }
+ 	buff->pBase = NULL;
+ 	buff->pCurrPos = NULL;
+ 	buff->bufLen = 0;
+ 	buff->currOffset = 0;
+ 	buff->dataLen = 0;
+ }
+ 
+ u8 *bufferPos(bufferObj *buff) 
+ { 
+ 	return buff->pCurrPos;  
+ }
+ u32 bufferLength(bufferObj *buff) 
+ { 
+ 	return buff->dataLen; 
+ }
+ u32 bufferRemaining(bufferObj *buff) 
+ { 
+ 	return buff->bufLen - buff->currOffset;  
+ }
+ u8 *bufferGetBuf(bufferObj *buff) 
+ { 
+ 	return buff->pBase; 
+ }
+ 
+ void bufferPrint(bufferObj *buff)
+ {
+ 	u8 *str= NULL; 
+ 	u16 len;
+ 
+ 	len=bufferLength(buff)+1;
+ 	str= (u8*) malloc(len);
+ 	if( str == NULL ) 
+ 	{
+ 		wpa_printf(MSG_ERROR,"BUFFER_OBJ: bufferPrint: ERROR: Insufficient available memory.");
+ 		return ;
+ 	}
+ 	wpa_printf(MSG_DEBUG,"BUFFER_OBJ: bufferPrint: Length: %d", len);
+ 
+ 	memcpy(str,bufferGetBuf(buff),len-1);
+ 	*(str+len-1)='\0';
+ 
+ 	wpa_printf(MSG_DEBUG,"BUFFER_OBJ: bufferPrint: %s", str);
+ }
+ 
+ void bufferPrintX(bufferObj *buff) 
+ {
+ 	u8 *pCurrByte= NULL; 
+ 	u16 len;
+ 	
+ 	len=bufferLength(buff);
+ 	pCurrByte=buff->pBase;
+ 	
+ 	wpa_printf(MSG_DEBUG,"BUFFER_OBJ: bufferPrintX: pBase: 0x%x", (unsigned int)buff->pBase);
+ 	wpa_printf(MSG_DEBUG,"BUFFER_OBJ: bufferPrintX: pCurrPos: 0x%x", (unsigned int)buff->pCurrPos);
+ 	wpa_printf(MSG_DEBUG,"BUFFER_OBJ: bufferPrintX: bufLen: %d", buff->bufLen);
+ 	wpa_printf(MSG_DEBUG,"BUFFER_OBJ: bufferPrintX: currOffset: %d", buff->currOffset);
+ 	wpa_printf(MSG_DEBUG,"BUFFER_OBJ: bufferPrintX: dataLen: %d", buff->dataLen);
+ 	wpa_printf(MSG_DEBUG,"BUFFER_OBJ: bufferPrintX: allocated: %d", buff->allocated);
+ 	
+ 	wpa_printf(MSG_DEBUG,"BUFFER_OBJ: bufferPrintX: Beginning Of Buffer");
+ 	while (len--)
+ 	{
+ 		printf(" %x",*pCurrByte++);         
+ 	}
+ 	wpa_printf(MSG_DEBUG,"BUFFER_OBJ: bufferPrintX: End Of Buffer");
+ }
diff -BNcr wpa_supplicant-0.5.7/bufferObj.h wpa_view/wpa_suppl/bufferObj.h
*** wpa_supplicant-0.5.7/bufferObj.h	Thu Jan  1 02:00:00 1970
--- wpa_view/wpa_suppl/bufferObj.h	Wed Jun  9 13:29:40 2010
***************
*** 0 ****
--- 1,62 ----
+ /*
+  * bufferObj.h
+  *
+  * Copyright 2001-2009 Texas Instruments, Inc. - http://www.ti.com/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  * Alternatively, this software may be distributed under the terms of BSD
+  * license.
+  *
+  * See README and COPYING for more details.
+  */
+ 
+ #ifndef _BUFFER_OBJ
+ #define _BUFFER_OBJ
+ 
+ #define STATUS int
+ 
+ 
+ /* Moved here from obsolete "pform_types_user.h" */
+ #define OK							0
+ #define NOK							1
+ 
+ typedef struct {
+     u8 *pBase;		/* beginning of the over whole buffer */
+ 	u8 *pCurrPos;	/* points to the current position in the buffer */
+     u32 bufLen;		/* the total allocated length */
+ 	u32 currOffset;	/* the offset of the pCurrPos ptr from pBase */
+ 	u32 dataLen;		/* the length of the data stored */
+ 	u8 allocated;	/* boolean */
+ } bufferObj;
+ 
+ /* "Constructor" for serializing operations, allocating default initial length. */
+ /* NOTE bufferFree should be called when this buffer has finished its role. */
+ STATUS bufferCreateChunk(bufferObj *buff);
+ /* "Constructor" for serializing operations, allocating exact length. */
+ /* NOTE bufferFree should be called when this buffer has finished its role. */
+ STATUS bufferCreateEmpty(bufferObj *buff, u32 length);
+ /* "Constructor" for Deserialize operations. */
+ /* Input: pointer to a previously-allocated data, and its length */
+ STATUS bufferCreateFill(bufferObj *buff, u8 *ptr, u32 length);
+ 
+ 
+ u8 *bufferPos(bufferObj *buff);
+ u32 bufferLength(bufferObj *buff);
+ u32 bufferRemaining(bufferObj *buff);
+ u8 *bufferGetBuf(bufferObj *buff);
+ 
+ u8 *bufferAdvance(bufferObj *buff, u32 offset);
+ u8 *bufferAppend(bufferObj *buff, u32 length, u8 *pBuff);
+ u8 *bufferSet(bufferObj *buff, u8 *pos);
+ u8 *bufferReset(bufferObj *buff);
+ u8 *bufferRewindX(bufferObj *buff, u32 length);
+ u8 *bufferRewindStart(bufferObj *buff);
+ 
+ void bufferFree(bufferObj *buff);
+ void bufferPrint(bufferObj *buff);
+ void bufferPrintX(bufferObj *buff);
+ 
+ #endif /* _BUFFER_OBJ */
diff -BNcr wpa_supplicant-0.5.7/config.c wpa_view/wpa_suppl/config.c
*** wpa_supplicant-0.5.7/config.c	Fri Nov 24 05:26:11 2006
--- wpa_view/wpa_suppl/config.c	Wed Jun  9 13:29:41 2010
***************
*** 22,27 ****
--- 22,34 ----
  #include "l2_packet.h"
  #include "config.h"
  
+ #ifdef CONFIG_EAP_WSC
+ #include "WscTypes.h"
+ #include "ossl_typ.h"
+ #include "rand.h"
+ #include "wsc_supplicant.h"
+ #endif
+ 
  
  /*
   * Structure for network configuration parsing. This data is used to implement
***************
*** 52,72 ****
  	int key_data;
  };
  
- 
  static char * wpa_config_parse_string(const char *value, size_t *len)
  {
! 	if (*value == '"') {
  		char *pos;
! 		value++;
  		pos = os_strrchr(value, '"');
  		if (pos == NULL || pos[1] != '\0')
  			return NULL;
  		*pos = '\0';
  		*len = os_strlen(value);
  		return os_strdup(value);
! 	} else {
  		u8 *str;
  		size_t hlen = os_strlen(value);
  		if (hlen & 1)
  			return NULL;
  		*len = hlen / 2;
--- 59,83 ----
  	int key_data;
  };
  
  static char * wpa_config_parse_string(const char *value, size_t *len)
  {
! 	if (*value == '"') 
! 	{
  		char *pos;
! 			
! 		value++;		
  		pos = os_strrchr(value, '"');
  		if (pos == NULL || pos[1] != '\0')
  			return NULL;
  		*pos = '\0';
  		*len = os_strlen(value);
  		return os_strdup(value);
! 	} 
! 	else 
! 	{
  		u8 *str;
  		size_t hlen = os_strlen(value);
+ 
  		if (hlen & 1)
  			return NULL;
  		*len = hlen / 2;
***************
*** 1030,1035 ****
--- 1041,1160 ----
  	return wpa_config_write_wep_key(ssid, 3);
  }
  
+ #ifdef CONFIG_EAP_WSC
+ static int wpa_config_parse_wsc_pin(const struct parse_data *data, 
+ 					struct wpa_ssid *ssid, int line,
+ 				     const char *value)
+ {
+ 	size_t res_len;
+ 	char c_devPwd[32];
+ 	u32 val;
+ 	u32 checksum;
+ 	u8 devPwd[10];
+ 	u8 password[LONG_PIN_LEN+1];
+ 
+ 	if(!ssid->wsc_pin)
+ 	{
+ 		free(ssid->wsc_pin);
+ 	}
+ 	ssid->wsc_pin = wpa_config_parse_string(value, &res_len);
+ 
+ 	if (ssid->wsc_pin == NULL) 
+ 	{
+ 		wpa_printf(MSG_ERROR, "Line %d: failed to parse %s '%s'.",
+ 			   line, data->name, value);
+ 		return -1;
+ 	}
+ 
+ 	if ((res_len != SHORT_PIN_LEN) && (res_len != LONG_PIN_LEN))
+ 	{
+ 		wpa_printf(MSG_ERROR, "Line %d: failed to parse %s '%s'. Pin length: %d is invalid",
+ 			   line, data->name, value, res_len);
+ 		return -1;
+ 	}
+ 
+ 	if (strncmp(ssid->wsc_pin, RANDOM_PIN_NUMBER, (sizeof(RANDOM_PIN_NUMBER) - 1)) == 0)
+ 	{
+ 		RAND_bytes(devPwd, LONG_PIN_LEN);
+ 		sprintf(c_devPwd, "%08u", *(u32 *)devPwd);
+ 		
+ 		/* Compute the checksum */
+ 		c_devPwd[7] = '\0';
+ 		val = strtoul(c_devPwd, NULL, 10 );
+ 		checksum = wsc_supplicant_ComputeChecksum( val );
+ 		val = val*10 + checksum;
+ 		sprintf((char *)password, "%d", val );
+ 		password[LONG_PIN_LEN] = '\0';
+ 		free(ssid->wsc_pin);
+ 		ssid->wsc_pin = strdup((char *)password);
+ 		
+ 		wpa_printf(MSG_INFO, "Random PIN: %c-%c-%c-%c-%c-%c-%c-%c\n", password[0], password[1], password[2], password[3], password[4], password[5], password[6], password[7]);
+ 	}
+ 	else if (strncmp(ssid->wsc_pin, RANDOM_SHORT_PIN_NUMBER, (sizeof(RANDOM_SHORT_PIN_NUMBER) - 1)) == 0)
+ 	{
+ 		RAND_bytes(devPwd, SHORT_PIN_LEN);
+ 		sprintf(c_devPwd, "%04u", *(u32 *)devPwd);
+ 		c_devPwd[SHORT_PIN_LEN] = '\0';
+ 		
+ 		/* save randomized PIN created */
+ 		strcpy((char *)password, c_devPwd);
+ 		free(ssid->wsc_pin);
+ 		ssid->wsc_pin = strdup((char *)password);
+ 		
+ 		wpa_printf(MSG_INFO, "Random PIN: %c-%c-%c-%c\n", password[0], password[1], password[2], password[3]);
+ 	}
+ 	else 
+ 	{
+ 		wpa_printf(MSG_DEBUG, "PIN exist='%s'", ssid->wsc_pin);
+ 		
+ 		/* (if res_len==4 no checksum check is required) */
+ 		if (res_len == LONG_PIN_LEN)
+ 		{
+ 			/* check the checksum */
+ 			strcpy(c_devPwd, ssid->wsc_pin);
+ 			c_devPwd[7] = '\0';
+ 			val = strtoul(c_devPwd, NULL, 10 );
+ 			checksum = wsc_supplicant_ComputeChecksum( val );
+ 			if (checksum != (ssid->wsc_pin[7] - '0'))
+ 			{
+ 				/* checksum is incorrect */
+ 				wpa_printf(MSG_ERROR, "checksum is incorrect :\nCalculated checksum = %d, wsc_pin[7] = %c, Randomizing new PIN...", checksum, ssid->wsc_pin[7]);
+ 
+ 				/* Randomize new PIN */
+ 				RAND_bytes(devPwd, LONG_PIN_LEN);
+ 				sprintf(c_devPwd, "%08u", *(u32 *)devPwd);
+ 
+ 				/* Compute the checksum */
+ 				c_devPwd[7] = '\0';
+ 				val = strtoul(c_devPwd, NULL, 10 );
+ 				checksum = wsc_supplicant_ComputeChecksum( val );
+ 				val = val*10 + checksum;
+ 				sprintf((char *)password, "%d", val );
+ 				password[LONG_PIN_LEN] = '\0';
+ 				free(ssid->wsc_pin);
+ 				ssid->wsc_pin = strdup((char *)password);
+ 				
+ 				wpa_printf(MSG_INFO, "Random PIN: %c-%c-%c-%c-%c-%c-%c-%c\n", password[0], password[1], password[2], password[3], password[4], password[5], password[6], password[7]);
+ 			}
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static char * wpa_config_write_wsc_pin(const struct parse_data *data,
+ 					struct wpa_ssid *ssid)
+ {
+ 	if (ssid->wsc_pin)
+ 	{
+ 		return wpa_config_write_string_ascii((const u8 *) ssid->wsc_pin, strlen(ssid->wsc_pin));
+ 	}
+ 	return NULL;
+ }
+ 
+ #endif /* CONFIG_EAP_WSC */
+ 
+ 
  
  /* Helper macros for network block parser */
  
***************
*** 1156,1162 ****
  #ifdef CONFIG_IEEE80211W
  	{ INT_RANGE(ieee80211w, 0, 2) },
  #endif /* CONFIG_IEEE80211W */
! 	{ INT_RANGE(peerkey, 0, 1) }
  };
  
  #undef OFFSET
--- 1281,1291 ----
  #ifdef CONFIG_IEEE80211W
  	{ INT_RANGE(ieee80211w, 0, 2) },
  #endif /* CONFIG_IEEE80211W */
! 	{ INT_RANGE(peerkey, 0, 1) },
! #ifdef CONFIG_EAP_WSC
! 	{ FUNC(wsc_pin) },
! 	{ INT(wsc_mode) }
! #endif /* CONFIG_EAP_WSC */
  };
  
  #undef OFFSET
diff -BNcr wpa_supplicant-0.5.7/config_file.c wpa_view/wpa_suppl/config_file.c
*** wpa_supplicant-0.5.7/config_file.c	Fri Nov 24 05:29:53 2006
--- wpa_view/wpa_suppl/config_file.c	Wed Jun  9 13:29:42 2010
***************
*** 559,564 ****
--- 559,577 ----
  	}
  }
  
+ #ifdef CONFIG_EAP_WSC
+ static void write_wsc_pin(FILE *f, struct wpa_ssid *ssid)
+ {
+ 	char *value;
+ 
+ 	value = wpa_config_get(ssid, "wsc_pin");
+ 	if (value == NULL)
+ 		return;
+ 	if (value[0])
+ 		fprintf(f, "\twsc_pin=%s\n", value);
+ 	free(value);
+ }
+ #endif /* CONFIG_EAP_WSC */
  
  static void wpa_config_write_network(FILE *f, struct wpa_ssid *ssid)
  {
***************
*** 577,582 ****
--- 590,598 ----
  	write_pairwise(f, ssid);
  	write_group(f, ssid);
  	write_auth_alg(f, ssid);
+ #ifdef CONFIG_EAP_WSC
+ 	write_wsc_pin(f, ssid);
+ #endif /* CONFIG_EAP_WSC */
  #ifdef IEEE8021X_EAPOL
  	write_eap(f, ssid);
  	STR(identity);
diff -BNcr wpa_supplicant-0.5.7/config_ssid.h wpa_view/wpa_suppl/config_ssid.h
*** wpa_supplicant-0.5.7/config_ssid.h	Fri Nov 24 05:22:44 2006
--- wpa_view/wpa_suppl/config_ssid.h	Wed Jun  9 13:29:43 2010
***************
*** 15,20 ****
--- 15,22 ----
  #ifndef CONFIG_SSID_H
  #define CONFIG_SSID_H
  
+ #include <netinet/if_ether.h>
+ 
  #ifndef BIT
  #define BIT(n) (1 << (n))
  #endif
***************
*** 46,51 ****
--- 48,59 ----
  #define EAP_PSK_LEN_MIN 16
  #define EAP_PSK_LEN_MAX 32
  
+ #ifdef CONFIG_EAP_WSC
+ #define WSC_MODE_OFF	0
+ #define WSC_MODE_PIN	1
+ #define WSC_MODE_PBC	2
+ #endif
+ 
  
  #define DEFAULT_EAP_WORKAROUND ((unsigned int) -1)
  #define DEFAULT_EAPOL_FLAGS (EAPOL_FLAG_REQUIRE_KEY_UNICAST | \
***************
*** 200,205 ****
--- 208,232 ----
  	 */
  	int scan_ssid;
  
+ #ifdef CONFIG_EAP_WSC
+ 	/**
+ 	 * wsc_mode - the WSC mode enum
+ 	 *
+ 	 * this the WSC mode:
+ 	 *	0 - WSC_MODE_OFF
+ 	 * 	1 - WSC_MODE_PIN
+ 	 *	2 - WSC_MODE_PBC
+ 	 */
+ 	u32 wsc_mode;
+ 	/**
+ 	 * wsc_pin -the WSC PIN string
+ 	 *
+ 	 * this the WSC PIN identification string
+ 	 */
+ 	char* wsc_pin;
+ 
+ #endif /* CONFIG_EAP_WSC */
+ 
  #ifdef IEEE8021X_EAPOL
  
  	/**
diff -BNcr wpa_supplicant-0.5.7/ctrl_iface.c wpa_view/wpa_suppl/ctrl_iface.c
*** wpa_supplicant-0.5.7/ctrl_iface.c	Thu Nov 23 21:52:24 2006
--- wpa_view/wpa_suppl/ctrl_iface.c	Thu Jun 17 17:47:02 2010
***************
*** 539,549 ****
--- 539,631 ----
  }
  
  
+ #ifdef TI_WLAN_DRIVER
+ static int wpa_supplicant_compare_ssid(struct wpa_ssid *ssid1, struct wpa_ssid *ssid2)
+ {
+    int is_identical = 1,i;
+ 
+    if (ssid1->mode != ssid2->mode)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->ssid_len != ssid2->ssid_len)
+    {
+          is_identical = 0;
+    }else
+    if (((ssid1->ssid) && (!ssid2->ssid)) || ((!ssid1->ssid) && (ssid2->ssid)) 
+ 	   || (ssid1->ssid && ssid2->ssid && (strcmp((char *)ssid1->ssid,(char *)ssid2->ssid) != 0)))
+    {
+          is_identical = 0;
+    }else
+    if (((ssid1->bssid) && (!ssid2->bssid)) || ((!ssid1->bssid) && (ssid2->bssid)) 
+ 	   || (ssid1->bssid && ssid2->bssid && (memcmp((char *)ssid1->bssid,(char *)ssid2->bssid,ETH_ALEN) != 0)))
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->key_mgmt != ssid2->key_mgmt)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->group_cipher != ssid2->group_cipher)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->pairwise_cipher != ssid2->pairwise_cipher)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->proto != ssid2->proto)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->auth_alg != ssid2->auth_alg)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->wep_tx_keyidx != ssid2->wep_tx_keyidx)
+    {
+          is_identical = 0;
+    }else
+    if (((ssid1->psk) && (!ssid2->psk)) || ((!ssid1->psk) && (ssid2->psk)) 
+ 	   || (ssid1->psk && ssid2->psk && (strcmp((char *)ssid1->psk,(char *)ssid2->psk) != 0)))
+    {
+          is_identical = 0;
+    }else
+ #ifdef CONFIG_EAP_WSC
+    if (((ssid1->wsc_pin) && (!ssid2->wsc_pin)) || ((!ssid1->wsc_pin) && (ssid2->wsc_pin)) 
+ 	   || (ssid1->wsc_pin && ssid2->wsc_pin && (strcmp((char *)ssid1->wsc_pin,(char *)ssid2->wsc_pin) != 0)))
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->wsc_mode != ssid2->wsc_mode)
+    {
+          is_identical = 0;
+    }else
+ #endif /* CONFIG_EAP_WSC */
+    {
+ 		for (i=0 ; i < NUM_WEP_KEYS; i++)
+ 		{	
+ 			if ((ssid1->wep_key_len[i] != ssid2->wep_key_len[i])
+ 				 || (memcmp(ssid1->wep_key[i], ssid2->wep_key[i], ssid1->wep_key_len[i]) != 0))
+ 			{
+ 				is_identical = 0;
+ 			}
+ 		}
+    }
+ 
+    return (is_identical);
+ }
+ #endif /* TI_WLAN_DRIVER */
+ 
+ 
  static int wpa_supplicant_ctrl_iface_select_network(
  	struct wpa_supplicant *wpa_s, char *cmd)
  {
  	int id;
  	struct wpa_ssid *ssid;
+ #ifdef TI_WLAN_DRIVER
+     struct wpa_ssid *selected_ssid;
+ #endif /* TI_WLAN_DRIVER */
  
  	/* cmd: "<network id>" or "any" */
  	if (os_strcmp(cmd, "any") == 0) {
***************
*** 571,576 ****
--- 653,678 ----
  	if (ssid != wpa_s->current_ssid && wpa_s->current_ssid)
  		wpa_supplicant_disassociate(wpa_s, REASON_DEAUTH_LEAVING);
  
+ #ifdef TI_WLAN_DRIVER
+     selected_ssid = ssid;
+ 
+ 	/* remove all matching networks */
+ 	ssid = wpa_s->conf->ssid;
+ 	while (ssid) 
+ 	{
+ 		if ((ssid != selected_ssid) && (wpa_supplicant_compare_ssid(ssid, selected_ssid)))
+       	{
+         	wpa_printf(MSG_DEBUG, "CTRL_IFACE: found matching block !!! ssid = %s",ssid->ssid);
+          	if (wpa_config_remove_network(wpa_s->conf, ssid->id) < 0)
+          	{
+             	wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not remove network id=%d", ssid->id);
+          	}
+          	break;
+       	}
+ 		ssid = ssid->next;
+ 	}
+ #endif /* TI_WLAN_DRIVER */
+ 
  	/* Mark all other networks disabled and trigger reassociation */
  	ssid = wpa_s->conf->ssid;
  	while (ssid) {
***************
*** 624,634 ****
  	id = atoi(cmd);
  	wpa_printf(MSG_DEBUG, "CTRL_IFACE: DISABLE_NETWORK id=%d", id);
  
! 	ssid = wpa_config_get_network(wpa_s->conf, id);
! 	if (ssid == NULL) {
! 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find network "
! 			   "id=%d", id);
! 		return -1;
  	}
  
  	if (ssid == wpa_s->current_ssid)
--- 726,747 ----
  	id = atoi(cmd);
  	wpa_printf(MSG_DEBUG, "CTRL_IFACE: DISABLE_NETWORK id=%d", id);
  
! 	if(id == -1)
! 	{
! 		/* disable the current network */
! 		if(wpa_s->current_ssid)
! 		ssid = wpa_s->current_ssid;
! 		else
! 			return -1;
! 	}
! 	else
! 	{
! 		ssid = wpa_config_get_network(wpa_s->conf, id);
! 		if (ssid == NULL) {
! 			wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find network "
! 				   "id=%d", id);
! 			return -1;
! 		}
  	}
  
  	if (ssid == wpa_s->current_ssid)
diff -BNcr wpa_supplicant-0.5.7/ctrl_iface.c.keep wpa_view/wpa_suppl/ctrl_iface.c.keep
*** wpa_supplicant-0.5.7/ctrl_iface.c.keep	Thu Jan  1 02:00:00 1970
--- wpa_view/wpa_suppl/ctrl_iface.c.keep	Thu Jun 17 17:30:06 2010
***************
*** 0 ****
--- 1,1481 ----
+ /*
+  * WPA Supplicant / Control interface (shared code for all backends)
+  * Copyright (c) 2004-2006, Jouni Malinen <jkmaline@cc.hut.fi>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  * Alternatively, this software may be distributed under the terms of BSD
+  * license.
+  *
+  * See README and COPYING for more details.
+  */
+ 
+ #include "includes.h"
+ 
+ #include "common.h"
+ #include "eloop.h"
+ #include "wpa.h"
+ #include "wpa_supplicant.h"
+ #include "config.h"
+ #include "eapol_sm.h"
+ #include "wpa_supplicant_i.h"
+ #include "ctrl_iface.h"
+ #include "l2_packet.h"
+ #include "preauth.h"
+ #include "pmksa_cache.h"
+ #include "wpa_ctrl.h"
+ #include "eap.h"
+ 
+ 
+ static int wpa_supplicant_global_iface_interfaces(struct wpa_global *global,
+ 						  char *buf, int len);
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_set(struct wpa_supplicant *wpa_s,
+ 					 char *cmd)
+ {
+ 	char *value;
+ 	int ret = 0;
+ 
+ 	value = os_strchr(cmd, ' ');
+ 	if (value == NULL)
+ 		return -1;
+ 	*value++ = '\0';
+ 
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE SET '%s'='%s'", cmd, value);
+ 	if (os_strcasecmp(cmd, "EAPOL::heldPeriod") == 0) {
+ 		eapol_sm_configure(wpa_s->eapol,
+ 				   atoi(value), -1, -1, -1);
+ 	} else if (os_strcasecmp(cmd, "EAPOL::authPeriod") == 0) {
+ 		eapol_sm_configure(wpa_s->eapol,
+ 				   -1, atoi(value), -1, -1);
+ 	} else if (os_strcasecmp(cmd, "EAPOL::startPeriod") == 0) {
+ 		eapol_sm_configure(wpa_s->eapol,
+ 				   -1, -1, atoi(value), -1);
+ 	} else if (os_strcasecmp(cmd, "EAPOL::maxStart") == 0) {
+ 		eapol_sm_configure(wpa_s->eapol,
+ 				   -1, -1, -1, atoi(value));
+ 	} else if (os_strcasecmp(cmd, "dot11RSNAConfigPMKLifetime") == 0) {
+ 		if (wpa_sm_set_param(wpa_s->wpa, RSNA_PMK_LIFETIME,
+ 				     atoi(value)))
+ 			ret = -1;
+ 	} else if (os_strcasecmp(cmd, "dot11RSNAConfigPMKReauthThreshold") ==
+ 		   0) {
+ 		if (wpa_sm_set_param(wpa_s->wpa, RSNA_PMK_REAUTH_THRESHOLD,
+ 				     atoi(value)))
+ 			ret = -1;
+ 	} else if (os_strcasecmp(cmd, "dot11RSNAConfigSATimeout") == 0) {
+ 		if (wpa_sm_set_param(wpa_s->wpa, RSNA_SA_TIMEOUT, atoi(value)))
+ 			ret = -1;
+ 	} else
+ 		ret = -1;
+ 
+ 	return ret;
+ }
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_preauth(struct wpa_supplicant *wpa_s,
+ 					     char *addr)
+ {
+ 	u8 bssid[ETH_ALEN];
+ 
+ 	if (hwaddr_aton(addr, bssid)) {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE PREAUTH: invalid address "
+ 			   "'%s'", addr);
+ 		return -1;
+ 	}
+ 
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE PREAUTH " MACSTR, MAC2STR(bssid));
+ 	rsn_preauth_deinit(wpa_s->wpa);
+ 	if (rsn_preauth_init(wpa_s->wpa, bssid, wpa_s->current_ssid))
+ 		return -1;
+ 
+ 	return 0;
+ }
+ 
+ 
+ #ifdef CONFIG_PEERKEY
+ /* MLME-STKSTART.request(peer) */
+ static int wpa_supplicant_ctrl_iface_stkstart(
+ 	struct wpa_supplicant *wpa_s, char *addr)
+ {
+ 	u8 peer[ETH_ALEN];
+ 
+ 	if (hwaddr_aton(addr, peer)) {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE STKSTART: invalid "
+ 			   "address '%s'", peer);
+ 		return -1;
+ 	}
+ 
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE STKSTART " MACSTR,
+ 		   MAC2STR(peer));
+ 
+ 	return wpa_sm_stkstart(wpa_s->wpa, peer);
+ }
+ #endif /* CONFIG_PEERKEY */
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_ctrl_rsp(struct wpa_supplicant *wpa_s,
+ 					      char *rsp)
+ {
+ #ifdef IEEE8021X_EAPOL
+ 	char *pos, *id_pos;
+ 	int id;
+ 	struct wpa_ssid *ssid;
+ 
+ 	pos = os_strchr(rsp, '-');
+ 	if (pos == NULL)
+ 		return -1;
+ 	*pos++ = '\0';
+ 	id_pos = pos;
+ 	pos = os_strchr(pos, ':');
+ 	if (pos == NULL)
+ 		return -1;
+ 	*pos++ = '\0';
+ 	id = atoi(id_pos);
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE: field=%s id=%d", rsp, id);
+ 	wpa_hexdump_ascii_key(MSG_DEBUG, "CTRL_IFACE: value",
+ 			      (u8 *) pos, os_strlen(pos));
+ 
+ 	ssid = wpa_config_get_network(wpa_s->conf, id);
+ 	if (ssid == NULL) {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find SSID id=%d "
+ 			   "to update", id);
+ 		return -1;
+ 	}
+ 
+ 	if (os_strcmp(rsp, "IDENTITY") == 0) {
+ 		os_free(ssid->identity);
+ 		ssid->identity = (u8 *) os_strdup(pos);
+ 		ssid->identity_len = os_strlen(pos);
+ 		ssid->pending_req_identity = 0;
+ 		if (ssid == wpa_s->current_ssid)
+ 			wpa_s->reassociate = 1;
+ 	} else if (os_strcmp(rsp, "PASSWORD") == 0) {
+ 		os_free(ssid->password);
+ 		ssid->password = (u8 *) os_strdup(pos);
+ 		ssid->password_len = os_strlen(pos);
+ 		ssid->pending_req_password = 0;
+ 		if (ssid == wpa_s->current_ssid)
+ 			wpa_s->reassociate = 1;
+ 	} else if (os_strcmp(rsp, "NEW_PASSWORD") == 0) {
+ 		os_free(ssid->new_password);
+ 		ssid->new_password = (u8 *) os_strdup(pos);
+ 		ssid->new_password_len = os_strlen(pos);
+ 		ssid->pending_req_new_password = 0;
+ 		if (ssid == wpa_s->current_ssid)
+ 			wpa_s->reassociate = 1;
+ 	} else if (os_strcmp(rsp, "PIN") == 0) {
+ 		os_free(ssid->pin);
+ 		ssid->pin = os_strdup(pos);
+ 		ssid->pending_req_pin = 0;
+ 		if (ssid == wpa_s->current_ssid)
+ 			wpa_s->reassociate = 1;
+ 	} else if (os_strcmp(rsp, "OTP") == 0) {
+ 		os_free(ssid->otp);
+ 		ssid->otp = (u8 *) os_strdup(pos);
+ 		ssid->otp_len = os_strlen(pos);
+ 		os_free(ssid->pending_req_otp);
+ 		ssid->pending_req_otp = NULL;
+ 		ssid->pending_req_otp_len = 0;
+ 	} else if (os_strcmp(rsp, "PASSPHRASE") == 0) {
+ 		os_free(ssid->private_key_passwd);
+ 		ssid->private_key_passwd = (u8 *) os_strdup(pos);
+ 		ssid->pending_req_passphrase = 0;
+ 		if (ssid == wpa_s->current_ssid)
+ 			wpa_s->reassociate = 1;
+ 	} else {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Unknown field '%s'", rsp);
+ 		return -1;
+ 	}
+ 
+ 	return 0;
+ #else /* IEEE8021X_EAPOL */
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE: 802.1X not included");
+ 	return -1;
+ #endif /* IEEE8021X_EAPOL */
+ }
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_status(struct wpa_supplicant *wpa_s,
+ 					    const char *params,
+ 					    char *buf, size_t buflen)
+ {
+ 	char *pos, *end, tmp[30];
+ 	int res, verbose, ret;
+ 
+ 	verbose = os_strcmp(params, "-VERBOSE") == 0;
+ 	pos = buf;
+ 	end = buf + buflen;
+ 	if (wpa_s->wpa_state >= WPA_ASSOCIATED) {
+ 		struct wpa_ssid *ssid = wpa_s->current_ssid;
+ 		ret = os_snprintf(pos, end - pos, "bssid=" MACSTR "\n",
+ 				  MAC2STR(wpa_s->bssid));
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos - buf;
+ 		pos += ret;
+ 		if (ssid) {
+ 			u8 *_ssid = ssid->ssid;
+ 			size_t ssid_len = ssid->ssid_len;
+ 			u8 ssid_buf[MAX_SSID_LEN];
+ 			if (ssid_len == 0) {
+ 				int _res = wpa_drv_get_ssid(wpa_s, ssid_buf);
+ 				if (_res < 0)
+ 					ssid_len = 0;
+ 				else
+ 					ssid_len = _res;
+ 				_ssid = ssid_buf;
+ 			}
+ 			ret = os_snprintf(pos, end - pos, "ssid=%s\nid=%d\n",
+ 					  wpa_ssid_txt(_ssid, ssid_len),
+ 					  ssid->id);
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 
+ 			if (ssid->id_str) {
+ 				ret = os_snprintf(pos, end - pos,
+ 						  "id_str=%s\n",
+ 						  ssid->id_str);
+ 				if (ret < 0 || ret >= end - pos)
+ 					return pos - buf;
+ 				pos += ret;
+ 			}
+ 		}
+ 
+ 		pos += wpa_sm_get_status(wpa_s->wpa, pos, end - pos, verbose);
+ 	}
+ 	ret = os_snprintf(pos, end - pos, "wpa_state=%s\n",
+ 			  wpa_supplicant_state_txt(wpa_s->wpa_state));
+ 	if (ret < 0 || ret >= end - pos)
+ 		return pos - buf;
+ 	pos += ret;
+ 
+ 	if (wpa_s->l2 &&
+ 	    l2_packet_get_ip_addr(wpa_s->l2, tmp, sizeof(tmp)) >= 0) {
+ 		ret = os_snprintf(pos, end - pos, "ip_address=%s\n", tmp);
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos - buf;
+ 		pos += ret;
+ 	}
+ 
+ 	if (wpa_s->key_mgmt == WPA_KEY_MGMT_IEEE8021X ||
+ 	    wpa_s->key_mgmt == WPA_KEY_MGMT_IEEE8021X_NO_WPA) {
+ 		res = eapol_sm_get_status(wpa_s->eapol, pos, end - pos,
+ 					  verbose);
+ 		if (res >= 0)
+ 			pos += res;
+ 	}
+ 
+ 	res = rsn_preauth_get_status(wpa_s->wpa, pos, end - pos, verbose);
+ 	if (res >= 0)
+ 		pos += res;
+ 
+ 	return pos - buf;
+ }
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_bssid(struct wpa_supplicant *wpa_s,
+ 					   char *cmd)
+ {
+ 	char *pos;
+ 	int id;
+ 	struct wpa_ssid *ssid;
+ 	u8 bssid[ETH_ALEN];
+ 
+ 	/* cmd: "<network id> <BSSID>" */
+ 	pos = os_strchr(cmd, ' ');
+ 	if (pos == NULL)
+ 		return -1;
+ 	*pos++ = '\0';
+ 	id = atoi(cmd);
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE: id=%d bssid='%s'", id, pos);
+ 	if (hwaddr_aton(pos, bssid)) {
+ 		wpa_printf(MSG_DEBUG ,"CTRL_IFACE: invalid BSSID '%s'", pos);
+ 		return -1;
+ 	}
+ 
+ 	ssid = wpa_config_get_network(wpa_s->conf, id);
+ 	if (ssid == NULL) {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find SSID id=%d "
+ 			   "to update", id);
+ 		return -1;
+ 	}
+ 
+ 	os_memcpy(ssid->bssid, bssid, ETH_ALEN);
+ 	ssid->bssid_set =
+ 		os_memcmp(bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN) != 0;
+ 		
+ 
+ 	return 0;
+ }
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_list_networks(
+ 	struct wpa_supplicant *wpa_s, char *buf, size_t buflen)
+ {
+ 	char *pos, *end;
+ 	struct wpa_ssid *ssid;
+ 	int ret;
+ 
+ 	pos = buf;
+ 	end = buf + buflen;
+ 	ret = os_snprintf(pos, end - pos,
+ 			  "network id / ssid / bssid / flags\n");
+ 	if (ret < 0 || ret >= end - pos)
+ 		return pos - buf;
+ 	pos += ret;
+ 
+ 	ssid = wpa_s->conf->ssid;
+ 	while (ssid) {
+ 		ret = os_snprintf(pos, end - pos, "%d\t%s",
+ 				  ssid->id,
+ 				  wpa_ssid_txt(ssid->ssid, ssid->ssid_len));
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos - buf;
+ 		pos += ret;
+ 		if (ssid->bssid_set) {
+ 			ret = os_snprintf(pos, end - pos, "\t" MACSTR,
+ 					  MAC2STR(ssid->bssid));
+ 		} else {
+ 			ret = os_snprintf(pos, end - pos, "\tany");
+ 		}
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos - buf;
+ 		pos += ret;
+ 		ret = os_snprintf(pos, end - pos, "\t%s%s",
+ 				  ssid == wpa_s->current_ssid ?
+ 				  "[CURRENT]" : "",
+ 				  ssid->disabled ? "[DISABLED]" : "");
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos - buf;
+ 		pos += ret;
+ 		ret = os_snprintf(pos, end - pos, "\n");
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos - buf;
+ 		pos += ret;
+ 
+ 		ssid = ssid->next;
+ 	}
+ 
+ 	return pos - buf;
+ }
+ 
+ 
+ static char * wpa_supplicant_cipher_txt(char *pos, char *end, int cipher)
+ {
+ 	int first = 1, ret;
+ 	ret = os_snprintf(pos, end - pos, "-");
+ 	if (ret < 0 || ret >= end - pos)
+ 		return pos;
+ 	pos += ret;
+ 	if (cipher & WPA_CIPHER_NONE) {
+ 		ret = os_snprintf(pos, end - pos, "%sNONE", first ? "" : "+");
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos;
+ 		pos += ret;
+ 		first = 0;
+ 	}
+ 	if (cipher & WPA_CIPHER_WEP40) {
+ 		ret = os_snprintf(pos, end - pos, "%sWEP40", first ? "" : "+");
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos;
+ 		pos += ret;
+ 		first = 0;
+ 	}
+ 	if (cipher & WPA_CIPHER_WEP104) {
+ 		ret = os_snprintf(pos, end - pos, "%sWEP104",
+ 				  first ? "" : "+");
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos;
+ 		pos += ret;
+ 		first = 0;
+ 	}
+ 	if (cipher & WPA_CIPHER_TKIP) {
+ 		ret = os_snprintf(pos, end - pos, "%sTKIP", first ? "" : "+");
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos;
+ 		pos += ret;
+ 		first = 0;
+ 	}
+ 	if (cipher & WPA_CIPHER_CCMP) {
+ 		ret = os_snprintf(pos, end - pos, "%sCCMP", first ? "" : "+");
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos;
+ 		pos += ret;
+ 		first = 0;
+ 	}
+ 	return pos;
+ }
+ 
+ 
+ static char * wpa_supplicant_ie_txt(char *pos, char *end, const char *proto,
+ 				    const u8 *ie, size_t ie_len)
+ {
+ 	struct wpa_ie_data data;
+ 	int first, ret;
+ 
+ 	ret = os_snprintf(pos, end - pos, "[%s-", proto);
+ 	if (ret < 0 || ret >= end - pos)
+ 		return pos;
+ 	pos += ret;
+ 
+ 	if (wpa_parse_wpa_ie(ie, ie_len, &data) < 0) {
+ 		ret = os_snprintf(pos, end - pos, "?]");
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos;
+ 		pos += ret;
+ 		return pos;
+ 	}
+ 
+ 	first = 1;
+ 	if (data.key_mgmt & WPA_KEY_MGMT_IEEE8021X) {
+ 		ret = os_snprintf(pos, end - pos, "%sEAP", first ? "" : "+");
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos;
+ 		pos += ret;
+ 		first = 0;
+ 	}
+ 	if (data.key_mgmt & WPA_KEY_MGMT_PSK) {
+ 		ret = os_snprintf(pos, end - pos, "%sPSK", first ? "" : "+");
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos;
+ 		pos += ret;
+ 		first = 0;
+ 	}
+ 	if (data.key_mgmt & WPA_KEY_MGMT_WPA_NONE) {
+ 		ret = os_snprintf(pos, end - pos, "%sNone", first ? "" : "+");
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos;
+ 		pos += ret;
+ 		first = 0;
+ 	}
+ 
+ 	pos = wpa_supplicant_cipher_txt(pos, end, data.pairwise_cipher);
+ 
+ 	if (data.capabilities & WPA_CAPABILITY_PREAUTH) {
+ 		ret = os_snprintf(pos, end - pos, "-preauth");
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos;
+ 		pos += ret;
+ 	}
+ 
+ 	ret = os_snprintf(pos, end - pos, "]");
+ 	if (ret < 0 || ret >= end - pos)
+ 		return pos;
+ 	pos += ret;
+ 
+ 	return pos;
+ }
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_scan_results(
+ 	struct wpa_supplicant *wpa_s, char *buf, size_t buflen)
+ {
+ 	char *pos, *end;
+ 	struct wpa_scan_result *res;
+ 	int i, ret;
+ 
+ 	if (wpa_s->scan_results == NULL &&
+ 	    wpa_supplicant_get_scan_results(wpa_s) < 0)
+ 		return 0;
+ 	if (wpa_s->scan_results == NULL)
+ 		return 0;
+ 
+ 	pos = buf;
+ 	end = buf + buflen;
+ 	ret = os_snprintf(pos, end - pos, "bssid / frequency / signal level / "
+ 			  "flags / ssid\n");
+ 	if (ret < 0 || ret >= end - pos)
+ 		return pos - buf;
+ 	pos += ret;
+ 
+ 	for (i = 0; i < wpa_s->num_scan_results; i++) {
+ 		res = &wpa_s->scan_results[i];
+ 		ret = os_snprintf(pos, end - pos, MACSTR "\t%d\t%d\t",
+ 				  MAC2STR(res->bssid), res->freq, res->level);
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos - buf;
+ 		pos += ret;
+ 		if (res->wpa_ie_len) {
+ 			pos = wpa_supplicant_ie_txt(pos, end, "WPA",
+ 						    res->wpa_ie,
+ 						    res->wpa_ie_len);
+ 		}
+ 		if (res->rsn_ie_len) {
+ 			pos = wpa_supplicant_ie_txt(pos, end, "WPA2",
+ 						    res->rsn_ie,
+ 						    res->rsn_ie_len);
+ 		}
+ 		if (!res->wpa_ie_len && !res->rsn_ie_len &&
+ 		    res->caps & IEEE80211_CAP_PRIVACY) {
+ 			ret = os_snprintf(pos, end - pos, "[WEP]");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 		}
+ 		if (res->caps & IEEE80211_CAP_IBSS) {
+ 			ret = os_snprintf(pos, end - pos, "[IBSS]");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 		}
+ 
+ 		ret = os_snprintf(pos, end - pos, "\t%s",
+ 				  wpa_ssid_txt(res->ssid, res->ssid_len));
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos - buf;
+ 		pos += ret;
+ 
+ 		ret = os_snprintf(pos, end - pos, "\n");
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos - buf;
+ 		pos += ret;
+ 	}
+ 
+ 	return pos - buf;
+ }
+ 
+ 
+ #ifdef TI_WLAN_DRIVER
+ static int wpa_supplicant_compare_ssid(struct wpa_ssid *ssid1, struct wpa_ssid *ssid2)
+ {
+    int is_identical = 1,i;
+ 
+    if (ssid1->mode != ssid2->mode)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->ssid_len != ssid2->ssid_len)
+    {
+          is_identical = 0;
+    }else
+    if (((ssid1->ssid) && (!ssid2->ssid)) || ((!ssid1->ssid) && (ssid2->ssid)) 
+ 	   || (ssid1->ssid && ssid2->ssid && (strcmp((char *)ssid1->ssid,(char *)ssid2->ssid) != 0)))
+    {
+          is_identical = 0;
+    }else
+    if (((ssid1->bssid) && (!ssid2->bssid)) || ((!ssid1->bssid) && (ssid2->bssid)) 
+ 	   || (ssid1->bssid && ssid2->bssid && (memcmp((char *)ssid1->bssid,(char *)ssid2->bssid,ETH_ALEN) != 0)))
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->key_mgmt != ssid2->key_mgmt)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->group_cipher != ssid2->group_cipher)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->pairwise_cipher != ssid2->pairwise_cipher)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->proto != ssid2->proto)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->auth_alg != ssid2->auth_alg)
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->wep_tx_keyidx != ssid2->wep_tx_keyidx)
+    {
+          is_identical = 0;
+    }else
+    if (((ssid1->psk) && (!ssid2->psk)) || ((!ssid1->psk) && (ssid2->psk)) 
+ 	   || (ssid1->psk && ssid2->psk && (strcmp((char *)ssid1->psk,(char *)ssid2->psk) != 0)))
+    {
+          is_identical = 0;
+    }else
+ #ifdef CONFIG_EAP_WSC
+    if (((ssid1->wsc_pin) && (!ssid2->wsc_pin)) || ((!ssid1->wsc_pin) && (ssid2->wsc_pin)) 
+ 	   || (ssid1->wsc_pin && ssid2->wsc_pin && (strcmp((char *)ssid1->wsc_pin,(char *)ssid2->wsc_pin) != 0)))
+    {
+          is_identical = 0;
+    }else
+    if (ssid1->wsc_mode != ssid2->wsc_mode)
+    {
+          is_identical = 0;
+    }else
+ #endif /* CONFIG_EAP_WSC */
+    {
+ 		for (i=0 ; i < NUM_WEP_KEYS; i++)
+ 		{	
+ 			if ((ssid1->wep_key_len[i] != ssid2->wep_key_len[i])
+ 				 || (memcmp(ssid1->wep_key[i], ssid2->wep_key[i], ssid1->wep_key_len[i]) != 0))
+ 			{
+ 				is_identical = 0;
+ 			}
+ 		}
+    }
+ 
+    return (is_identical);
+ }
+ #endif /* TI_WLAN_DRIVER */
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_select_network(
+ 	struct wpa_supplicant *wpa_s, char *cmd)
+ {
+ 	int id;
+ 	struct wpa_ssid *ssid;
+ #ifdef TI_WLAN_DRIVER
+     struct wpa_ssid *selected_ssid;
+ #endif /* TI_WLAN_DRIVER */
+ 
+ 	/* cmd: "<network id>" or "any" */
+ 	if (os_strcmp(cmd, "any") == 0) {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: SELECT_NETWORK any");
+ 		ssid = wpa_s->conf->ssid;
+ 		while (ssid) {
+ 			ssid->disabled = 0;
+ 			ssid = ssid->next;
+ 		}
+ 		wpa_s->reassociate = 1;
+ 		wpa_supplicant_req_scan(wpa_s, 0, 0);
+ 		return 0;
+ 	}
+ 
+ 	id = atoi(cmd);
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE: SELECT_NETWORK id=%d", id);
+ 
+ 	ssid = wpa_config_get_network(wpa_s->conf, id);
+ 	if (ssid == NULL) {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find network "
+ 			   "id=%d", id);
+ 		return -1;
+ 	}
+ 
+ 	if (ssid != wpa_s->current_ssid && wpa_s->current_ssid)
+ 		wpa_supplicant_disassociate(wpa_s, REASON_DEAUTH_LEAVING);
+ 
+ #ifdef TI_WLAN_DRIVER
+     selected_ssid = ssid;
+ 
+ 	/* remove all matching networks */
+ 	ssid = wpa_s->conf->ssid;
+ 	while (ssid) 
+ 	{
+ 		if ((ssid != selected_ssid) && (wpa_supplicant_compare_ssid(ssid, selected_ssid)))
+       	{
+         	wpa_printf(MSG_DEBUG, "CTRL_IFACE: found matching block !!! ssid = %s",ssid->ssid);
+          	if (wpa_config_remove_network(wpa_s->conf, ssid->id) < 0)
+          	{
+             	wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not remove network id=%d", ssid->id);
+          	}
+          	break;
+       	}
+ 		ssid = ssid->next;
+ 	}
+ #endif /* TI_WLAN_DRIVER */
+ 
+ 	/* Mark all other networks disabled and trigger reassociation */
+ 	ssid = wpa_s->conf->ssid;
+ 	while (ssid) {
+ 		ssid->disabled = id != ssid->id;
+ 		ssid = ssid->next;
+ 	}
+ 	wpa_s->reassociate = 1;
+ 	wpa_supplicant_req_scan(wpa_s, 0, 0);
+ 
+ 	return 0;
+ }
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_enable_network(
+ 	struct wpa_supplicant *wpa_s, char *cmd)
+ {
+ 	int id;
+ 	struct wpa_ssid *ssid;
+ 
+ 	/* cmd: "<network id>" */
+ 	id = atoi(cmd);
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE: ENABLE_NETWORK id=%d", id);
+ 
+ 	ssid = wpa_config_get_network(wpa_s->conf, id);
+ 	if (ssid == NULL) {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find network "
+ 			   "id=%d", id);
+ 		return -1;
+ 	}
+ 
+ 	if (wpa_s->current_ssid == NULL && ssid->disabled) {
+ 		/*
+ 		 * Try to reassociate since there is no current configuration
+ 		 * and a new network was made available. */
+ 		wpa_s->reassociate = 1;
+ 		wpa_supplicant_req_scan(wpa_s, 0, 0);
+ 	}
+ 	ssid->disabled = 0;
+ 
+ 	return 0;
+ }
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_disable_network(
+ 	struct wpa_supplicant *wpa_s, char *cmd)
+ {
+ 	int id;
+ 	struct wpa_ssid *ssid;
+ 
+ 	/* cmd: "<network id>" */
+ 	id = atoi(cmd);
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE: DISABLE_NETWORK id=%d", id);
+ 
+ 	if(id == -1)
+ 	{
+ 		/* disable the current network */
+ 		if(wpa_s->current_ssid)
+ 		ssid = wpa_s->current_ssid;
+ 		else
+ 			return -1;
+ 	}
+ 	else
+ 	{
+ 		ssid = wpa_config_get_network(wpa_s->conf, id);
+ 		if (ssid == NULL) {
+ 			wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find network "
+ 				   "id=%d", id);
+ 			return -1;
+ 		}
+ 	}
+ 
+ 	if (ssid == wpa_s->current_ssid)
+ 		wpa_supplicant_disassociate(wpa_s, REASON_DEAUTH_LEAVING);
+ 	ssid->disabled = 1;
+ 
+ 	return 0;
+ }
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_add_network(
+ 	struct wpa_supplicant *wpa_s, char *buf, size_t buflen)
+ {
+ 	struct wpa_ssid *ssid;
+ 	int ret;
+ 
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE: ADD_NETWORK");
+ 
+ 	ssid = wpa_config_add_network(wpa_s->conf);
+ 	if (ssid == NULL)
+ 		return -1;
+ 	ssid->disabled = 1;
+ 	wpa_config_set_network_defaults(ssid);
+ 
+ 	ret = os_snprintf(buf, buflen, "%d\n", ssid->id);
+ 	if (ret < 0 || (size_t) ret >= buflen)
+ 		return -1;
+ 	return ret;
+ }
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_remove_network(
+ 	struct wpa_supplicant *wpa_s, char *cmd)
+ {
+ 	int id;
+ 	struct wpa_ssid *ssid;
+ 
+ 	/* cmd: "<network id>" */
+ 	id = atoi(cmd);
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE: REMOVE_NETWORK id=%d", id);
+ 
+ 	ssid = wpa_config_get_network(wpa_s->conf, id);
+ 	if (ssid == NULL ||
+ 	    wpa_config_remove_network(wpa_s->conf, id) < 0) {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find network "
+ 			   "id=%d", id);
+ 		return -1;
+ 	}
+ 
+ 	if (ssid == wpa_s->current_ssid) {
+ 		/*
+ 		 * Invalidate the EAP session cache if the current network is
+ 		 * removed.
+ 		 */
+ 		eapol_sm_invalidate_cached_session(wpa_s->eapol);
+ 
+ 		wpa_supplicant_disassociate(wpa_s, REASON_DEAUTH_LEAVING);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_set_network(
+ 	struct wpa_supplicant *wpa_s, char *cmd)
+ {
+ 	int id;
+ 	struct wpa_ssid *ssid;
+ 	char *name, *value;
+ 
+ 	/* cmd: "<network id> <variable name> <value>" */
+ 	name = os_strchr(cmd, ' ');
+ 	if (name == NULL)
+ 		return -1;
+ 	*name++ = '\0';
+ 
+ 	value = os_strchr(name, ' ');
+ 	if (value == NULL)
+ 		return -1;
+ 	*value++ = '\0';
+ 
+ 	id = atoi(cmd);
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE: SET_NETWORK id=%d name='%s'",
+ 		   id, name);
+ 	wpa_hexdump_ascii_key(MSG_DEBUG, "CTRL_IFACE: value",
+ 			      (u8 *) value, os_strlen(value));
+ 
+ 	ssid = wpa_config_get_network(wpa_s->conf, id);
+ 	if (ssid == NULL) {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find network "
+ 			   "id=%d", id);
+ 		return -1;
+ 	}
+ 
+ 	if (wpa_config_set(ssid, name, value, 0) < 0) {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Failed to set network "
+ 			   "variable '%s'", name);
+ 		return -1;
+ 	}
+ 
+ 	if (wpa_s->current_ssid == ssid) {
+ 		/*
+ 		 * Invalidate the EAP session cache if anything in the current
+ 		 * configuration changes.
+ 		 */
+ 		eapol_sm_invalidate_cached_session(wpa_s->eapol);
+ 	}
+ 
+ 	if ((os_strcmp(name, "psk") == 0 &&
+ 	     value[0] == '"' && ssid->ssid_len) ||
+ 	    (os_strcmp(name, "ssid") == 0 && ssid->passphrase))
+ 		wpa_config_update_psk(ssid);
+ 
+ 	return 0;
+ }
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_get_network(
+ 	struct wpa_supplicant *wpa_s, char *cmd, char *buf, size_t buflen)
+ {
+ 	int id;
+ 	struct wpa_ssid *ssid;
+ 	char *name, *value;
+ 
+ 	/* cmd: "<network id> <variable name>" */
+ 	name = os_strchr(cmd, ' ');
+ 	if (name == NULL || buflen == 0)
+ 		return -1;
+ 	*name++ = '\0';
+ 
+ 	id = atoi(cmd);
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE: GET_NETWORK id=%d name='%s'",
+ 		   id, name);
+ 
+ 	ssid = wpa_config_get_network(wpa_s->conf, id);
+ 	if (ssid == NULL) {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Could not find network "
+ 			   "id=%d", id);
+ 		return -1;
+ 	}
+ 
+ 	value = wpa_config_get_no_key(ssid, name);
+ 	if (value == NULL) {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: Failed to get network "
+ 			   "variable '%s'", name);
+ 		return -1;
+ 	}
+ 
+ 	os_snprintf(buf, buflen, "%s", value);
+ 	buf[buflen - 1] = '\0';
+ 
+ 	os_free(value);
+ 
+ 	return os_strlen(buf);
+ }
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_save_config(struct wpa_supplicant *wpa_s)
+ {
+ 	int ret;
+ 
+ 	if (!wpa_s->conf->update_config) {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: SAVE_CONFIG - Not allowed "
+ 			   "to update configuration (update_config=0)");
+ 		return -1;
+ 	}
+ 
+ 	ret = wpa_config_write(wpa_s->confname, wpa_s->conf);
+ 	if (ret) {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: SAVE_CONFIG - Failed to "
+ 			   "update configuration");
+ 	} else {
+ 		wpa_printf(MSG_DEBUG, "CTRL_IFACE: SAVE_CONFIG - Configuration"
+ 			   " updated");
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_get_capability(
+ 	struct wpa_supplicant *wpa_s, const char *_field, char *buf,
+ 	size_t buflen)
+ {
+ 	struct wpa_driver_capa capa;
+ 	int res, first = 1, ret;
+ 	char *pos, *end, *strict;
+ 	char field[30];
+ 
+ 	/* Determine whether or not strict checking was requested */
+ 	os_snprintf(field, sizeof(field), "%s", _field);
+ 	field[sizeof(field) - 1] = '\0';
+ 	strict = os_strchr(field, ' ');
+ 	if (strict != NULL) {
+ 		*strict++ = '\0';
+ 		if (os_strcmp(strict, "strict") != 0)
+ 			return -1;
+ 	}
+ 
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE: GET_CAPABILITY '%s' %s",
+ 		field, strict ? strict : "");
+ 
+ 	if (os_strcmp(field, "eap") == 0) {
+ 		return eap_get_names(buf, buflen);
+ 	}
+ 
+ 	res = wpa_drv_get_capa(wpa_s, &capa);
+ 
+ 	pos = buf;
+ 	end = pos + buflen;
+ 
+ 	if (os_strcmp(field, "pairwise") == 0) {
+ 		if (res < 0) {
+ 			if (strict)
+ 				return 0;
+ 			ret = os_snprintf(buf, buflen, "CCMP TKIP NONE");
+ 			if (ret < 0 || (size_t) ret >= buflen)
+ 				return -1;
+ 			return ret;
+ 		}
+ 
+ 		if (capa.enc & WPA_DRIVER_CAPA_ENC_CCMP) {
+ 			ret = os_snprintf(pos, end - pos, "%sCCMP",
+ 					  first ? "" : " ");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 			first = 0;
+ 		}
+ 
+ 		if (capa.enc & WPA_DRIVER_CAPA_ENC_TKIP) {
+ 			ret = os_snprintf(pos, end - pos, "%sTKIP",
+ 					  first ? "" : " ");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 			first = 0;
+ 		}
+ 
+ 		if (capa.key_mgmt & WPA_DRIVER_CAPA_KEY_MGMT_WPA_NONE) {
+ 			ret = os_snprintf(pos, end - pos, "%sNONE",
+ 					  first ? "" : " ");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 			first = 0;
+ 		}
+ 
+ 		return pos - buf;
+ 	}
+ 
+ 	if (os_strcmp(field, "group") == 0) {
+ 		if (res < 0) {
+ 			if (strict)
+ 				return 0;
+ 			ret = os_snprintf(buf, buflen,
+ 					  "CCMP TKIP WEP104 WEP40");
+ 			if (ret < 0 || (size_t) ret >= buflen)
+ 				return -1;
+ 			return ret;
+ 		}
+ 
+ 		if (capa.enc & WPA_DRIVER_CAPA_ENC_CCMP) {
+ 			ret = os_snprintf(pos, end - pos, "%sCCMP",
+ 					  first ? "" : " ");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 			first = 0;
+ 		}
+ 
+ 		if (capa.enc & WPA_DRIVER_CAPA_ENC_TKIP) {
+ 			ret = os_snprintf(pos, end - pos, "%sTKIP",
+ 					  first ? "" : " ");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 			first = 0;
+ 		}
+ 
+ 		if (capa.enc & WPA_DRIVER_CAPA_ENC_WEP104) {
+ 			ret = os_snprintf(pos, end - pos, "%sWEP104",
+ 					  first ? "" : " ");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 			first = 0;
+ 		}
+ 
+ 		if (capa.enc & WPA_DRIVER_CAPA_ENC_WEP40) {
+ 			ret = os_snprintf(pos, end - pos, "%sWEP40",
+ 					  first ? "" : " ");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 			first = 0;
+ 		}
+ 
+ 		return pos - buf;
+ 	}
+ 
+ 	if (os_strcmp(field, "key_mgmt") == 0) {
+ 		if (res < 0) {
+ 			if (strict)
+ 				return 0;
+ 			ret = os_snprintf(buf, buflen, "WPA-PSK WPA-EAP "
+ 					  "IEEE8021X WPA-NONE NONE");
+ 			if (ret < 0 || (size_t) ret >= buflen)
+ 				return -1;
+ 			return ret;
+ 		}
+ 
+ 		ret = os_snprintf(pos, end - pos, "NONE IEEE8021X");
+ 		if (ret < 0 || ret >= end - pos)
+ 			return pos - buf;
+ 		pos += ret;
+ 
+ 		if (capa.key_mgmt & (WPA_DRIVER_CAPA_KEY_MGMT_WPA |
+ 				     WPA_DRIVER_CAPA_KEY_MGMT_WPA2)) {
+ 			ret = os_snprintf(pos, end - pos, " WPA-EAP");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 		}
+ 
+ 		if (capa.key_mgmt & (WPA_DRIVER_CAPA_KEY_MGMT_WPA_PSK |
+ 				     WPA_DRIVER_CAPA_KEY_MGMT_WPA2_PSK)) {
+ 			ret = os_snprintf(pos, end - pos, " WPA-PSK");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 		}
+ 
+ 		if (capa.key_mgmt & WPA_DRIVER_CAPA_KEY_MGMT_WPA_NONE) {
+ 			ret = os_snprintf(pos, end - pos, " WPA-NONE");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 		}
+ 
+ 		return pos - buf;
+ 	}
+ 
+ 	if (os_strcmp(field, "proto") == 0) {
+ 		if (res < 0) {
+ 			if (strict)
+ 				return 0;
+ 			ret = os_snprintf(buf, buflen, "RSN WPA");
+ 			if (ret < 0 || (size_t) ret >= buflen)
+ 				return -1;
+ 			return ret;
+ 		}
+ 
+ 		if (capa.key_mgmt & (WPA_DRIVER_CAPA_KEY_MGMT_WPA2 |
+ 				     WPA_DRIVER_CAPA_KEY_MGMT_WPA2_PSK)) {
+ 			ret = os_snprintf(pos, end - pos, "%sRSN",
+ 					  first ? "" : " ");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 			first = 0;
+ 		}
+ 
+ 		if (capa.key_mgmt & (WPA_DRIVER_CAPA_KEY_MGMT_WPA |
+ 				     WPA_DRIVER_CAPA_KEY_MGMT_WPA_PSK)) {
+ 			ret = os_snprintf(pos, end - pos, "%sWPA",
+ 					  first ? "" : " ");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 			first = 0;
+ 		}
+ 
+ 		return pos - buf;
+ 	}
+ 
+ 	if (os_strcmp(field, "auth_alg") == 0) {
+ 		if (res < 0) {
+ 			if (strict)
+ 				return 0;
+ 			ret = os_snprintf(buf, buflen, "OPEN SHARED LEAP");
+ 			if (ret < 0 || (size_t) ret >= buflen)
+ 				return -1;
+ 			return ret;
+ 		}
+ 
+ 		if (capa.auth & (WPA_DRIVER_AUTH_OPEN)) {
+ 			ret = os_snprintf(pos, end - pos, "%sOPEN",
+ 					  first ? "" : " ");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 			first = 0;
+ 		}
+ 
+ 		if (capa.auth & (WPA_DRIVER_AUTH_SHARED)) {
+ 			ret = os_snprintf(pos, end - pos, "%sSHARED",
+ 					  first ? "" : " ");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 			first = 0;
+ 		}
+ 
+ 		if (capa.auth & (WPA_DRIVER_AUTH_LEAP)) {
+ 			ret = os_snprintf(pos, end - pos, "%sLEAP",
+ 					  first ? "" : " ");
+ 			if (ret < 0 || ret >= end - pos)
+ 				return pos - buf;
+ 			pos += ret;
+ 			first = 0;
+ 		}
+ 
+ 		return pos - buf;
+ 	}
+ 
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE: Unknown GET_CAPABILITY field '%s'",
+ 		   field);
+ 
+ 	return -1;
+ }
+ 
+ 
+ static int wpa_supplicant_ctrl_iface_ap_scan(
+ 	struct wpa_supplicant *wpa_s, char *cmd)
+ {
+ 	int ap_scan = atoi(cmd);
+ 
+ 	if (ap_scan < 0 || ap_scan > 2)
+ 		return -1;
+ 	wpa_s->conf->ap_scan = ap_scan;
+ 	return 0;
+ }
+ 
+ char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
+ 					 char *buf, size_t *resp_len)
+ {
+ 	char *reply;
+ 	const int reply_size = 2048;
+ 	int ctrl_rsp = 0;
+ 	int reply_len;
+ 
+ 	if (os_strncmp(buf, WPA_CTRL_RSP, os_strlen(WPA_CTRL_RSP)) == 0 ||
+ 	    os_strncmp(buf, "SET_NETWORK ", 12) == 0) {
+ 		wpa_hexdump_ascii_key(MSG_DEBUG, "RX ctrl_iface",
+ 				      (const u8 *) buf, os_strlen(buf));
+ 	} else {
+ 		wpa_hexdump_ascii(MSG_DEBUG, "RX ctrl_iface",
+ 				  (const u8 *) buf, os_strlen(buf));
+ 	}
+ 
+ 	reply = os_malloc(reply_size);
+ 	if (reply == NULL) {
+ 		*resp_len = 1;
+ 		return NULL;
+ 	}
+ 
+ 	os_memcpy(reply, "OK\n", 3);
+ 	reply_len = 3;
+ 
+ 	if (os_strcmp(buf, "PING") == 0) {
+ 		os_memcpy(reply, "PONG\n", 5);
+ 		reply_len = 5;
+ 	} else if (os_strcmp(buf, "MIB") == 0) {
+ 		reply_len = wpa_sm_get_mib(wpa_s->wpa, reply, reply_size);
+ 		if (reply_len >= 0) {
+ 			int res;
+ 			res = eapol_sm_get_mib(wpa_s->eapol, reply + reply_len,
+ 					       reply_size - reply_len);
+ 			if (res < 0)
+ 				reply_len = -1;
+ 			else
+ 				reply_len += res;
+ 		}
+ 	} else if (os_strncmp(buf, "STATUS", 6) == 0) {
+ 		reply_len = wpa_supplicant_ctrl_iface_status(
+ 			wpa_s, buf + 6, reply, reply_size);
+ 	} else if (os_strcmp(buf, "PMKSA") == 0) {
+ 		reply_len = pmksa_cache_list(wpa_s->wpa, reply, reply_size);
+ 	} else if (os_strncmp(buf, "SET ", 4) == 0) {
+ 		if (wpa_supplicant_ctrl_iface_set(wpa_s, buf + 4))
+ 			reply_len = -1;
+ 	} else if (os_strcmp(buf, "LOGON") == 0) {
+ 		eapol_sm_notify_logoff(wpa_s->eapol, FALSE);
+ 	} else if (os_strcmp(buf, "LOGOFF") == 0) {
+ 		eapol_sm_notify_logoff(wpa_s->eapol, TRUE);
+ 	} else if (os_strcmp(buf, "REASSOCIATE") == 0) {
+ 		wpa_s->disconnected = 0;
+ 		wpa_s->reassociate = 1;
+ 		wpa_supplicant_req_scan(wpa_s, 0, 0);
+ 	} else if (os_strncmp(buf, "PREAUTH ", 8) == 0) {
+ 		if (wpa_supplicant_ctrl_iface_preauth(wpa_s, buf + 8))
+ 			reply_len = -1;
+ #ifdef CONFIG_PEERKEY
+ 	} else if (os_strncmp(buf, "STKSTART ", 9) == 0) {
+ 		if (wpa_supplicant_ctrl_iface_stkstart(wpa_s, buf + 9))
+ 			reply_len = -1;
+ #endif /* CONFIG_PEERKEY */
+ 	} else if (os_strncmp(buf, WPA_CTRL_RSP, os_strlen(WPA_CTRL_RSP)) == 0)
+ 	{
+ 		if (wpa_supplicant_ctrl_iface_ctrl_rsp(
+ 			    wpa_s, buf + os_strlen(WPA_CTRL_RSP)))
+ 			reply_len = -1;
+ 		else
+ 			ctrl_rsp = 1;
+ 	} else if (os_strcmp(buf, "RECONFIGURE") == 0) {
+ 		if (wpa_supplicant_reload_configuration(wpa_s))
+ 			reply_len = -1;
+ 	} else if (os_strcmp(buf, "TERMINATE") == 0) {
+ 		eloop_terminate();
+ 	} else if (os_strncmp(buf, "BSSID ", 6) == 0) {
+ 		if (wpa_supplicant_ctrl_iface_bssid(wpa_s, buf + 6))
+ 			reply_len = -1;
+ 	} else if (os_strcmp(buf, "LIST_NETWORKS") == 0) {
+ 		reply_len = wpa_supplicant_ctrl_iface_list_networks(
+ 			wpa_s, reply, reply_size);
+ 	} else if (os_strcmp(buf, "DISCONNECT") == 0) {
+ 		wpa_s->disconnected = 1;
+ 		wpa_supplicant_disassociate(wpa_s, REASON_DEAUTH_LEAVING);
+ 	} else if (os_strcmp(buf, "SCAN") == 0) {
+ 		wpa_s->scan_req = 2;
+ 		wpa_supplicant_req_scan(wpa_s, 0, 0);
+ 	} else if (os_strcmp(buf, "SCAN_RESULTS") == 0) {
+ 		reply_len = wpa_supplicant_ctrl_iface_scan_results(
+ 			wpa_s, reply, reply_size);
+ 	} else if (os_strncmp(buf, "SELECT_NETWORK ", 15) == 0) {
+ 		if (wpa_supplicant_ctrl_iface_select_network(wpa_s, buf + 15))
+ 			reply_len = -1;
+ 	} else if (os_strncmp(buf, "ENABLE_NETWORK ", 15) == 0) {
+ 		if (wpa_supplicant_ctrl_iface_enable_network(wpa_s, buf + 15))
+ 			reply_len = -1;
+ 	} else if (os_strncmp(buf, "DISABLE_NETWORK ", 16) == 0) {
+ 		if (wpa_supplicant_ctrl_iface_disable_network(wpa_s, buf + 16))
+ 			reply_len = -1;
+ 	} else if (os_strcmp(buf, "ADD_NETWORK") == 0) {
+ 		reply_len = wpa_supplicant_ctrl_iface_add_network(
+ 			wpa_s, reply, reply_size);
+ 	} else if (os_strncmp(buf, "REMOVE_NETWORK ", 15) == 0) {
+ 		if (wpa_supplicant_ctrl_iface_remove_network(wpa_s, buf + 15))
+ 			reply_len = -1;
+ 	} else if (os_strncmp(buf, "SET_NETWORK ", 12) == 0) {
+ 		if (wpa_supplicant_ctrl_iface_set_network(wpa_s, buf + 12))
+ 			reply_len = -1;
+ 	} else if (os_strncmp(buf, "GET_NETWORK ", 12) == 0) {
+ 		reply_len = wpa_supplicant_ctrl_iface_get_network(
+ 			wpa_s, buf + 12, reply, reply_size);
+ 	} else if (os_strcmp(buf, "SAVE_CONFIG") == 0) {
+ 		if (wpa_supplicant_ctrl_iface_save_config(wpa_s))
+ 			reply_len = -1;
+ 	} else if (os_strncmp(buf, "GET_CAPABILITY ", 15) == 0) {
+ 		reply_len = wpa_supplicant_ctrl_iface_get_capability(
+ 			wpa_s, buf + 15, reply, reply_size);
+ 	} else if (os_strncmp(buf, "AP_SCAN ", 8) == 0) {
+ 		if (wpa_supplicant_ctrl_iface_ap_scan(wpa_s, buf + 8))
+ 			reply_len = -1;
+ 	} else if (os_strcmp(buf, "INTERFACES") == 0) {
+ 		reply_len = wpa_supplicant_global_iface_interfaces(
+ 			wpa_s->global, reply, reply_size);
+ 	} else {
+ 		os_memcpy(reply, "UNKNOWN COMMAND\n", 16);
+ 		reply_len = 16;
+ 	}
+ 
+ 	if (reply_len < 0) {
+ 		os_memcpy(reply, "FAIL\n", 5);
+ 		reply_len = 5;
+ 	}
+ 
+ 	if (ctrl_rsp)
+ 		eapol_sm_notify_ctrl_response(wpa_s->eapol);
+ 
+ 	*resp_len = reply_len;
+ 	return reply;
+ }
+ 
+ 
+ static int wpa_supplicant_global_iface_add(struct wpa_global *global,
+ 					   char *cmd)
+ {
+ 	struct wpa_interface iface;
+ 	char *pos;
+ 
+ 	/*
+ 	 * <ifname>TAB<confname>TAB<driver>TAB<ctrl_interface>TAB<driver_param>
+ 	 * TAB<bridge_ifname>
+ 	 */
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE GLOBAL INTERFACE_ADD '%s'", cmd);
+ 
+ 	os_memset(&iface, 0, sizeof(iface));
+ 
+ 	do {
+ 		iface.ifname = pos = cmd;
+ 		pos = os_strchr(pos, '\t');
+ 		if (pos)
+ 			*pos++ = '\0';
+ 		if (iface.ifname[0] == '\0')
+ 			return -1;
+ 		if (pos == NULL)
+ 			break;
+ 
+ 		iface.confname = pos;
+ 		pos = os_strchr(pos, '\t');
+ 		if (pos)
+ 			*pos++ = '\0';
+ 		if (iface.confname[0] == '\0')
+ 			iface.confname = NULL;
+ 		if (pos == NULL)
+ 			break;
+ 
+ 		iface.driver = pos;
+ 		pos = os_strchr(pos, '\t');
+ 		if (pos)
+ 			*pos++ = '\0';
+ 		if (iface.driver[0] == '\0')
+ 			iface.driver = NULL;
+ 		if (pos == NULL)
+ 			break;
+ 
+ 		iface.ctrl_interface = pos;
+ 		pos = os_strchr(pos, '\t');
+ 		if (pos)
+ 			*pos++ = '\0';
+ 		if (iface.ctrl_interface[0] == '\0')
+ 			iface.ctrl_interface = NULL;
+ 		if (pos == NULL)
+ 			break;
+ 
+ 		iface.driver_param = pos;
+ 		pos = os_strchr(pos, '\t');
+ 		if (pos)
+ 			*pos++ = '\0';
+ 		if (iface.driver_param[0] == '\0')
+ 			iface.driver_param = NULL;
+ 		if (pos == NULL)
+ 			break;
+ 
+ 		iface.bridge_ifname = pos;
+ 		pos = os_strchr(pos, '\t');
+ 		if (pos)
+ 			*pos++ = '\0';
+ 		if (iface.bridge_ifname[0] == '\0')
+ 			iface.bridge_ifname = NULL;
+ 		if (pos == NULL)
+ 			break;
+ 	} while (0);
+ 
+ 	if (wpa_supplicant_get_iface(global, iface.ifname))
+ 		return -1;
+ 
+ 	return wpa_supplicant_add_iface(global, &iface) ? 0 : -1;
+ }
+ 
+ 
+ static int wpa_supplicant_global_iface_remove(struct wpa_global *global,
+ 					      char *cmd)
+ {
+ 	struct wpa_supplicant *wpa_s;
+ 
+ 	wpa_printf(MSG_DEBUG, "CTRL_IFACE GLOBAL INTERFACE_REMOVE '%s'", cmd);
+ 
+ 	wpa_s = wpa_supplicant_get_iface(global, cmd);
+ 	if (wpa_s == NULL)
+ 		return -1;
+ 	return wpa_supplicant_remove_iface(global, wpa_s);
+ }
+ 
+ 
+ static int wpa_supplicant_global_iface_interfaces(struct wpa_global *global,
+ 						  char *buf, int len)
+ {
+ 	int res;
+ 	char *pos, *end;
+ 	struct wpa_supplicant *wpa_s;
+ 
+ 	wpa_s = global->ifaces;
+ 	pos = buf;
+ 	end = buf + len;
+ 
+ 	while (wpa_s) {
+ 		res = os_snprintf(pos, end - pos, "%s\n", wpa_s->ifname);
+ 		if (res < 0 || res >= end - pos) {
+ 			*pos = '\0';
+ 			break;
+ 		}
+ 		pos += res;
+ 		wpa_s = wpa_s->next;
+ 	}
+ 	return pos - buf;
+ }
+ 
+ 
+ char * wpa_supplicant_global_ctrl_iface_process(struct wpa_global *global,
+ 						char *buf, size_t *resp_len)
+ {
+ 	char *reply;
+ 	const int reply_size = 2048;
+ 	int reply_len;
+ 
+ 	wpa_hexdump_ascii(MSG_DEBUG, "RX global ctrl_iface",
+ 			  (const u8 *) buf, os_strlen(buf));
+ 
+ 	reply = os_malloc(reply_size);
+ 	if (reply == NULL) {
+ 		*resp_len = 1;
+ 		return NULL;
+ 	}
+ 
+ 	os_memcpy(reply, "OK\n", 3);
+ 	reply_len = 3;
+ 
+ 	if (os_strcmp(buf, "PING") == 0) {
+ 		os_memcpy(reply, "PONG\n", 5);
+ 		reply_len = 5;
+ 	} else if (os_strncmp(buf, "INTERFACE_ADD ", 14) == 0) {
+ 		if (wpa_supplicant_global_iface_add(global, buf + 14))
+ 			reply_len = -1;
+ 	} else if (os_strncmp(buf, "INTERFACE_REMOVE ", 17) == 0) {
+ 		if (wpa_supplicant_global_iface_remove(global, buf + 17))
+ 			reply_len = -1;
+ 	} else if (os_strcmp(buf, "INTERFACES") == 0) {
+ 		reply_len = wpa_supplicant_global_iface_interfaces(
+ 			global, reply, reply_size);
+ 	} else if (os_strcmp(buf, "TERMINATE") == 0) {
+ 		eloop_terminate();
+ 	} else {
+ 		os_memcpy(reply, "UNKNOWN COMMAND\n", 16);
+ 		reply_len = 16;
+ 	}
+ 
+ 	if (reply_len < 0) {
+ 		os_memcpy(reply, "FAIL\n", 5);
+ 		reply_len = 5;
+ 	}
+ 
+ 	*resp_len = reply_len;
+ 	return reply;
+ }
diff -BNcr wpa_supplicant-0.5.7/dbus_dict_helpers.c wpa_view/wpa_suppl/dbus_dict_helpers.c
*** wpa_supplicant-0.5.7/dbus_dict_helpers.c	Sun Dec 10 06:49:07 2006
--- wpa_view/wpa_suppl/dbus_dict_helpers.c	Wed Jun  9 13:29:49 2010
***************
*** 902,910 ****
  
  error:
  	if (entry) {
! 		wpa_dbus_dict_entry_clear(entry);
! 		entry->type = DBUS_TYPE_INVALID;
! 		entry->array_type = DBUS_TYPE_INVALID;
  	}
  
  	return FALSE;
--- 902,910 ----
  
  error:
  	if (entry) {
! 	wpa_dbus_dict_entry_clear(entry);
! 	entry->type = DBUS_TYPE_INVALID;
! 	entry->array_type = DBUS_TYPE_INVALID;
  	}
  
  	return FALSE;
diff -BNcr wpa_supplicant-0.5.7/doc/.cvsignore wpa_view/wpa_suppl/doc/.cvsignore
*** wpa_supplicant-0.5.7/doc/.cvsignore	Sun Jun 26 06:44:32 2005
--- wpa_view/wpa_suppl/doc/.cvsignore	Thu Jan  1 02:00:00 1970
***************
*** 1,4 ****
- html
- latex
- wpa_supplicant.eps
- wpa_supplicant.png
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/code_structure.doxygen wpa_view/wpa_suppl/doc/code_structure.doxygen
*** wpa_supplicant-0.5.7/doc/code_structure.doxygen	Sun Jun 11 06:50:00 2006
--- wpa_view/wpa_suppl/doc/code_structure.doxygen	Thu Jan  1 02:00:00 1970
***************
*** 1,270 ****
- /**
- \page code_structure Structure of the source code
- 
- [ \ref wpa_supplicant_core "wpa_supplicant core functionality" |
- \ref generic_helper_func "Generic helper functions" |
- \ref crypto_func "Cryptographic functions" |
- \ref configuration "Configuration" |
- \ref ctrl_iface "Control interface" |
- \ref wpa_code "WPA supplicant" |
- \ref eap_peer "EAP peer" |
- \ref eapol_supp "EAPOL supplicant" |
- \ref win_port "Windows port" |
- \ref test_programs "Test programs" ]
- 
- %wpa_supplicant implementation is divided into number of independent
- modules. Core code includes functionality for controlling the network
- selection, association, and configuration. Independent modules include
- WPA code (key handshake, PMKSA caching, pre-authentication), EAPOL
- state machine, and EAP state machine and methods. In addition, there
- are number of separate files for generic helper functions.
- 
- Both WPA and EAPOL/EAP state machines can be used separately in other
- programs than %wpa_supplicant. As an example, the included test
- programs eapol_test and preauth_test are using these modules.
- 
- \ref driver_wrapper "Driver interface API" is defined in driver.h and
- all hardware/driver dependent functionality is implemented in
- driver_*.c.
- 
- 
- \section wpa_supplicant_core wpa_supplicant core functionality
- 
- wpa_supplicant.c
- 	Program initialization, main control loop
- 
- main.c
- 	main() for UNIX-like operating systems and MinGW (Windows); this
- 	uses command line arguments to configure wpa_supplicant
- 
- events.c
- 	Driver event processing; wpa_supplicant_event() and related functions
- 
- wpa_supplicant_i.h
- 	Internal definitions for %wpa_supplicant core; should not be
- 	included into independent modules
- 
- wpa_supplicant.h
- 	Definitions for driver event data and message logging
- 
- 
- \section generic_helper_func Generic helper functions
- 
- %wpa_supplicant uses generic helper functions some of which are shared
- with with hostapd. The following C files are currently used:
- 
- eloop.c and eloop.h
- 	Event loop (select() loop with registerable timeouts, socket read
- 	callbacks, and signal callbacks)
- 
- common.c and common.h
- 	Common helper functions
- 
- defs.h
- 	Definitions shared by multiple files
- 
- l2_packet.h, l2_packet_linux.c, and l2_packet_pcap.c
- 	Layer 2 (link) access wrapper (includes native Linux implementation
- 	and wrappers for libdnet/libpcap). A new l2_packet implementation
- 	may need to be added when porting to new operating systems that are
- 	not supported by libdnet/libpcap. Makefile can be used to select which
- 	l2_packet implementation is included. l2_packet_linux.c uses Linux
- 	packet sockets and l2_packet_pcap.c has a more portable version using
- 	libpcap and libdnet.
- 
- pcsc_funcs.c and pcsc_funcs.h
- 	Wrapper for PC/SC lite SIM and smart card readers
- 
- priv_netlink.h
- 	Private version of netlink definitions from Linux kernel header files;
- 	this could be replaced with C library header file once suitable
- 	version becomes commonly available
- 
- version.h
- 	Version number definitions
- 
- wireless_copy.h
- 	Private version of Linux wireless extensions definitions from kernel
- 	header files; this could be replaced with C library header file once
- 	suitable version becomes commonly available
- 
- 
- \section crypto_func Cryptographic functions
- 
- md5.c and md5.h
- 	MD5 (replaced with a crypto library if TLS support is included)
- 	HMAC-MD5 (keyed checksum for message authenticity validation)
- 
- rc4.c and rc4.h
- 	RC4 (broadcast/default key encryption)
- 
- sha1.c and sha1.h
- 	SHA-1 (replaced with a crypto library if TLS support is included)
- 	HMAC-SHA-1 (keyed checksum for message authenticity validation)
- 	PRF-SHA-1 (pseudorandom (key/nonce generation) function)
- 	PBKDF2-SHA-1 (ASCII passphrase to shared secret)
- 	T-PRF (for EAP-FAST)
- 	TLS-PRF (RFC 2246)
- 
- aes_wrap.c, aes_wrap.h, aes.c
- 	AES (replaced with a crypto library if TLS support is included),
- 	AES Key Wrap Algorithm with 128-bit KEK, RFC3394 (broadcast/default
- 	key encryption),
- 	One-Key CBC MAC (OMAC1) hash with AES-128,
- 	AES-128 CTR mode encryption,
- 	AES-128 EAX mode encryption/decryption,
- 	AES-128 CBC
- 
- crypto.h
- 	Definition of crypto library wrapper
- 
- crypto.c
- 	Wrapper functions for libcrypto (OpenSSL)
- 
- crypto_gnutls.c
- 	Wrapper functions for libgcrypt (used by GnuTLS)
- 
- ms_funcs.c and ms_funcs.h
- 	Helper functions for MSCHAPV2 and LEAP
- 
- tls.h
- 	Definition of TLS library wrapper
- 
- tls_none.c
- 	Dummy implementation of TLS library wrapper for cases where TLS
- 	functionality is not included.
- 
- tls_openssl.c
- 	TLS library wrapper for openssl
- 
- tls_gnutls.c
- 	TLS library wrapper for GnuTLS
- 
- 
- \section configuration Configuration
- 
- config_ssid.h
- 	Definition of per network configuration items
- 
- config.h
- 	Definition of the %wpa_supplicant configuration
- 
- config.c
- 	Configuration parser and common functions
- 
- config_file.c
- 	Configuration backend for text files (e.g., wpa_supplicant.conf)
- 
- 
- \section ctrl_iface Control interface
- 
- %wpa_supplicant has a \ref ctrl_iface_page "control interface"
- that can be used to get status
- information and manage operations from external programs. An example
- command line interface (wpa_cli) and GUI (wpa_gui) for this interface
- are included in the %wpa_supplicant distribution.
- 
- ctrl_iface.c and ctrl_iface.h
- 	%wpa_supplicant-side of the control interface
- 
- wpa_ctrl.c and wpa_ctrl.h
- 	Library functions for external programs to provide access to the
- 	%wpa_supplicant control interface
- 
- wpa_cli.c
- 	Example program for using %wpa_supplicant control interface
- 
- 
- \section wpa_code WPA supplicant
- 
- wpa.c and wpa.h
- 	WPA state machine and 4-Way/Group Key Handshake processing
- 
- preauth.c and preauth.h
- 	PMKSA caching and pre-authentication (RSN/WPA2)
- 
- wpa_i.h
- 	Internal definitions for WPA code; not to be included to other modules.
- 
- \section eap_peer EAP peer
- 
- \ref eap_module "EAP peer implementation" is a separate module that
- can be used by other programs than just %wpa_supplicant.
- 
- eap.c and eap.h
- 	EAP state machine and method interface
- 
- eap_defs.h
- 	Common EAP definitions
- 
- eap_i.h
- 	Internal definitions for EAP state machine and EAP methods; not to be
- 	included in other modules
- 
- eap_sim_common.c and eap_sim_common.h
- 	Common code for EAP-SIM and EAP-AKA
- 
- eap_tls_common.c and eap_tls_common.h
- 	Common code for EAP-PEAP, EAP-TTLS, and EAP-FAST
- 
- eap_tlv.c and eap_tlv.h
- 	EAP-TLV code for EAP-PEAP and EAP-FAST
- 
- eap_ttls.c and eap_ttls.h
- 	EAP-TTLS
- 
- eap_pax.c, eap_pax_common.h, eap_pax_common.c
- 	EAP-PAX
- 
- eap_psk.c, eap_psk_common.h, eap_psk_common.c
- 	EAP-PSK (note: this is not needed for WPA-PSK)
- 
- eap_sake.c, eap_sake_common.h, eap_sake_common.c
- 	EAP-SAKE
- 
- eap_gpsk.c, eap_gpsk_common.h, eap_gpsk_common.c
- 	EAP-GPSK
- 
- eap_aka.c, eap_fast.c, eap_gtc.c, eap_leap.c, eap_md5.c, eap_mschapv2.c,
- eap_otp.c, eap_peap.c, eap_sim.c, eap_tls.c
- 	Other EAP method implementations
- 
- 
- \section eapol_supp EAPOL supplicant
- 
- eapol_sm.c and eapol_sm.h
- 	EAPOL supplicant state machine and IEEE 802.1X processing
- 
- 
- \section win_port Windows port
- 
- ndis_events.cpp
- 	External program for receiving NdisMIndicateStatus() events and
- 	delivering them to %wpa_supplicant in more easier to use form
- 
- win_if_list.c
- 	External program for listing current network interface
- 
- 
- \section test_programs Test programs
- 
- radius_client.c and radius_client.h
- 	RADIUS authentication client implementation for eapol_test
- 
- radius.c and radius.h
- 	RADIUS message processing for eapol_test
- 
- config_types.h and hostapd.h
- 	Minimal version of hostapd header files for eapol_test
- 
- eapol_test.c
- 	Standalone EAP testing tool with integrated RADIUS authentication
- 	client
- 
- preauth_test.c
- 	Standalone RSN pre-authentication tool
- 
- wpa_passphrase.c
- 	WPA ASCII passphrase to PSK conversion
- 
- */
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/ctrl_iface.doxygen wpa_view/wpa_suppl/doc/ctrl_iface.doxygen
*** wpa_supplicant-0.5.7/doc/ctrl_iface.doxygen	Tue Aug 22 05:36:05 2006
--- wpa_view/wpa_suppl/doc/ctrl_iface.doxygen	Thu Jan  1 02:00:00 1970
***************
*** 1,437 ****
- /**
- \page ctrl_iface_page Control interface
- 
- %wpa_supplicant implements a control interface that can be used by
- external programs to control the operations of the %wpa_supplicant
- daemon and to get status information and event notifications. There is
- a small C library, in a form of a single C file, wpa_ctrl.c, that
- provides helper functions to facilitate the use of the control
- interface. External programs can link this file into them and then use
- the library functions documented in wpa_ctrl.h to interact with
- %wpa_supplicant. This library can also be used with C++. wpa_cli.c and
- wpa_gui are example programs using this library.
- 
- There are multiple mechanisms for inter-process communication. For
- example, Linux version of %wpa_supplicant is using UNIX domain sockets
- for the control interface and Windows version UDP sockets. The use of
- the functions defined in wpa_ctrl.h can be used to hide the details of
- the used IPC from external programs.
- 
- 
- \section using_ctrl_iface Using the control interface
- 
- External programs, e.g., a GUI or a configuration utility, that need to
- communicate with %wpa_supplicant should link in wpa_ctrl.c. This
- allows them to use helper functions to open connection to the control
- interface with wpa_ctrl_open() and to send commands with
- wpa_ctrl_request().
- 
- %wpa_supplicant uses the control interface for two types of communication:
- commands and unsolicited event messages. Commands are a pair of
- messages, a request from the external program and a response from
- %wpa_supplicant. These can be executed using wpa_ctrl_request().
- Unsolicited event messages are sent by %wpa_supplicant to the control
- interface connection without specific request from the external program
- for receiving each message. However, the external program needs to
- attach to the control interface with wpa_ctrl_attach() to receive these
- unsolicited messages.
- 
- If the control interface connection is used both for commands and
- unsolicited event messages, there is potential for receiving an
- unsolicited message between the command request and response.
- wpa_ctrl_request() caller will need to supply a callback, msg_cb,
- for processing these messages. Often it is easier to open two
- control interface connections by calling wpa_ctrl_open() twice and
- then use one of the connections for commands and the other one for
- unsolicited messages. This way command request/response pairs will
- not be broken by unsolicited messages. wpa_cli is an example of how
- to use only one connection for both purposes and wpa_gui demonstrates
- how to use two separate connections.
- 
- Once the control interface connection is not needed anymore, it should
- be closed by calling wpa_ctrl_close(). If the connection was used for
- unsolicited event messages, it should be first detached by calling
- wpa_ctrl_detach().
- 
- 
- \section ctrl_iface_cmds Control interface commands
- 
- Following commands can be used with wpa_ctrl_request():
- 
- \subsection ctrl_iface_PING PING
- 
- This command can be used to test whether %wpa_supplicant is replying
- to the control interface commands. The expected reply is \c PONG if the
- connection is open and %wpa_supplicant is processing commands.
- 
- 
- \subsection ctrl_iface_MIB MIB
- 
- Request a list of MIB variables (dot1x, dot11). The output is a text
- block with each line in \c variable=value format. For example:
- 
- \verbatim
- dot11RSNAOptionImplemented=TRUE
- dot11RSNAPreauthenticationImplemented=TRUE
- dot11RSNAEnabled=FALSE
- dot11RSNAPreauthenticationEnabled=FALSE
- dot11RSNAConfigVersion=1
- dot11RSNAConfigPairwiseKeysSupported=5
- dot11RSNAConfigGroupCipherSize=128
- dot11RSNAConfigPMKLifetime=43200
- dot11RSNAConfigPMKReauthThreshold=70
- dot11RSNAConfigNumberOfPTKSAReplayCounters=1
- dot11RSNAConfigSATimeout=60
- dot11RSNAAuthenticationSuiteSelected=00-50-f2-2
- dot11RSNAPairwiseCipherSelected=00-50-f2-4
- dot11RSNAGroupCipherSelected=00-50-f2-4
- dot11RSNAPMKIDUsed=
- dot11RSNAAuthenticationSuiteRequested=00-50-f2-2
- dot11RSNAPairwiseCipherRequested=00-50-f2-4
- dot11RSNAGroupCipherRequested=00-50-f2-4
- dot11RSNAConfigNumberOfGTKSAReplayCounters=0
- dot11RSNA4WayHandshakeFailures=0
- dot1xSuppPaeState=5
- dot1xSuppHeldPeriod=60
- dot1xSuppAuthPeriod=30
- dot1xSuppStartPeriod=30
- dot1xSuppMaxStart=3
- dot1xSuppSuppControlledPortStatus=Authorized
- dot1xSuppBackendPaeState=2
- dot1xSuppEapolFramesRx=0
- dot1xSuppEapolFramesTx=440
- dot1xSuppEapolStartFramesTx=2
- dot1xSuppEapolLogoffFramesTx=0
- dot1xSuppEapolRespFramesTx=0
- dot1xSuppEapolReqIdFramesRx=0
- dot1xSuppEapolReqFramesRx=0
- dot1xSuppInvalidEapolFramesRx=0
- dot1xSuppEapLengthErrorFramesRx=0
- dot1xSuppLastEapolFrameVersion=0
- dot1xSuppLastEapolFrameSource=00:00:00:00:00:00
- \endverbatim
- 
- 
- \subsection ctrl_iface_STATUS STATUS
- 
- Request current WPA/EAPOL/EAP status information. The output is a text
- block with each line in \c variable=value format. For example:
- 
- \verbatim
- bssid=02:00:01:02:03:04
- ssid=test network
- pairwise_cipher=CCMP
- group_cipher=CCMP
- key_mgmt=WPA-PSK
- wpa_state=COMPLETED
- ip_address=192.168.1.21
- Supplicant PAE state=AUTHENTICATED
- suppPortStatus=Authorized
- EAP state=SUCCESS
- \endverbatim
- 
- 
- \subsection ctrl_iface_STATUS-VERBOSE STATUS-VERBOSE
- 
- Same as STATUS, but with more verbosity (i.e., more \c variable=value pairs).
- 
- \verbatim
- bssid=02:00:01:02:03:04
- ssid=test network
- id=0
- pairwise_cipher=CCMP
- group_cipher=CCMP
- key_mgmt=WPA-PSK
- wpa_state=COMPLETED
- ip_address=192.168.1.21
- Supplicant PAE state=AUTHENTICATED
- suppPortStatus=Authorized
- heldPeriod=60
- authPeriod=30
- startPeriod=30
- maxStart=3
- portControl=Auto
- Supplicant Backend state=IDLE
- EAP state=SUCCESS
- reqMethod=0
- methodState=NONE
- decision=COND_SUCC
- ClientTimeout=60
- \endverbatim
- 
- 
- \subsection ctrl_iface_PMKSA PMKSA
- 
- Show PMKSA cache
- 
- \verbatim
- Index / AA / PMKID / expiration (in seconds) / opportunistic
- 1 / 02:00:01:02:03:04 / 000102030405060708090a0b0c0d0e0f / 41362 / 0
- 2 / 02:00:01:33:55:77 / 928389281928383b34afb34ba4212345 / 362 / 1
- \endverbatim
- 
- 
- \subsection ctrl_iface_SET SET <variable> <value>
- 
- Set variables:
- - EAPOL::heldPeriod
- - EAPOL::authPeriod
- - EAPOL::startPeriod
- - EAPOL::maxStart
- - dot11RSNAConfigPMKLifetime
- - dot11RSNAConfigPMKReauthThreshold
- - dot11RSNAConfigSATimeout
- 
- Example command:
- \verbatim
- SET EAPOL::heldPeriod 45
- \endverbatim
- 
- 
- \subsection ctrl_iface_LOGON LOGON
- 
- IEEE 802.1X EAPOL state machine logon.
- 
- 
- \subsection ctrl_iface_LOGOFF LOGOFF
- 
- IEEE 802.1X EAPOL state machine logoff.
- 
- 
- \subsection ctrl_iface_REASSOCIATE REASSOCIATE
- 
- Force reassociation.
- 
- 
- \subsection ctrl_iface_PREAUTH PREAUTH <BSSID>
- 
- Start pre-authentication with the given BSSID.
- 
- 
- \subsection ctrl_iface_ATTACH ATTACH
- 
- Attach the connection as a monitor for unsolicited events. This can
- be done with wpa_ctrl_attach().
- 
- 
- \subsection ctrl_iface_DETACH DETACH
- 
- Detach the connection as a monitor for unsolicited events. This can
- be done with wpa_ctrl_detach().
- 
- 
- \subsection ctrl_iface_LEVEL LEVEL <debug level>
- 
- Change debug level.
- 
- 
- \subsection ctrl_iface_RECONFIGURE RECONFIGURE
- 
- Force %wpa_supplicant to re-read its configuration data.
- 
- 
- \subsection ctrl_iface_TERMINATE TERMINATE
- 
- Terminate %wpa_supplicant process.
- 
- 
- \subsection ctrl_iface_BSSID BSSID <network id> <BSSID>
- 
- Set preferred BSSID for a network. Network id can be received from the
- \c LIST_NETWORKS command output.
- 
- 
- \subsection ctrl_iface_LIST_NETWORKS LIST_NETWORKS
- 
- List configured networks.
- 
- \verbatim
- network id / ssid / bssid / flags
- 0	example network	any	[CURRENT]
- \endverbatim
- 
- (note: fields are separated with tabs)
- 
- 
- \subsection ctrl_iface_DISCONNECT DISCONNECT
- 
- Disconnect and wait for \c REASSOCIATE command before connecting.
- 
- 
- \subsection ctrl_iface_SCAN SCAN
- 
- Request a new BSS scan.
- 
- 
- \subsection ctrl_iface_SCAN_RESULTS SCAN_RESULTS
- 
- Get the latest scan results.
- 
- \verbatim
- bssid / frequency / signal level / flags / ssid
- 00:09:5b:95:e0:4e	2412	208	[WPA-PSK-CCMP]	jkm private
- 02:55:24:33:77:a3	2462	187	[WPA-PSK-TKIP]	testing
- 00:09:5b:95:e0:4f	2412	209		jkm guest
- \endverbatim
- 
- (note: fields are separated with tabs)
- 
- 
- \subsection ctrl_iface_SELECT_NETWORK SELECT_NETWORK <network id>
- 
- Select a network (disable others). Network id can be received from the
- \c LIST_NETWORKS command output.
- 
- 
- \subsection ctrl_iface_ENABLE_NETWORK ENABLE_NETWORK <network id>
- 
- Enable a network. Network id can be received from the
- \c LIST_NETWORKS command output.
- 
- 
- \subsection ctrl_iface_DISABLE_NETWORK DISABLE_NETWORK <network id>
- 
- Disable a network. Network id can be received from the
- \c LIST_NETWORKS command output.
- 
- 
- \subsection ctrl_iface_ADD_NETWORK ADD_NETWORK
- 
- Add a new network. This command creates a new network with empty
- configuration. The new network is disabled and once it has been
- configured it can be enabled with \c ENABLE_NETWORK command. \c ADD_NETWORK
- returns the network id of the new network or FAIL on failure.
- 
- 
- \subsection ctrl_iface_REMOVE_NETWORK REMOVE_NETWORK <network id>
- 
- Remove a network. Network id can be received from the
- \c LIST_NETWORKS command output.
- 
- 
- \subsection ctrl_iface_SET_NETWORK SET_NETWORK <network id> <variable> <value>
- 
- Set network variables. Network id can be received from the
- \c LIST_NETWORKS command output.
- 
- This command uses the same variables and data formats as the
- configuration file. See example wpa_supplicant.conf for more details.
- 
- - ssid (network name, SSID)
- - psk (WPA passphrase or pre-shared key)
- - key_mgmt (key management protocol)
- - identity (EAP identity)
- - password (EAP password)
- - ...
- 
- 
- \subsection ctrl_iface_GET_NETWORK GET_NETWORK <network id> <variable>
- 
- Get network variables. Network id can be received from the
- \c LIST_NETWORKS command output.
- 
- 
- \subsection ctrl_iface_SAVE_CONFIG SAVE_CONFIG
- 
- Save the current configuration.
- 
- 
- \section ctrl_iface_interactive Interactive requests
- 
- If %wpa_supplicant needs additional information during authentication
- (e.g., password), it will use a specific prefix, \c CTRL-REQ-
- (\a WPA_CTRL_REQ macro) in an unsolicited event message. An external
- program, e.g., a GUI, can provide such information by using
- \c CTRL-RSP- (\a WPA_CTRL_RSP macro) prefix in a command with matching
- field name.
- 
- The following fields can be requested in this way from the user:
- - IDENTITY (EAP identity/user name)
- - PASSWORD (EAP password)
- - NEW_PASSWORD (New password if the server is requesting password change)
- - PIN (PIN code for accessing a SIM or smartcard)
- - OTP (one-time password; like password, but the value is used only once)
- - PASSPHRASE (passphrase for a private key file)
- 
- \verbatim
- CTRL-REQ-<field name>-<network id>-<human readable text>
- CTRL-RSP-<field name>-<network id>-<value>
- \endverbatim
- 
- For example, request from %wpa_supplicant:
- \verbatim
- CTRL-REQ-PASSWORD-1-Password needed for SSID test-network
- \endverbatim
- 
- And a matching reply from the GUI:
- \verbatim
- CTRL-RSP-PASSWORD-1-secret
- \endverbatim
- 
- 
- \subsection ctrl_iface_GET_CAPABILITY GET_CAPABILITY <option> [strict]
- 
- Get list of supported functionality (eap, pairwise, group,
- proto). Supported functionality is shown as space separate lists of
- values used in the same format as in %wpa_supplicant configuration.
- If optional argument, 'strict', is added, only the values that the
- driver claims to explicitly support are included. Without this, all
- available capabilities are included if the driver does not provide
- a mechanism for querying capabilities.
- 
- Example request/reply pairs:
- 
- \verbatim
- GET_CAPABILITY eap
- AKA FAST GTC LEAP MD5 MSCHAPV2 OTP PAX PEAP PSK SIM TLS TTLS
- \endverbatim
- 
- \verbatim
- GET_CAPABILITY pairwise
- CCMP TKIP NONE
- \endverbatim
- 
- \verbatim
- GET_CAPABILITY pairwise strict
- \endverbatim
- 
- \verbatim
- GET_CAPABILITY group
- CCMP TKIP WEP104 WEP40
- \endverbatim
- 
- \verbatim
- GET_CAPABILITY key_mgmt
- WPA-PSK WPA-EAP IEEE8021X NONE
- \endverbatim
- 
- \verbatim
- GET_CAPABILITY proto
- RSN WPA
- \endverbatim
- 
- \verbatim
- GET_CAPABILITY auth_alg
- OPEN SHARED LEAP
- \endverbatim
- 
- 
- \subsection ctrl_iface_AP_SCAN AP_SCAN <ap_scan value>
- 
- Change ap_scan value:
- 0 = no scanning,
- 1 = %wpa_supplicant requests scans and uses scan results to select the AP,
- 2 = %wpa_supplicant does not use scanning and just requests driver to
- associate and take care of AP selection
- 
- 
- \subsection ctrl_iface_INTERFACES INTERFACES
- 
- List configured interfaces.
- 
- \verbatim
- wlan0
- eth0
- \endverbatim
- 
- */
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/docbook/.cvsignore wpa_view/wpa_suppl/doc/docbook/.cvsignore
*** wpa_supplicant-0.5.7/doc/docbook/.cvsignore	Mon Sep 26 04:23:43 2005
--- wpa_view/wpa_suppl/doc/docbook/.cvsignore	Thu Jan  1 02:00:00 1970
***************
*** 1,6 ****
- manpage.links
- manpage.refs
- *.8
- *.5
- *.html
- *.pdf
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/docbook/Makefile wpa_view/wpa_suppl/doc/docbook/Makefile
*** wpa_supplicant-0.5.7/doc/docbook/Makefile	Sat Aug 27 07:44:07 2005
--- wpa_view/wpa_suppl/doc/docbook/Makefile	Thu Jan  1 02:00:00 1970
***************
*** 1,25 ****
- all: man html pdf
- 
- FILES += wpa_background
- FILES += wpa_cli
- FILES += wpa_passphrase
- FILES += wpa_supplicant.conf
- FILES += wpa_supplicant
- 
- man:
- 	for i in $(FILES); do docbook2man $$i.sgml; done
- 
- html:
- 	for i in $(FILES); do docbook2html $$i.sgml && \
- 		mv index.html $$i.html; done
- 
- pdf:
- 	for i in $(FILES); do docbook2pdf $$i.sgml; done
- 
- 
- clean:
- 	rm -f wpa_background.8 wpa_cli.8 wpa_passphrase.8 wpa_supplicant.8
- 	rm -f wpa_supplicant.conf.5
- 	rm -f manpage.links manpage.refs
- 	rm -f $(FILES:%=%.pdf)
- 	rm -f $(FILES:%=%.html)
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/docbook/wpa_background.8 wpa_view/wpa_suppl/doc/docbook/wpa_background.8
*** wpa_supplicant-0.5.7/doc/docbook/wpa_background.8	Sun Dec 31 23:41:44 2006
--- wpa_view/wpa_suppl/doc/docbook/wpa_background.8	Thu Jan  1 02:00:00 1970
***************
*** 1,84 ****
- .\" This manpage has been automatically generated by docbook2man 
- .\" from a DocBook document.  This tool can be found at:
- .\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
- .\" Please send any bug reports, improvements, comments, patches, 
- .\" etc. to Steve Cheng <steve@ggi-project.org>.
- .TH "WPA_BACKGROUND" "8" "31 December 2006" "" ""
- 
- .SH NAME
- wpa_background \- Background information on Wi-Fi Protected Access and IEEE 802.11i
- .SH "WPA"
- .PP
- The original security mechanism of IEEE 802.11 standard was
- not designed to be strong and has proven to be insufficient for
- most networks that require some kind of security. Task group I
- (Security) of IEEE 802.11 working group
- (http://www.ieee802.org/11/) has worked to address the flaws of
- the base standard and has in practice completed its work in May
- 2004. The IEEE 802.11i amendment to the IEEE 802.11 standard was
- approved in June 2004 and published in July 2004.
- .PP
- Wi-Fi Alliance (http://www.wi-fi.org/) used a draft version
- of the IEEE 802.11i work (draft 3.0) to define a subset of the
- security enhancements that can be implemented with existing wlan
- hardware. This is called Wi-Fi Protected Access<TM> (WPA). This
- has now become a mandatory component of interoperability testing
- and certification done by Wi-Fi Alliance. Wi-Fi provides
- information about WPA at its web site
- (http://www.wi-fi.org/OpenSection/protected_access.asp).
- .PP
- IEEE 802.11 standard defined wired equivalent privacy (WEP)
- algorithm for protecting wireless networks. WEP uses RC4 with
- 40-bit keys, 24-bit initialization vector (IV), and CRC32 to
- protect against packet forgery. All these choices have proven to
- be insufficient: key space is too small against current attacks,
- RC4 key scheduling is insufficient (beginning of the pseudorandom
- stream should be skipped), IV space is too small and IV reuse
- makes attacks easier, there is no replay protection, and non-keyed
- authentication does not protect against bit flipping packet
- data.
- .PP
- WPA is an intermediate solution for the security issues. It
- uses Temporal Key Integrity Protocol (TKIP) to replace WEP. TKIP
- is a compromise on strong security and possibility to use existing
- hardware. It still uses RC4 for the encryption like WEP, but with
- per-packet RC4 keys. In addition, it implements replay protection,
- keyed packet authentication mechanism (Michael MIC).
- .PP
- Keys can be managed using two different mechanisms. WPA can
- either use an external authentication server (e.g., RADIUS) and
- EAP just like IEEE 802.1X is using or pre-shared keys without need
- for additional servers. Wi-Fi calls these "WPA-Enterprise" and
- "WPA-Personal", respectively. Both mechanisms will generate a
- master session key for the Authenticator (AP) and Supplicant
- (client station).
- .PP
- WPA implements a new key handshake (4-Way Handshake and
- Group Key Handshake) for generating and exchanging data encryption
- keys between the Authenticator and Supplicant. This handshake is
- also used to verify that both Authenticator and Supplicant know
- the master session key. These handshakes are identical regardless
- of the selected key management mechanism (only the method for
- generating master session key changes).
- .SH "IEEE 802.11I / WPA2"
- .PP
- The design for parts of IEEE 802.11i that were not included
- in WPA has finished (May 2004) and this amendment to IEEE 802.11
- was approved in June 2004. Wi-Fi Alliance is using the final IEEE
- 802.11i as a new version of WPA called WPA2. This includes, e.g.,
- support for more robust encryption algorithm (CCMP: AES in Counter
- mode with CBC-MAC) to replace TKIP and optimizations for handoff
- (reduced number of messages in initial key handshake,
- pre-authentication, and PMKSA caching).
- .SH "SEE ALSO"
- .PP
- \fBwpa_supplicant\fR(8)
- .SH "LEGAL"
- .PP
- wpa_supplicant is copyright (c) 2003-2005,
- Jouni Malinen <jkmaline@cc.hut.fi> and
- contributors.
- All Rights Reserved.
- .PP
- This program is dual-licensed under both the GPL version 2
- and BSD license. Either license may be used at your option.
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/docbook/wpa_background.sgml wpa_view/wpa_suppl/doc/docbook/wpa_background.sgml
*** wpa_supplicant-0.5.7/doc/docbook/wpa_background.sgml	Sat Aug 27 08:02:15 2005
--- wpa_view/wpa_suppl/doc/docbook/wpa_background.sgml	Thu Jan  1 02:00:00 1970
***************
*** 1,101 ****
- <!doctype refentry PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
- 
- <refentry>
-   <refmeta>
-     <refentrytitle>wpa_background</refentrytitle>
-     <manvolnum>8</manvolnum>
-   </refmeta>
-   <refnamediv>
-     <refname>wpa_background</refname>
-     <refpurpose>Background information on Wi-Fi Protected Access and IEEE 802.11i</refpurpose>
-   </refnamediv>
-   <refsect1>
-     <title>WPA</title>
- 
-     <para>The original security mechanism of IEEE 802.11 standard was
-     not designed to be strong and has proven to be insufficient for
-     most networks that require some kind of security. Task group I
-     (Security) of IEEE 802.11 working group
-     (http://www.ieee802.org/11/) has worked to address the flaws of
-     the base standard and has in practice completed its work in May
-     2004. The IEEE 802.11i amendment to the IEEE 802.11 standard was
-     approved in June 2004 and published in July 2004.</para>
- 
-     <para>Wi-Fi Alliance (http://www.wi-fi.org/) used a draft version
-     of the IEEE 802.11i work (draft 3.0) to define a subset of the
-     security enhancements that can be implemented with existing wlan
-     hardware. This is called Wi-Fi Protected Access&lt;TM&gt; (WPA). This
-     has now become a mandatory component of interoperability testing
-     and certification done by Wi-Fi Alliance. Wi-Fi provides
-     information about WPA at its web site
-     (http://www.wi-fi.org/OpenSection/protected_access.asp).</para>
- 
-     <para>IEEE 802.11 standard defined wired equivalent privacy (WEP)
-     algorithm for protecting wireless networks. WEP uses RC4 with
-     40-bit keys, 24-bit initialization vector (IV), and CRC32 to
-     protect against packet forgery. All these choices have proven to
-     be insufficient: key space is too small against current attacks,
-     RC4 key scheduling is insufficient (beginning of the pseudorandom
-     stream should be skipped), IV space is too small and IV reuse
-     makes attacks easier, there is no replay protection, and non-keyed
-     authentication does not protect against bit flipping packet
-     data.</para>
- 
-     <para>WPA is an intermediate solution for the security issues. It
-     uses Temporal Key Integrity Protocol (TKIP) to replace WEP. TKIP
-     is a compromise on strong security and possibility to use existing
-     hardware. It still uses RC4 for the encryption like WEP, but with
-     per-packet RC4 keys. In addition, it implements replay protection,
-     keyed packet authentication mechanism (Michael MIC).</para>
- 
-     <para>Keys can be managed using two different mechanisms. WPA can
-     either use an external authentication server (e.g., RADIUS) and
-     EAP just like IEEE 802.1X is using or pre-shared keys without need
-     for additional servers. Wi-Fi calls these "WPA-Enterprise" and
-     "WPA-Personal", respectively. Both mechanisms will generate a
-     master session key for the Authenticator (AP) and Supplicant
-     (client station).</para>
- 
-     <para>WPA implements a new key handshake (4-Way Handshake and
-     Group Key Handshake) for generating and exchanging data encryption
-     keys between the Authenticator and Supplicant. This handshake is
-     also used to verify that both Authenticator and Supplicant know
-     the master session key. These handshakes are identical regardless
-     of the selected key management mechanism (only the method for
-     generating master session key changes).</para>
-   </refsect1>
- 
-   <refsect1>
-     <title>IEEE 802.11i / WPA2</title>
- 
-     <para>The design for parts of IEEE 802.11i that were not included
-     in WPA has finished (May 2004) and this amendment to IEEE 802.11
-     was approved in June 2004. Wi-Fi Alliance is using the final IEEE
-     802.11i as a new version of WPA called WPA2. This includes, e.g.,
-     support for more robust encryption algorithm (CCMP: AES in Counter
-     mode with CBC-MAC) to replace TKIP and optimizations for handoff
-     (reduced number of messages in initial key handshake,
-     pre-authentication, and PMKSA caching).</para>
-   </refsect1>
- 
-   <refsect1>
-     <title>See Also</title>
-     <para>
-       <citerefentry>
- 	<refentrytitle>wpa_supplicant</refentrytitle>
- 	<manvolnum>8</manvolnum>
-       </citerefentry>
-     </para>
-   </refsect1>
- 
-   <refsect1>
-     <title>Legal</title>
-     <para>wpa_supplicant is copyright (c) 2003-2005,
-     Jouni Malinen <email>jkmaline@cc.hut.fi</email> and
-     contributors.
-     All Rights Reserved.</para>
- 
-     <para>This program is dual-licensed under both the GPL version 2
-     and BSD license. Either license may be used at your option.</para>
-   </refsect1>
- </refentry>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/docbook/wpa_cli.8 wpa_view/wpa_suppl/doc/docbook/wpa_cli.8
*** wpa_supplicant-0.5.7/doc/docbook/wpa_cli.8	Sun Dec 31 23:41:45 2006
--- wpa_view/wpa_suppl/doc/docbook/wpa_cli.8	Thu Jan  1 02:00:00 1970
***************
*** 1,209 ****
- .\" This manpage has been automatically generated by docbook2man 
- .\" from a DocBook document.  This tool can be found at:
- .\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
- .\" Please send any bug reports, improvements, comments, patches, 
- .\" etc. to Steve Cheng <steve@ggi-project.org>.
- .TH "WPA_CLI" "8" "31 December 2006" "" ""
- 
- .SH NAME
- wpa_cli \- WPA command line client
- .SH SYNOPSIS
- 
- \fBwpa_cli\fR [ \fB-p \fIpath to ctrl sockets\fB\fR ] [ \fB-i \fIifname\fB\fR ] [ \fB-hvB\fR ] [ \fB-a \fIaction file\fB\fR ] [ \fB-P \fIpid file\fB\fR ] [ \fB\fIcommand ...\fB\fR ]
- 
- .SH "OVERVIEW"
- .PP
- wpa_cli is a text-based frontend program for interacting
- with wpa_supplicant. It is used to query current status, change
- configuration, trigger events, and request interactive user
- input.
- .PP
- wpa_cli can show the current authentication status, selected
- security mode, dot11 and dot1x MIBs, etc. In addition, it can
- configure some variables like EAPOL state machine parameters and
- trigger events like reassociation and IEEE 802.1X
- logoff/logon. wpa_cli provides a user interface to request
- authentication information, like username and password, if these
- are not included in the configuration. This can be used to
- implement, e.g., one-time-passwords or generic token card
- authentication where the authentication is based on a
- challenge-response that uses an external device for generating the
- response.
- .PP
- The control interface of wpa_supplicant can be configured to
- allow non-root user access (ctrl_interface_group in the
- configuration file). This makes it possible to run wpa_cli with a
- normal user account.
- .PP
- wpa_cli supports two modes: interactive and command
- line. Both modes share the same command set and the main
- difference is in interactive mode providing access to unsolicited
- messages (event messages, username/password requests).
- .PP
- Interactive mode is started when wpa_cli is executed without
- including the command as a command line parameter. Commands are
- then entered on the wpa_cli prompt. In command line mode, the same
- commands are entered as command line arguments for wpa_cli.
- .SH "INTERACTIVE AUTHENTICATION PARAMETERS REQUEST"
- .PP
- When wpa_supplicant need authentication parameters, like
- username and password, which are not present in the configuration
- file, it sends a request message to all attached frontend programs,
- e.g., wpa_cli in interactive mode. wpa_cli shows these requests
- with "CTRL-REQ-<type>-<id>:<text>"
- prefix. <type> is IDENTITY, PASSWORD, or OTP
- (one-time-password). <id> is a unique identifier for the
- current network. <text> is description of the request. In
- case of OTP request, it includes the challenge from the
- authentication server.
- .PP
- The reply to these requests can be given with 'identity',
- 'password', and 'otp' commands. <id> needs to be copied from the
- the matching request. 'password' and 'otp' commands can be used
- regardless of whether the request was for PASSWORD or OTP. The
- main difference between these two commands is that values given
- with 'password' are remembered as long as wpa_supplicant is
- running whereas values given with 'otp' are used only once and
- then forgotten, i.e., wpa_supplicant will ask frontend for a new
- value for every use. This can be used to implement
- one-time-password lists and generic token card -based
- authentication.
- .PP
- Example request for password and a matching reply:
- .sp
- .RS
- 
- .nf
- CTRL-REQ-PASSWORD-1:Password needed for SSID foobar
- > password 1 mysecretpassword
- .fi
- .RE
- .PP
- Example request for generic token card challenge-response:
- .sp
- .RS
- 
- .nf
- CTRL-REQ-OTP-2:Challenge 1235663 needed for SSID foobar
- > otp 2 9876
- .fi
- .RE
- .SH "COMMAND ARGUMENTS"
- .TP
- \fB-p path\fR
- Change the path where control sockets should
- be found.
- .TP
- \fB-i ifname\fR
- Specify the interface that is being
- configured.  By default, choose the first interface found with
- a control socket in the socket path.
- .TP
- \fB-h\fR
- Help.  Show a usage message.
- .TP
- \fB-v\fR
- Show version information.
- .TP
- \fB-B\fR
- Run as a daemon in the background.
- .TP
- \fB-a file\fR
- Run in daemon mode executing the action file
- based on events from wpa_supplicant.  The specified file will
- be executed with the first argument set to interface name and
- second to "CONNECT" or "DISCONNECT" depending on the event.
- This can be used to execute networking tools required to configure
- the interface.
- 
- Additionally, three environmental variables are available to
- the file: WPA_CTRL_DIR, WPA_ID, and WPA_ID_STR. WPA_CTRL_DIR
- contains the absolute path to the ctrl_interface socket. WPA_ID
- contains the unique network_id identifier assigned to the active
- network, and WPA_ID_STR contains the content of the id_str option.
- .TP
- \fB-P file\fR
- Set the location of the PID
- file.
- .TP
- \fBcommand\fR
- Run a command.  The available commands are
- listed in the next section.
- .SH "COMMANDS"
- .PP
- The following commands are available:
- .TP
- \fBstatus\fR
- get current WPA/EAPOL/EAP status
- .TP
- \fBmib\fR
- get MIB variables (dot1x, dot11)
- .TP
- \fBhelp\fR
- show this usage help
- .TP
- \fBinterface [ifname]\fR
- show interfaces/select interface
- .TP
- \fBlevel <debug level>\fR
- change debug level
- .TP
- \fBlicense\fR
- show full wpa_cli license
- .TP
- \fBlogoff\fR
- IEEE 802.1X EAPOL state machine logoff
- .TP
- \fBlogon\fR
- IEEE 802.1X EAPOL state machine logon
- .TP
- \fBset\fR
- set variables (shows list of variables when run without arguments)
- .TP
- \fBpmksa\fR
- show PMKSA cache
- .TP
- \fBreassociate\fR
- force reassociation
- .TP
- \fBreconfigure\fR
- force wpa_supplicant to re-read its configuration file
- .TP
- \fBpreauthenticate <BSSID>\fR
- force preauthentication
- .TP
- \fBidentity <network id> <identity>\fR
- configure identity for an SSID
- .TP
- \fBpassword <network id> <password>\fR
- configure password for an SSID
- .TP
- \fBpin <network id> <pin>\fR
- configure pin for an SSID
- .TP
- \fBotp <network id> <password>\fR
- configure one-time-password for an SSID
- .TP
- \fBbssid <network id> <BSSID>\fR
- set preferred BSSID for an SSID
- .TP
- \fBlist_networks\fR
- list configured networks
- .TP
- \fBterminate\fR
- terminate \fBwpa_supplicant\fR
- .TP
- \fBquit\fR
- exit wpa_cli
- .SH "SEE ALSO"
- .PP
- \fBwpa_supplicant\fR(8)
- .SH "LEGAL"
- .PP
- wpa_supplicant is copyright (c) 2003-2005,
- Jouni Malinen <jkmaline@cc.hut.fi> and
- contributors.
- All Rights Reserved.
- .PP
- This program is dual-licensed under both the GPL version 2
- and BSD license. Either license may be used at your option.
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/docbook/wpa_cli.sgml wpa_view/wpa_suppl/doc/docbook/wpa_cli.sgml
*** wpa_supplicant-0.5.7/doc/docbook/wpa_cli.sgml	Mon Jun 19 04:54:19 2006
--- wpa_view/wpa_suppl/doc/docbook/wpa_cli.sgml	Thu Jan  1 02:00:00 1970
***************
*** 1,338 ****
- <!doctype refentry PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
- 
- <refentry>
-   <refmeta>
-     <refentrytitle>wpa_cli</refentrytitle>
-     <manvolnum>8</manvolnum>
-   </refmeta>
-   <refnamediv>
-     <refname>wpa_cli</refname>
- 
-     <refpurpose>WPA command line client</refpurpose>
-   </refnamediv>
- 
-   <refsynopsisdiv>
-     <cmdsynopsis>
-       <command>wpa_cli</command>
-       <arg>-p <replaceable>path to ctrl sockets</replaceable></arg>
-       <arg>-i <replaceable>ifname</replaceable></arg>
-       <arg>-hvB</arg>
-       <arg>-a <replaceable>action file</replaceable></arg>
-       <arg>-P <replaceable>pid file</replaceable></arg>
-       <arg><replaceable>command ...</replaceable></arg>
-     </cmdsynopsis>
-   </refsynopsisdiv>
- 
-   <refsect1>
-     <title>Overview</title>
- 
-     <para>wpa_cli is a text-based frontend program for interacting
-     with wpa_supplicant. It is used to query current status, change
-     configuration, trigger events, and request interactive user
-     input.</para>
- 
-     <para>wpa_cli can show the current authentication status, selected
-     security mode, dot11 and dot1x MIBs, etc. In addition, it can
-     configure some variables like EAPOL state machine parameters and
-     trigger events like reassociation and IEEE 802.1X
-     logoff/logon. wpa_cli provides a user interface to request
-     authentication information, like username and password, if these
-     are not included in the configuration. This can be used to
-     implement, e.g., one-time-passwords or generic token card
-     authentication where the authentication is based on a
-     challenge-response that uses an external device for generating the
-     response.</para>
- 
-     <para>The control interface of wpa_supplicant can be configured to
-     allow non-root user access (ctrl_interface_group in the
-     configuration file). This makes it possible to run wpa_cli with a
-     normal user account.</para>
- 
-     <para>wpa_cli supports two modes: interactive and command
-     line. Both modes share the same command set and the main
-     difference is in interactive mode providing access to unsolicited
-     messages (event messages, username/password requests).</para>
- 
-     <para>Interactive mode is started when wpa_cli is executed without
-     including the command as a command line parameter. Commands are
-     then entered on the wpa_cli prompt. In command line mode, the same
-     commands are entered as command line arguments for wpa_cli.</para>
-  </refsect1>
-  <refsect1>
-    <title>Interactive authentication parameters request</title>
- 
-    <para>When wpa_supplicant need authentication parameters, like
-    username and password, which are not present in the configuration
-    file, it sends a request message to all attached frontend programs,
-    e.g., wpa_cli in interactive mode. wpa_cli shows these requests
-    with "CTRL-REQ-&lt;type&gt;-&lt;id&gt;:&lt;text&gt;"
-    prefix. &lt;type&gt; is IDENTITY, PASSWORD, or OTP
-    (one-time-password). &lt;id&gt; is a unique identifier for the
-    current network. &lt;text&gt; is description of the request. In
-    case of OTP request, it includes the challenge from the
-    authentication server.</para>
- 
-     <para>The reply to these requests can be given with 'identity',
-     'password', and 'otp' commands. &lt;id&gt; needs to be copied from the
-     the matching request. 'password' and 'otp' commands can be used
-     regardless of whether the request was for PASSWORD or OTP. The
-     main difference between these two commands is that values given
-     with 'password' are remembered as long as wpa_supplicant is
-     running whereas values given with 'otp' are used only once and
-     then forgotten, i.e., wpa_supplicant will ask frontend for a new
-     value for every use. This can be used to implement
-     one-time-password lists and generic token card -based
-     authentication.</para>
- 
-     <para>Example request for password and a matching reply:</para>
- 
- <blockquote><programlisting>
- CTRL-REQ-PASSWORD-1:Password needed for SSID foobar
- > password 1 mysecretpassword
- </programlisting></blockquote>
- 
-     <para>Example request for generic token card challenge-response:</para>
- 
- <blockquote><programlisting>
- CTRL-REQ-OTP-2:Challenge 1235663 needed for SSID foobar
- > otp 2 9876
- </programlisting></blockquote>
- 
-   </refsect1>
-   <refsect1>
-     <title>Command Arguments</title>
-     <variablelist>
-       <varlistentry>
- 	<term>-p path</term>
- 
- 	<listitem><para>Change the path where control sockets should
- 	be found.</para></listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-i ifname</term>
- 
-         <listitem><para>Specify the interface that is being
- 	configured.  By default, choose the first interface found with
- 	a control socket in the socket path.</para></listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-h</term>
- 	<listitem><para>Help.  Show a usage message.</para></listitem>
-       </varlistentry>
- 
- 
-       <varlistentry>
- 	<term>-v</term>
- 	<listitem><para>Show version information.</para></listitem>
-       </varlistentry>
- 
- 
-       <varlistentry>
- 	<term>-B</term>
- 	<listitem><para>Run as a daemon in the background.</para></listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-a file</term>
- 
- 	<listitem><para>Run in daemon mode executing the action file
-         based on events from wpa_supplicant.  The specified file will
- 	be executed with the first argument set to interface name and
- 	second to "CONNECT" or "DISCONNECT" depending on the event.
- 	This can be used to execute networking tools required to configure
- 	the interface.</para>
- 
- 	<para>Additionally, three environmental variables are available to
- 	the file: WPA_CTRL_DIR, WPA_ID, and WPA_ID_STR. WPA_CTRL_DIR
- 	contains the absolute path to the ctrl_interface socket. WPA_ID
- 	contains the unique network_id identifier assigned to the active
- 	network, and WPA_ID_STR contains the content of the id_str option.
- 	</para></listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-P file</term>
- 
- 	<listitem><para>Set the location of the PID
- 	file.</para></listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>command</term>
- 
- 	<listitem><para>Run a command.  The available commands are
- 	listed in the next section.</para></listitem>
- 
-       </varlistentry>
-     </variablelist>
-   </refsect1>
-   <refsect1>
-     <title>Commands</title>
-     <para>The following commands are available:</para>
- 
-     <variablelist>
-       <varlistentry>
- 	<term>status</term>
- 	<listitem>
- 	  <para>get current WPA/EAPOL/EAP status</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>mib</term>
- 	<listitem>
- 	  <para>get MIB variables (dot1x, dot11)</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>help</term>
- 	<listitem>
- 	  <para>show this usage help</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>interface [ifname]</term>
- 	<listitem>
- 	  <para>show interfaces/select interface</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>level &lt;debug level&gt;</term>
- 	<listitem>
- 	  <para>change debug level</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>license</term>
- 	<listitem>
- 	  <para>show full wpa_cli license</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>logoff</term>
- 	<listitem>
- 	  <para>IEEE 802.1X EAPOL state machine logoff</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>logon</term>
- 	<listitem>
- 	  <para>IEEE 802.1X EAPOL state machine logon</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>set</term>
- 	<listitem>
- 	  <para>set variables (shows list of variables when run without arguments)</para>
- 	</listitem>
-       </varlistentry>
-       <varlistentry>
- 	<term>pmksa</term>
- 	<listitem>
- 	  <para>show PMKSA cache</para>
- 	</listitem>
-       </varlistentry>
-       <varlistentry>
- 	<term>reassociate</term>
- 	<listitem>
- 	  <para>force reassociation</para>
- 	</listitem>
-       </varlistentry>
-       <varlistentry>
- 	<term>reconfigure</term>
- 	<listitem>
- 	  <para>force wpa_supplicant to re-read its configuration file</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>preauthenticate &lt;BSSID&gt;</term>
- 	<listitem>
- 	  <para>force preauthentication</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>identity &lt;network id&gt; &lt;identity&gt;</term>
- 	<listitem>
- 	  <para>configure identity for an SSID</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>password &lt;network id&gt; &lt;password&gt;</term>
- 	<listitem>
- 	  <para>configure password for an SSID</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>pin &lt;network id&gt; &lt;pin&gt;</term>
- 	<listitem>
- 	  <para>configure pin for an SSID</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>otp &lt;network id&gt; &lt;password&gt;</term>
- 	<listitem>
- 	  <para>configure one-time-password for an SSID</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>bssid &lt;network id&gt; &lt;BSSID&gt;</term>
- 	<listitem>
- 	  <para>set preferred BSSID for an SSID</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>list_networks</term>
- 	<listitem>
- 	  <para>list configured networks</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>terminate</term>
- 	<listitem>
- 	  <para>terminate <command>wpa_supplicant</command></para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>quit</term>
- 	<listitem><para>exit wpa_cli</para></listitem>
-       </varlistentry>
-     </variablelist>
-   </refsect1>
-   <refsect1>
-     <title>See Also</title>
-     <para>
-       <citerefentry>
- 	<refentrytitle>wpa_supplicant</refentrytitle>
- 	<manvolnum>8</manvolnum>
-       </citerefentry>
-     </para>
-   </refsect1>
-   <refsect1>
-     <title>Legal</title>
-     <para>wpa_supplicant is copyright (c) 2003-2005,
-     Jouni Malinen <email>jkmaline@cc.hut.fi</email> and
-     contributors.
-     All Rights Reserved.</para>
- 
-     <para>This program is dual-licensed under both the GPL version 2
-     and BSD license. Either license may be used at your option.</para>
-   </refsect1>
- </refentry>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/docbook/wpa_passphrase.8 wpa_view/wpa_suppl/doc/docbook/wpa_passphrase.8
*** wpa_supplicant-0.5.7/doc/docbook/wpa_passphrase.8	Sun Dec 31 23:41:45 2006
--- wpa_view/wpa_suppl/doc/docbook/wpa_passphrase.8	Thu Jan  1 02:00:00 1970
***************
*** 1,40 ****
- .\" This manpage has been automatically generated by docbook2man 
- .\" from a DocBook document.  This tool can be found at:
- .\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
- .\" Please send any bug reports, improvements, comments, patches, 
- .\" etc. to Steve Cheng <steve@ggi-project.org>.
- .TH "WPA_PASSPHRASE" "8" "31 December 2006" "" ""
- 
- .SH NAME
- wpa_passphrase \- Generate a WPA PSK from an ASCII passphrase for a SSID
- .SH SYNOPSIS
- 
- \fBwpa_passphrase\fR [ \fB\fIssid\fB\fR ] [ \fB\fIpassphrase\fB\fR ]
- 
- .SH "OVERVIEW"
- .PP
- \fBwpa_passphrase\fR pre-computes PSK entries for
- network configuration blocks of a
- \fIwpa_supplicant.conf\fR file. An ASCII passphrase
- and SSID are used to generate a 256-bit PSK.
- .SH "OPTIONS"
- .TP
- \fBssid\fR
- The SSID whose passphrase should be derived.
- .TP
- \fBpassphrase\fR
- The passphrase to use. If not included on the command line,
- passphrase will be read from standard input.
- .SH "SEE ALSO"
- .PP
- \fBwpa_supplicant.conf\fR(5)
- \fBwpa_supplicant\fR(8)
- .SH "LEGAL"
- .PP
- wpa_supplicant is copyright (c) 2003-2005,
- Jouni Malinen <jkmaline@cc.hut.fi> and
- contributors.
- All Rights Reserved.
- .PP
- This program is dual-licensed under both the GPL version 2
- and BSD license. Either license may be used at your option.
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/docbook/wpa_passphrase.sgml wpa_view/wpa_suppl/doc/docbook/wpa_passphrase.sgml
*** wpa_supplicant-0.5.7/doc/docbook/wpa_passphrase.sgml	Mon Aug 21 19:36:19 2006
--- wpa_view/wpa_suppl/doc/docbook/wpa_passphrase.sgml	Thu Jan  1 02:00:00 1970
***************
*** 1,73 ****
- <!doctype refentry PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
- 
- <refentry>
-   <refmeta>
-     <refentrytitle>wpa_passphrase</refentrytitle>
-     <manvolnum>8</manvolnum>
-   </refmeta>
-   <refnamediv>
-     <refname>wpa_passphrase</refname>
-     <refpurpose>Generate a WPA PSK from an ASCII passphrase for a SSID</refpurpose>
-   </refnamediv>
-   <refsynopsisdiv>
-     <cmdsynopsis>
-       <command>wpa_passphrase</command>
-       <arg><replaceable>ssid</replaceable></arg>
-       <arg><replaceable>passphrase</replaceable></arg>
-     </cmdsynopsis>
-   </refsynopsisdiv>
- 
-   <refsect1>
-     <title>Overview</title> 
- 
-     <para><command>wpa_passphrase</command> pre-computes PSK entries for
-     network configuration blocks of a
-     <filename>wpa_supplicant.conf</filename> file. An ASCII passphrase
-     and SSID are used to generate a 256-bit PSK.</para>
-   </refsect1>
- 
-   <refsect1>
-     <title>Options</title>
-     <variablelist>
-       <varlistentry>
- 	<term>ssid</term>
- 	<listitem>
- 	  <para>The SSID whose passphrase should be derived.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>passphrase</term>
- 	<listitem>
- 	  <para>The passphrase to use. If not included on the command line,
- 	  passphrase will be read from standard input.</para>
- 	</listitem>
-       </varlistentry>
-     </variablelist>
-   </refsect1>
- 
-   <refsect1>
-     <title>See Also</title>
-     <para>
-       <citerefentry>
- 	<refentrytitle>wpa_supplicant.conf</refentrytitle>
- 	<manvolnum>5</manvolnum>
-       </citerefentry>
-       <citerefentry>
- 	<refentrytitle>wpa_supplicant</refentrytitle>
- 	<manvolnum>8</manvolnum>
-       </citerefentry>
-     </para>
- 
-   </refsect1>
-   <refsect1>
-     <title>Legal</title>
-     <para>wpa_supplicant is copyright (c) 2003-2005,
-     Jouni Malinen <email>jkmaline@cc.hut.fi</email> and
-     contributors.
-     All Rights Reserved.</para>
- 
-     <para>This program is dual-licensed under both the GPL version 2
-     and BSD license. Either license may be used at your option.</para>
-   </refsect1>
- </refentry>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/docbook/wpa_supplicant.8 wpa_view/wpa_suppl/doc/docbook/wpa_supplicant.8
*** wpa_supplicant-0.5.7/doc/docbook/wpa_supplicant.8	Sun Dec 31 23:41:46 2006
--- wpa_view/wpa_suppl/doc/docbook/wpa_supplicant.8	Thu Jan  1 02:00:00 1970
***************
*** 1,553 ****
- .\" This manpage has been automatically generated by docbook2man 
- .\" from a DocBook document.  This tool can be found at:
- .\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
- .\" Please send any bug reports, improvements, comments, patches, 
- .\" etc. to Steve Cheng <steve@ggi-project.org>.
- .TH "WPA_SUPPLICANT" "8" "31 December 2006" "" ""
- 
- .SH NAME
- wpa_supplicant \- Wi-Fi Protected Access client and IEEE 802.1X supplicant
- .SH SYNOPSIS
- 
- \fBwpa_supplicant\fR [ \fB-BddehLqqvw\fR ] [ \fB-i\fIifname\fB\fR ] [ \fB-c\fIconfig file\fB\fR ] [ \fB-D\fIdriver\fB\fR ] [ \fB-P\fIPID_file\fB\fR ]
- 
- .SH "OVERVIEW"
- .PP
- Wireless networks do not require physical access to the network equipment
- in the same way as wired networks. This makes it easier for unauthorized
- users to passively monitor a network and capture all transmitted frames.
- In addition, unauthorized use of the network is much easier. In many cases,
- this can happen even without user's explicit knowledge since the wireless
- LAN adapter may have been configured to automatically join any available
- network.
- .PP
- Link-layer encryption can be used to provide a layer of security for
- wireless networks. The original wireless LAN standard, IEEE 802.11,
- included a simple encryption mechanism, WEP. However, that proved to
- be flawed in many areas and network protected with WEP cannot be consider
- secure. IEEE 802.1X authentication and frequently changed dynamic WEP keys
- can be used to improve the network security, but even that has inherited
- security issues due to the use of WEP for encryption. Wi-Fi Protected
- Access and IEEE 802.11i amendment to the wireless LAN standard introduce
- a much improvement mechanism for securing wireless networks. IEEE 802.11i
- enabled networks that are using CCMP (encryption mechanism based on strong
- cryptographic algorithm AES) can finally be called secure used for
- applications which require efficient protection against unauthorized
- access.
- .PP
- \fBwpa_supplicant\fR is an implementation of
- the WPA Supplicant component, i.e., the part that runs in the
- client stations. It implements WPA key negotiation with a WPA
- Authenticator and EAP authentication with Authentication
- Server. In addition, it controls the roaming and IEEE 802.11
- authentication/association of the wireless LAN driver.
- .PP
- \fBwpa_supplicant\fR is designed to be a
- "daemon" program that runs in the background and acts as the
- backend component controlling the wireless
- connection. \fBwpa_supplicant\fR supports separate
- frontend programs and an example text-based frontend,
- \fBwpa_cli\fR, is included with
- wpa_supplicant.
- .PP
- Before wpa_supplicant can do its work, the network interface
- must be available.  That means that the physical device must be
- present and enabled, and the driver for the device must have be
- loaded.  Note, however, that the '-w' option of the wpa_supplicant
- daemon instructs the daemon to continue running and to wait for
- the interface to become available.  Without the '-w' option, the
- daemon will exit immediately if the device is not already
- available.
- .PP
- After \fBwpa_supplicant\fR has configured the
- network device, higher level configuration such as DHCP may
- proceed.  There are a variety of ways to integrate wpa_supplicant
- into a machine's networking scripts, a few of which are described
- in sections below.
- .PP
- The following steps are used when associating with an AP
- using WPA:
- .TP 0.2i
- \(bu
- \fBwpa_supplicant\fR requests the kernel
- driver to scan neighboring BSSes
- .TP 0.2i
- \(bu
- \fBwpa_supplicant\fR selects a BSS based on
- its configuration
- .TP 0.2i
- \(bu
- \fBwpa_supplicant\fR requests the kernel
- driver to associate with the chosen BSS
- .TP 0.2i
- \(bu
- If WPA-EAP: integrated IEEE 802.1X Supplicant or
- external Xsupplicant completes EAP authentication with the
- authentication server (proxied by the Authenticator in the
- AP)
- .TP 0.2i
- \(bu
- If WPA-EAP: master key is received from the IEEE 802.1X
- Supplicant
- .TP 0.2i
- \(bu
- If WPA-PSK: \fBwpa_supplicant\fR uses PSK
- as the master session key
- .TP 0.2i
- \(bu
- \fBwpa_supplicant\fR completes WPA 4-Way
- Handshake and Group Key Handshake with the Authenticator
- (AP)
- .TP 0.2i
- \(bu
- \fBwpa_supplicant\fR configures encryption
- keys for unicast and broadcast
- .TP 0.2i
- \(bu
- normal data packets can be transmitted and received
- .SH "SUPPORTED FEATURES"
- .PP
- Supported WPA/IEEE 802.11i features:
- .TP 0.2i
- \(bu
- WPA-PSK ("WPA-Personal")
- .TP 0.2i
- \(bu
- WPA with EAP (e.g., with RADIUS authentication server)
- ("WPA-Enterprise") Following authentication methods are
- supported with an integrate IEEE 802.1X Supplicant:
- .RS
- .TP 0.2i
- \(bu
- EAP-TLS
- .RE
- .RS
- .TP 0.2i
- \(bu
- EAP-PEAP/MSCHAPv2 (both PEAPv0 and PEAPv1)
- .TP 0.2i
- \(bu
- EAP-PEAP/TLS (both PEAPv0 and PEAPv1)
- .TP 0.2i
- \(bu
- EAP-PEAP/GTC (both PEAPv0 and PEAPv1)
- .TP 0.2i
- \(bu
- EAP-PEAP/OTP (both PEAPv0 and PEAPv1)
- .TP 0.2i
- \(bu
- EAP-PEAP/MD5-Challenge (both PEAPv0 and PEAPv1)
- .TP 0.2i
- \(bu
- EAP-TTLS/EAP-MD5-Challenge
- .TP 0.2i
- \(bu
- EAP-TTLS/EAP-GTC
- .TP 0.2i
- \(bu
- EAP-TTLS/EAP-OTP
- .TP 0.2i
- \(bu
- EAP-TTLS/EAP-MSCHAPv2
- .TP 0.2i
- \(bu
- EAP-TTLS/EAP-TLS
- .TP 0.2i
- \(bu
- EAP-TTLS/MSCHAPv2
- .TP 0.2i
- \(bu
- EAP-TTLS/MSCHAP
- .TP 0.2i
- \(bu
- EAP-TTLS/PAP
- .TP 0.2i
- \(bu
- EAP-TTLS/CHAP
- .TP 0.2i
- \(bu
- EAP-SIM
- .TP 0.2i
- \(bu
- EAP-AKA
- .TP 0.2i
- \(bu
- EAP-PSK
- .TP 0.2i
- \(bu
- EAP-PAX
- .TP 0.2i
- \(bu
- LEAP (note: requires special support from
- the driver for IEEE 802.11 authentication)
- .TP 0.2i
- \(bu
- (following methods are supported, but since
- they do not generate keying material, they cannot be used
- with WPA or IEEE 802.1X WEP keying)
- .TP 0.2i
- \(bu
- EAP-MD5-Challenge 
- .TP 0.2i
- \(bu
- EAP-MSCHAPv2
- .TP 0.2i
- \(bu
- EAP-GTC
- .TP 0.2i
- \(bu
- EAP-OTP
- .RE
- .TP 0.2i
- \(bu
- key management for CCMP, TKIP, WEP104, WEP40
- .TP 0.2i
- \(bu
- RSN/WPA2 (IEEE 802.11i)
- .RS
- .TP 0.2i
- \(bu
- pre-authentication
- .TP 0.2i
- \(bu
- PMKSA caching
- .RE
- .SH "AVAILABLE DRIVERS"
- .PP
- The available drivers to specify with the -D option are:
- .TP
- \fBhostap\fR
- (default) Host AP driver (Intersil Prism2/2.5/3).
- (this can also be used with Linuxant DriverLoader).
- .TP
- \fBhermes\fR
- Agere Systems Inc. driver (Hermes-I/Hermes-II).
- .TP
- \fBmadwifi\fR
- MADWIFI 802.11 support (Atheros, etc.).
- .TP
- \fBatmel\fR
- ATMEL AT76C5XXx (USB, PCMCIA).
- .TP
- \fBwext\fR
- Linux wireless extensions (generic).
- .TP
- \fBndiswrapper\fR
- Linux ndiswrapper.
- .TP
- \fBbroadcom\fR
- Broadcom wl.o driver.
- .TP
- \fBipw\fR
- Intel ipw2100/2200 driver.
- .TP
- \fBwired\fR
- wpa_supplicant wired Ethernet driver
- .TP
- \fBbsd\fR
- BSD 802.11 support (Atheros, etc.).
- .TP
- \fBndis\fR
- Windows NDIS driver.
- .SH "COMMAND LINE OPTIONS"
- .TP
- \fB-B\fR
- Run daemon in the background.
- .TP
- \fB-i ifname\fR
- Interface to listen on.
- .TP
- \fB-c filename\fR
- Path to configuration file.
- .TP
- \fB-P PID_file\fR
- Path to PID file.
- .TP
- \fB-C ctrl_interface\fR
- Path to ctrl_interface socket (only used if -c is not).
- .TP
- \fB-g global ctrl_interface\fR
- Path to global ctrl_interface socket.
- .TP
- \fB-D driver\fR
- Driver to use.  See the available options below.
- .TP
- \fB-d\fR
- Increase debugging verbosity (-dd even more).
- .TP
- \fB-K\fR
- Include keys (passwords, etc.) in debug output.
- .TP
- \fB-t\fR
- Include timestamp in debug messages.
- .TP
- \fB-e\fR
- Use external IEEE 802.1X Supplicant (e.g.,
- \fBxsupplicant\fR) (this disables the internal
- Supplicant).
- .TP
- \fB-h\fR
- Help.  Show a usage message.
- .TP
- \fB-L\fR
- Show license (GPL and BSD).
- .TP
- \fB-q\fR
- Decrease debugging verbosity (-qq even less).
- .TP
- \fB-v\fR
- Show version.
- .TP
- \fB-w\fR
- wait for interface to be added, if needed.  normally,
- \fBwpa_supplicant\fR will exit if the interface
- is not there yet.
- .TP
- \fB-N\fR
- Start describing new interface.
- .SH "EXAMPLES"
- .PP
- In most common cases, \fBwpa_supplicant\fR is
- started with:
- .sp
- .RS
- 
- .nf
- wpa_supplicant -Bw -c/etc/wpa_supplicant.conf -iwlan0
- .fi
- .RE
- .PP
- This makes the process fork into background and wait for the wlan0
- interface if it is not available at startup time.
- .PP
- The easiest way to debug problems, and to get debug log for
- bug reports, is to start \fBwpa_supplicant\fR on
- foreground with debugging enabled:
- .sp
- .RS
- 
- .nf
- wpa_supplicant -c/etc/wpa_supplicant.conf -iwlan0 -d
- .fi
- .RE
- .PP
- \fBwpa_supplicant\fR can control multiple
- interfaces (radios) either by running one process for each
- interface separately or by running just one process and list of
- options at command line. Each interface is separated with -N
- argument. As an example, following command would start
- wpa_supplicant for two interfaces:
- .sp
- .RS
- 
- .nf
- wpa_supplicant \\
- 	-c wpa1.conf -i wlan0 -D hostap -N \\
- 	-c wpa2.conf -i ath0 -D madwifi
- .fi
- .RE
- .SH "OS REQUIREMENTS"
- .PP
- Current hardware/software requirements:
- .TP 0.2i
- \(bu
- Linux kernel 2.4.x or 2.6.x with Linux Wireless
- Extensions v15 or newer
- .TP 0.2i
- \(bu
- FreeBSD 6-CURRENT
- .TP 0.2i
- \(bu
- Microsoft Windows with WinPcap (at least WinXP, may work
- with other versions)
- .SH "SUPPORTED DRIVERS"
- .TP
- \fBHost AP driver for Prism2/2.5/3 (development snapshot/v0.2.x)\fR
- (http://hostap.epitest.fi/) Driver needs to be set in
- Managed mode ('iwconfig wlan0 mode managed').  Please note
- that station firmware version needs to be 1.7.0 or newer to
- work in WPA mode.
- .TP
- \fBLinuxant DriverLoader\fR
- (http://www.linuxant.com/driverloader/)
- with Windows NDIS driver for your wlan card supporting WPA.
- .TP
- \fBAgere Systems Inc. Linux Driver\fR
- (http://www.agere.com/support/drivers/) Please note
- that the driver interface file (driver_hermes.c) and hardware
- specific include files are not included in the wpa_supplicant
- distribution. You will need to copy these from the source
- package of the Agere driver.
- .TP
- \fBmadwifi driver for cards based on Atheros chip set (ar521x)\fR
- (http://sourceforge.net/projects/madwifi/) Please
- note that you will need to modify the wpa_supplicant .config
- file to use the correct path for the madwifi driver root
- directory (CFLAGS += -I../madwifi/wpa line in example
- defconfig).
- .TP
- \fBATMEL AT76C5XXx driver for USB and PCMCIA cards\fR
- (http://atmelwlandriver.sourceforge.net/).
- .TP
- \fBLinux ndiswrapper\fR
- (http://ndiswrapper.sourceforge.net/) with Windows
- NDIS driver.
- .TP
- \fBBroadcom wl.o driver\fR
- This is a generic Linux driver for Broadcom IEEE
- 802.11a/g cards.  However, it is proprietary driver that is
- not publicly available except for couple of exceptions, mainly
- Broadcom-based APs/wireless routers that use Linux. The driver
- binary can be downloaded, e.g., from Linksys support site
- (http://www.linksys.com/support/gpl.asp) for Linksys
- WRT54G. The GPL tarball includes cross-compiler and the needed
- header file, wlioctl.h, for compiling wpa_supplicant.  This
- driver support in wpa_supplicant is expected to work also with
- other devices based on Broadcom driver (assuming the driver
- includes client mode support).
- .TP
- \fB Intel ipw2100 driver\fR
- (http://sourceforge.net/projects/ipw2100/)
- .TP
- \fBIntel ipw2200 driver\fR
- (http://sourceforge.net/projects/ipw2200/)
- .TP
- \fBLinux wireless extensions\fR
- In theory, any driver that supports Linux wireless
- extensions can be used with IEEE 802.1X (i.e., not WPA) when
- using ap_scan=0 option in configuration file.
- .TP
- \fBWired Ethernet drivers\fR
- Use ap_scan=0.
- .TP
- \fBBSD net80211 layer (e.g., Atheros driver)\fR
- At the moment, this is for FreeBSD 6-CURRENT branch.
- .TP
- \fBWindows NDIS\fR
- The current Windows port requires WinPcap
- (http://winpcap.polito.it/).  See README-Windows.txt for more
- information.
- .PP
- wpa_supplicant was designed to be portable for different
- drivers and operating systems. Hopefully, support for more wlan
- cards and OSes will be added in the future. See developer.txt for
- more information about the design of wpa_supplicant and porting to
- other drivers. One main goal is to add full WPA/WPA2 support to
- Linux wireless extensions to allow new drivers to be supported
- without having to implement new driver-specific interface code in
- wpa_supplicant.
- .SH "ARCHITECTURE"
- .PP
- The
- \fBwpa_supplicant\fR system consists of the following
- components:
- .TP
- \fB\fIwpa_supplicant.conf\fB \fR
- the configuration file describing all networks that the
- user wants the computer to connect to.  
- .TP
- \fBwpa_supplicant\fR
- the program that directly interacts with the
- network interface.  
- .TP
- \fBwpa_cli\fR
- the
- client program that provides a high-level interface to the
- functionality of the daemon.  
- .TP
- \fBwpa_passphrase\fR
- a utility needed to construct
- \fIwpa_supplicant.conf\fR files that include
- encrypted passwords.
- .SH "QUICK START"
- .PP
- First, make a configuration file, e.g.
- \fI/etc/wpa_supplicant.conf\fR, that describes the networks
- you are interested in.  See \fBwpa_supplicant.conf\fR(5)
- for details.
- .PP
- Once the configuration is ready, you can test whether the
- configuration works by running \fBwpa_supplicant\fR
- with following command to start it on foreground with debugging
- enabled:
- .sp
- .RS
- 
- .nf
- wpa_supplicant -iwlan0 -c/etc/wpa_supplicant.conf -d
-     
- .fi
- .RE
- .PP
- Assuming everything goes fine, you can start using following
- command to start \fBwpa_supplicant\fR on background
- without debugging:
- .sp
- .RS
- 
- .nf
- wpa_supplicant -iwlan0 -c/etc/wpa_supplicant.conf -B
-     
- .fi
- .RE
- .PP
- Please note that if you included more than one driver
- interface in the build time configuration (.config), you may need
- to specify which interface to use by including -D<driver
- name> option on the command line.
- .SH "INTERFACE TO PCMCIA-CS/CARDMRG"
- .PP
- For example, following small changes to pcmcia-cs scripts
- can be used to enable WPA support:
- .PP
- Add MODE="Managed" and WPA="y" to the network scheme in
- \fI/etc/pcmcia/wireless.opts\fR\&.
- .PP
- Add the following block to the end of 'start' action handler
- in \fI/etc/pcmcia/wireless\fR:
- .sp
- .RS
- 
- .nf
- if [ "$WPA" = "y" -a -x /usr/local/bin/wpa_supplicant ]; then
-     /usr/local/bin/wpa_supplicant -Bw -c/etc/wpa_supplicant.conf -i$DEVICE
- fi
-     
- .fi
- .RE
- .PP
- Add the following block to the end of 'stop' action handler
- (may need to be separated from other actions) in
- \fI/etc/pcmcia/wireless\fR:
- .sp
- .RS
- 
- .nf
- if [ "$WPA" = "y" -a -x /usr/local/bin/wpa_supplicant ]; then
-     killall wpa_supplicant
- fi
-     
- .fi
- .RE
- .PP
- This will make \fBcardmgr\fR start
- \fBwpa_supplicant\fR when the card is plugged
- in. \fBwpa_supplicant\fR will wait until the
- interface is set up--either when a static IP address is configured
- or when DHCP client is started--and will then negotiate keys with
- the AP.
- .SH "SEE ALSO"
- .PP
- \fBwpa_background\fR(8)
- \fBwpa_supplicant.conf\fR(5)
- \fBwpa_cli\fR(8)
- \fBwpa_passphrase\fR(8)
- .SH "LEGAL"
- .PP
- wpa_supplicant is copyright (c) 2003-2005,
- Jouni Malinen <jkmaline@cc.hut.fi> and
- contributors.
- All Rights Reserved.
- .PP
- This program is dual-licensed under both the GPL version 2
- and BSD license. Either license may be used at your option.
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/docbook/wpa_supplicant.conf.5 wpa_view/wpa_suppl/doc/docbook/wpa_supplicant.conf.5
*** wpa_supplicant-0.5.7/doc/docbook/wpa_supplicant.conf.5	Sun Dec 31 23:41:45 2006
--- wpa_view/wpa_suppl/doc/docbook/wpa_supplicant.conf.5	Thu Jan  1 02:00:00 1970
***************
*** 1,230 ****
- .\" This manpage has been automatically generated by docbook2man 
- .\" from a DocBook document.  This tool can be found at:
- .\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
- .\" Please send any bug reports, improvements, comments, patches, 
- .\" etc. to Steve Cheng <steve@ggi-project.org>.
- .TH "WPA_SUPPLICANT.CONF" "5" "31 December 2006" "" ""
- 
- .SH NAME
- wpa_supplicant.conf \- configuration file for wpa_supplicant
- .SH "OVERVIEW"
- .PP
- \fBwpa_supplicant\fR is configured using a text
- file that lists all accepted networks and security policies,
- including pre-shared keys. See the example configuration file,
- probably in \fB/usr/share/doc/wpa_supplicant/\fR, for
- detailed information about the configuration format and supported
- fields.
- .PP
- All file paths in this configuration file should use full
- (absolute, not relative to working directory) path in order to allow
- working directory to be changed. This can happen if wpa_supplicant is
- run in the background.
- .PP
- Changes to configuration file can be reloaded be sending
- SIGHUP signal to \fBwpa_supplicant\fR ('killall -HUP
- wpa_supplicant'). Similarly, reloading can be triggered with
- the 'wpa_cli reconfigure' command.
- .PP
- Configuration file can include one or more network blocks,
- e.g., one for each used SSID. wpa_supplicant will automatically
- select the best network based on the order of network blocks in
- the configuration file, network security level (WPA/WPA2 is
- preferred), and signal strength.
- .SH "QUICK EXAMPLES"
- .TP 3
- 1. 
- WPA-Personal (PSK) as home network and WPA-Enterprise with
- EAP-TLS as work network.
- .sp
- .RS
- 
- .nf
- # allow frontend (e.g., wpa_cli) to be used by all users in 'wheel' group
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- #
- # home network; allow all valid ciphers
- network={
- 	ssid="home"
- 	scan_ssid=1
- 	key_mgmt=WPA-PSK
- 	psk="very secret passphrase"
- }
- #
- # work network; use EAP-TLS with WPA; allow only CCMP and TKIP ciphers
- network={
- 	ssid="work"
- 	scan_ssid=1
- 	key_mgmt=WPA-EAP
- 	pairwise=CCMP TKIP
- 	group=CCMP TKIP
- 	eap=TLS
- 	identity="user@example.com"
- 	ca_cert="/etc/cert/ca.pem"
- 	client_cert="/etc/cert/user.pem"
- 	private_key="/etc/cert/user.prv"
- 	private_key_passwd="password"
- }
- .fi
- .RE
- .TP 3
- 2. 
- WPA-RADIUS/EAP-PEAP/MSCHAPv2 with RADIUS servers that
- use old peaplabel (e.g., Funk Odyssey and SBR, Meetinghouse
- Aegis, Interlink RAD-Series)
- .sp
- .RS
- 
- .nf
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- network={
- 	ssid="example"
- 	scan_ssid=1
- 	key_mgmt=WPA-EAP
- 	eap=PEAP
- 	identity="user@example.com"
- 	password="foobar"
- 	ca_cert="/etc/cert/ca.pem"
- 	phase1="peaplabel=0"
- 	phase2="auth=MSCHAPV2"
- }
- .fi
- .RE
- .TP 3
- 3. 
- EAP-TTLS/EAP-MD5-Challenge configuration with anonymous
- identity for the unencrypted use. Real identity is sent only
- within an encrypted TLS tunnel.
- .sp
- .RS
- 
- .nf
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- network={
- 	ssid="example"
- 	scan_ssid=1
- 	key_mgmt=WPA-EAP
- 	eap=TTLS
- 	identity="user@example.com"
- 	anonymous_identity="anonymous@example.com"
- 	password="foobar"
- 	ca_cert="/etc/cert/ca.pem"
- 	phase2="auth=MD5"
- }
- .fi
- .RE
- .TP 3
- 4. 
- IEEE 802.1X (i.e., no WPA) with dynamic WEP keys
- (require both unicast and broadcast); use EAP-TLS for
- authentication
- .sp
- .RS
- 
- .nf
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- network={
- 	ssid="1x-test"
- 	scan_ssid=1
- 	key_mgmt=IEEE8021X
- 	eap=TLS
- 	identity="user@example.com"
- 	ca_cert="/etc/cert/ca.pem"
- 	client_cert="/etc/cert/user.pem"
- 	private_key="/etc/cert/user.prv"
- 	private_key_passwd="password"
- 	eapol_flags=3
- }
- .fi
- .RE
- .TP 3
- 5. 
- Catch all example that allows more or less all
- configuration modes. The configuration options are used based
- on what security policy is used in the selected SSID. This is
- mostly for testing and is not recommended for normal
- use.
- .sp
- .RS
- 
- .nf
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- network={
- 	ssid="example"
- 	scan_ssid=1
- 	key_mgmt=WPA-EAP WPA-PSK IEEE8021X NONE
- 	pairwise=CCMP TKIP
- 	group=CCMP TKIP WEP104 WEP40
- 	psk="very secret passphrase"
- 	eap=TTLS PEAP TLS
- 	identity="user@example.com"
- 	password="foobar"
- 	ca_cert="/etc/cert/ca.pem"
- 	client_cert="/etc/cert/user.pem"
- 	private_key="/etc/cert/user.prv"
- 	private_key_passwd="password"
- 	phase1="peaplabel=0"
- 	ca_cert2="/etc/cert/ca2.pem"
- 	client_cert2="/etc/cer/user.pem"
- 	private_key2="/etc/cer/user.prv"
- 	private_key2_passwd="password"
- }
- .fi
- .RE
- .TP 3
- 6. 
- Authentication for wired Ethernet. This can be used with
- 'wired' interface (-Dwired on command line).
- .sp
- .RS
- 
- .nf
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- ap_scan=0
- network={
- 	key_mgmt=IEEE8021X
- 	eap=MD5
- 	identity="user"
- 	password="password"
- 	eapol_flags=0
- }
- .fi
- .RE
- .SH "CERTIFICATES"
- .PP
- Some EAP authentication methods require use of
- certificates. EAP-TLS uses both server side and client
- certificates whereas EAP-PEAP and EAP-TTLS only require the server
- side certificate. When client certificate is used, a matching
- private key file has to also be included in configuration. If the
- private key uses a passphrase, this has to be configured in
- wpa_supplicant.conf ("private_key_passwd").
- .PP
- wpa_supplicant supports X.509 certificates in PEM and DER
- formats. User certificate and private key can be included in the
- same file.
- .PP
- If the user certificate and private key is received in
- PKCS#12/PFX format, they need to be converted to suitable PEM/DER
- format for wpa_supplicant. This can be done, e.g., with following
- commands:
- .sp
- .RS
- 
- .nf
- # convert client certificate and private key to PEM format
- openssl pkcs12 -in example.pfx -out user.pem -clcerts
- # convert CA certificate (if included in PFX file) to PEM format
- openssl pkcs12 -in example.pfx -out ca.pem -cacerts -nokeys
- .fi
- .RE
- .SH "SEE ALSO"
- .PP
- \fBwpa_supplicant\fR(8)
- \fBopenssl\fR(1)
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/docbook/wpa_supplicant.conf.sgml wpa_view/wpa_suppl/doc/docbook/wpa_supplicant.conf.sgml
*** wpa_supplicant-0.5.7/doc/docbook/wpa_supplicant.conf.sgml	Sun Jul 30 20:48:26 2006
--- wpa_view/wpa_suppl/doc/docbook/wpa_supplicant.conf.sgml	Thu Jan  1 02:00:00 1970
***************
*** 1,244 ****
- <!doctype refentry PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
- <refentry>
-   <refmeta>
-     <refentrytitle>wpa_supplicant.conf</refentrytitle>
-     <manvolnum>5</manvolnum>
-   </refmeta>
-   <refnamediv>
-     <refname>wpa_supplicant.conf</refname>
-     <refpurpose>configuration file for wpa_supplicant</refpurpose>
-   </refnamediv>
-   <refsect1>
-     <title>Overview</title>
- 
-     <para><command>wpa_supplicant</command> is configured using a text
-     file that lists all accepted networks and security policies,
-     including pre-shared keys. See the example configuration file,
-     probably in <command>/usr/share/doc/wpa_supplicant/</command>, for
-     detailed information about the configuration format and supported
-     fields.</para>
- 
-     <para>All file paths in this configuration file should use full
-     (absolute, not relative to working directory) path in order to allow
-     working directory to be changed. This can happen if wpa_supplicant is
-     run in the background.</para>
- 
-     <para>Changes to configuration file can be reloaded be sending
-     SIGHUP signal to <command>wpa_supplicant</command> ('killall -HUP
-     wpa_supplicant'). Similarly, reloading can be triggered with
-     the 'wpa_cli reconfigure' command.</para>
- 
-     <para>Configuration file can include one or more network blocks,
-     e.g., one for each used SSID. wpa_supplicant will automatically
-     select the best network based on the order of network blocks in
-     the configuration file, network security level (WPA/WPA2 is
-     preferred), and signal strength.</para>
-   </refsect1>
- 
-   <refsect1>
-     <title>Quick Examples</title>
- 
-     <orderedlist>
-       <listitem>
- 
-       <para>WPA-Personal (PSK) as home network and WPA-Enterprise with
-       EAP-TLS as work network.</para>
- 
- <blockquote><programlisting>
- # allow frontend (e.g., wpa_cli) to be used by all users in 'wheel' group
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- #
- # home network; allow all valid ciphers
- network={
- 	ssid="home"
- 	scan_ssid=1
- 	key_mgmt=WPA-PSK
- 	psk="very secret passphrase"
- }
- #
- # work network; use EAP-TLS with WPA; allow only CCMP and TKIP ciphers
- network={
- 	ssid="work"
- 	scan_ssid=1
- 	key_mgmt=WPA-EAP
- 	pairwise=CCMP TKIP
- 	group=CCMP TKIP
- 	eap=TLS
- 	identity="user@example.com"
- 	ca_cert="/etc/cert/ca.pem"
- 	client_cert="/etc/cert/user.pem"
- 	private_key="/etc/cert/user.prv"
- 	private_key_passwd="password"
- }
- </programlisting></blockquote>   
-       </listitem>
- 
-       <listitem>
- 	<para>WPA-RADIUS/EAP-PEAP/MSCHAPv2 with RADIUS servers that
-         use old peaplabel (e.g., Funk Odyssey and SBR, Meetinghouse
-         Aegis, Interlink RAD-Series)</para>
- 
- <blockquote><programlisting>
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- network={
- 	ssid="example"
- 	scan_ssid=1
- 	key_mgmt=WPA-EAP
- 	eap=PEAP
- 	identity="user@example.com"
- 	password="foobar"
- 	ca_cert="/etc/cert/ca.pem"
- 	phase1="peaplabel=0"
- 	phase2="auth=MSCHAPV2"
- }
- </programlisting></blockquote>
-       </listitem>
- 
-       <listitem>
- 	<para>EAP-TTLS/EAP-MD5-Challenge configuration with anonymous
-         identity for the unencrypted use. Real identity is sent only
-         within an encrypted TLS tunnel.</para>
- 
- 
- <blockquote><programlisting>
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- network={
- 	ssid="example"
- 	scan_ssid=1
- 	key_mgmt=WPA-EAP
- 	eap=TTLS
- 	identity="user@example.com"
- 	anonymous_identity="anonymous@example.com"
- 	password="foobar"
- 	ca_cert="/etc/cert/ca.pem"
- 	phase2="auth=MD5"
- }
- </programlisting></blockquote>
- 
-       </listitem>
- 
-       <listitem>
- 	<para>IEEE 802.1X (i.e., no WPA) with dynamic WEP keys
-         (require both unicast and broadcast); use EAP-TLS for
-         authentication</para>
- 
- <blockquote><programlisting>
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- network={
- 	ssid="1x-test"
- 	scan_ssid=1
- 	key_mgmt=IEEE8021X
- 	eap=TLS
- 	identity="user@example.com"
- 	ca_cert="/etc/cert/ca.pem"
- 	client_cert="/etc/cert/user.pem"
- 	private_key="/etc/cert/user.prv"
- 	private_key_passwd="password"
- 	eapol_flags=3
- }
- </programlisting></blockquote>
-       </listitem>
- 
- 
-       <listitem>
- 	<para>Catch all example that allows more or less all
-         configuration modes. The configuration options are used based
-         on what security policy is used in the selected SSID. This is
-         mostly for testing and is not recommended for normal
-         use.</para>
- 
- <blockquote><programlisting>
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- network={
- 	ssid="example"
- 	scan_ssid=1
- 	key_mgmt=WPA-EAP WPA-PSK IEEE8021X NONE
- 	pairwise=CCMP TKIP
- 	group=CCMP TKIP WEP104 WEP40
- 	psk="very secret passphrase"
- 	eap=TTLS PEAP TLS
- 	identity="user@example.com"
- 	password="foobar"
- 	ca_cert="/etc/cert/ca.pem"
- 	client_cert="/etc/cert/user.pem"
- 	private_key="/etc/cert/user.prv"
- 	private_key_passwd="password"
- 	phase1="peaplabel=0"
- 	ca_cert2="/etc/cert/ca2.pem"
- 	client_cert2="/etc/cer/user.pem"
- 	private_key2="/etc/cer/user.prv"
- 	private_key2_passwd="password"
- }
- </programlisting></blockquote>
-       </listitem>
- 
-       <listitem>
- 	<para>Authentication for wired Ethernet. This can be used with
-        'wired' interface (-Dwired on command line).</para>
- 
- <blockquote><programlisting>
- ctrl_interface=/var/run/wpa_supplicant
- ctrl_interface_group=wheel
- ap_scan=0
- network={
- 	key_mgmt=IEEE8021X
- 	eap=MD5
- 	identity="user"
- 	password="password"
- 	eapol_flags=0
- }
- </programlisting></blockquote>
-       </listitem>
-     </orderedlist>
- 
- 
- 
- 
- 
-   </refsect1>
-   <refsect1>
-     <title>Certificates</title>
- 
-     <para>Some EAP authentication methods require use of
-     certificates. EAP-TLS uses both server side and client
-     certificates whereas EAP-PEAP and EAP-TTLS only require the server
-     side certificate. When client certificate is used, a matching
-     private key file has to also be included in configuration. If the
-     private key uses a passphrase, this has to be configured in
-     wpa_supplicant.conf ("private_key_passwd").</para>
- 
-     <para>wpa_supplicant supports X.509 certificates in PEM and DER
-     formats. User certificate and private key can be included in the
-     same file.</para>
- 
-     <para>If the user certificate and private key is received in
-     PKCS#12/PFX format, they need to be converted to suitable PEM/DER
-     format for wpa_supplicant. This can be done, e.g., with following
-     commands:</para>
- <blockquote><programlisting>
- # convert client certificate and private key to PEM format
- openssl pkcs12 -in example.pfx -out user.pem -clcerts
- # convert CA certificate (if included in PFX file) to PEM format
- openssl pkcs12 -in example.pfx -out ca.pem -cacerts -nokeys
- </programlisting></blockquote>
-   </refsect1>
- 
-   <refsect1>
-     <title>See Also</title>
-     <para>
-       <citerefentry>
- 	<refentrytitle>wpa_supplicant</refentrytitle>
- 	<manvolnum>8</manvolnum>
-       </citerefentry>
-       <citerefentry>
- 	<refentrytitle>openssl</refentrytitle>
- 	<manvolnum>1</manvolnum>
-       </citerefentry>
-     </para>
-   </refsect1>
- </refentry>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/docbook/wpa_supplicant.sgml wpa_view/wpa_suppl/doc/docbook/wpa_supplicant.sgml
*** wpa_supplicant-0.5.7/doc/docbook/wpa_supplicant.sgml	Sun Nov 19 05:31:33 2006
--- wpa_view/wpa_suppl/doc/docbook/wpa_supplicant.sgml	Thu Jan  1 02:00:00 1970
***************
*** 1,783 ****
- <!doctype refentry PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
- 
- <refentry>
-   <refmeta>
-     <refentrytitle>wpa_supplicant</refentrytitle>
-     <manvolnum>8</manvolnum>
-   </refmeta>
-   <refnamediv>
-     <refname>wpa_supplicant</refname>
-     <refpurpose>Wi-Fi Protected Access client and IEEE 802.1X supplicant</refpurpose>
-   </refnamediv>
-   <refsynopsisdiv>
-     <cmdsynopsis>
-       <command>wpa_supplicant</command>
-       <arg>-BddehLqqvw</arg>
-       <arg>-i<replaceable>ifname</replaceable></arg>
-       <arg>-c<replaceable>config file</replaceable></arg>
-       <arg>-D<replaceable>driver</replaceable></arg>
-       <arg>-P<replaceable>PID_file</replaceable></arg>
-     </cmdsynopsis>
-   </refsynopsisdiv>
-   <refsect1>
-     <title>Overview</title>
- 
-     <para>
-     Wireless networks do not require physical access to the network equipment
-     in the same way as wired networks. This makes it easier for unauthorized
-     users to passively monitor a network and capture all transmitted frames.
-     In addition, unauthorized use of the network is much easier. In many cases,
-     this can happen even without user's explicit knowledge since the wireless
-     LAN adapter may have been configured to automatically join any available
-     network.
-     </para>
- 
-     <para>
-     Link-layer encryption can be used to provide a layer of security for
-     wireless networks. The original wireless LAN standard, IEEE 802.11,
-     included a simple encryption mechanism, WEP. However, that proved to
-     be flawed in many areas and network protected with WEP cannot be consider
-     secure. IEEE 802.1X authentication and frequently changed dynamic WEP keys
-     can be used to improve the network security, but even that has inherited
-     security issues due to the use of WEP for encryption. Wi-Fi Protected
-     Access and IEEE 802.11i amendment to the wireless LAN standard introduce
-     a much improvement mechanism for securing wireless networks. IEEE 802.11i
-     enabled networks that are using CCMP (encryption mechanism based on strong
-     cryptographic algorithm AES) can finally be called secure used for
-     applications which require efficient protection against unauthorized
-     access.
-     </para>
- 
-     <para><command>wpa_supplicant</command> is an implementation of
-     the WPA Supplicant component, i.e., the part that runs in the
-     client stations. It implements WPA key negotiation with a WPA
-     Authenticator and EAP authentication with Authentication
-     Server. In addition, it controls the roaming and IEEE 802.11
-     authentication/association of the wireless LAN driver.</para>
- 
-     <para><command>wpa_supplicant</command> is designed to be a
-     "daemon" program that runs in the background and acts as the
-     backend component controlling the wireless
-     connection. <command>wpa_supplicant</command> supports separate
-     frontend programs and an example text-based frontend,
-     <command>wpa_cli</command>, is included with
-     wpa_supplicant.</para>
- 
-     <para>Before wpa_supplicant can do its work, the network interface
-     must be available.  That means that the physical device must be
-     present and enabled, and the driver for the device must have be
-     loaded.  Note, however, that the '-w' option of the wpa_supplicant
-     daemon instructs the daemon to continue running and to wait for
-     the interface to become available.  Without the '-w' option, the
-     daemon will exit immediately if the device is not already
-     available.</para>
- 
-     <para>After <command>wpa_supplicant</command> has configured the
-     network device, higher level configuration such as DHCP may
-     proceed.  There are a variety of ways to integrate wpa_supplicant
-     into a machine's networking scripts, a few of which are described
-     in sections below.</para>
- 
-     <para>The following steps are used when associating with an AP
-     using WPA:</para>
- 
-     <itemizedlist>
-       <listitem>
- 	<para><command>wpa_supplicant</command> requests the kernel
- 	driver to scan neighboring BSSes</para>
-       </listitem>
- 
-       <listitem>
- 	<para><command>wpa_supplicant</command> selects a BSS based on
- 	its configuration</para>
-       </listitem>
- 
-       <listitem>
- 	<para><command>wpa_supplicant</command> requests the kernel
-         driver to associate with the chosen BSS</para>
-       </listitem>
- 
-       <listitem>
- 	<para>If WPA-EAP: integrated IEEE 802.1X Supplicant or
-         external Xsupplicant completes EAP authentication with the
-         authentication server (proxied by the Authenticator in the
-         AP)</para>
-       </listitem>
- 
-       <listitem>
- 	<para>If WPA-EAP: master key is received from the IEEE 802.1X
- 	Supplicant</para>
-       </listitem>
- 
-       <listitem>
- 	<para>If WPA-PSK: <command>wpa_supplicant</command> uses PSK
- 	as the master session key</para>
-       </listitem>
- 
-       <listitem>
- 	<para><command>wpa_supplicant</command> completes WPA 4-Way
-         Handshake and Group Key Handshake with the Authenticator
-         (AP)</para>
-       </listitem>
- 
-       <listitem>
- 	<para><command>wpa_supplicant</command> configures encryption
- 	keys for unicast and broadcast</para>
-       </listitem>
- 
-       <listitem>
- 	<para>normal data packets can be transmitted and received</para>
-       </listitem>
-     </itemizedlist>
-   </refsect1>
- 
-   <refsect1>
-     <title>Supported Features</title>
-     <para>Supported WPA/IEEE 802.11i features:</para>
-     <itemizedlist>
-       <listitem>
- 	<para>WPA-PSK ("WPA-Personal")</para>
-       </listitem>
- 
-       <listitem>
- 	<para>WPA with EAP (e.g., with RADIUS authentication server)
-        ("WPA-Enterprise") Following authentication methods are
-        supported with an integrate IEEE 802.1X Supplicant:</para>
- 
- 	<itemizedlist>
- 	  <listitem>
- 	    <para>EAP-TLS</para>
- 	  </listitem>
- 	</itemizedlist>
- 
- 	<itemizedlist>
- 	  <listitem>
- 	    <para>EAP-PEAP/MSCHAPv2 (both PEAPv0 and PEAPv1)</para>
- 	  </listitem>
- 
- 
- 	  <listitem>
- 	    <para>EAP-PEAP/TLS (both PEAPv0 and PEAPv1)</para>
- 	  </listitem>
- 
- 	  <listitem>
- 	    <para>EAP-PEAP/GTC (both PEAPv0 and PEAPv1)</para>
- 	  </listitem>
- 
- 	  <listitem>
- 	    <para>EAP-PEAP/OTP (both PEAPv0 and PEAPv1)</para>
- 	  </listitem>
- 
- 	  <listitem>
- 	    <para>EAP-PEAP/MD5-Challenge (both PEAPv0 and PEAPv1)</para>
- 	  </listitem>
- 
- 	  <listitem>
- 	    <para>EAP-TTLS/EAP-MD5-Challenge</para>
- 	  </listitem>
- 
- 	  <listitem>
- 	    <para>EAP-TTLS/EAP-GTC</para>
- 	  </listitem>
- 
-           <listitem><para>EAP-TTLS/EAP-OTP</para></listitem>
- 
-           <listitem><para>EAP-TTLS/EAP-MSCHAPv2</para></listitem>
- 
-           <listitem><para>EAP-TTLS/EAP-TLS</para></listitem>
- 
-           <listitem><para>EAP-TTLS/MSCHAPv2</para></listitem>
- 
-           <listitem><para>EAP-TTLS/MSCHAP</para></listitem>
- 
-           <listitem><para>EAP-TTLS/PAP</para></listitem>
- 
-           <listitem><para>EAP-TTLS/CHAP</para></listitem>
- 
-           <listitem><para>EAP-SIM</para></listitem>
- 
-           <listitem><para>EAP-AKA</para></listitem>
- 
-           <listitem><para>EAP-PSK</para></listitem>
- 
-           <listitem><para>EAP-PAX</para></listitem>
- 
-           <listitem><para>LEAP (note: requires special support from
-           the driver for IEEE 802.11 authentication)</para></listitem>
- 
-           <listitem><para>(following methods are supported, but since
-           they do not generate keying material, they cannot be used
-           with WPA or IEEE 802.1X WEP keying)</para></listitem>
- 
-           <listitem><para>EAP-MD5-Challenge </para></listitem>
- 
-           <listitem><para>EAP-MSCHAPv2</para></listitem>
- 
-           <listitem><para>EAP-GTC</para></listitem>
- 
-           <listitem><para>EAP-OTP</para></listitem>
- 	</itemizedlist>
-       </listitem>
- 
-       <listitem>
- 	<para>key management for CCMP, TKIP, WEP104, WEP40</para>
-       </listitem>
- 
-       <listitem>
- 	<para>RSN/WPA2 (IEEE 802.11i)</para>
- 	<itemizedlist>
- 	  <listitem>
- 	    <para>pre-authentication</para>
- 	  </listitem>
- 
- 	  <listitem>
- 	    <para>PMKSA caching</para>
- 	  </listitem>
- 	</itemizedlist>
-       </listitem>
-     </itemizedlist>
-   </refsect1>
- 
-   <refsect1>
-     <title>Available Drivers</title>
-     <para>The available drivers to specify with the -D option are:</para>
- 
-     <variablelist>
-       <varlistentry>
- 	<term>hostap</term>
- 	<listitem>
- 	  <para>(default) Host AP driver (Intersil Prism2/2.5/3).
-   	  (this can also be used with Linuxant DriverLoader).</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>hermes</term>
- 	<listitem>
- 	  <para>Agere Systems Inc. driver (Hermes-I/Hermes-II).</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>madwifi</term>
- 	<listitem>
- 	  <para>MADWIFI 802.11 support (Atheros, etc.).</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>atmel</term>
- 	<listitem>
- 	  <para>ATMEL AT76C5XXx (USB, PCMCIA).</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>wext</term>
- 	<listitem>
- 	  <para>Linux wireless extensions (generic).</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>ndiswrapper</term>
- 	<listitem>
- 	  <para>Linux ndiswrapper.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>broadcom</term>
- 	<listitem>
- 	  <para>Broadcom wl.o driver.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>ipw</term>
- 	<listitem>
- 	  <para>Intel ipw2100/2200 driver.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>wired</term>
- 	<listitem>
- 	  <para>wpa_supplicant wired Ethernet driver</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>bsd</term>
- 	<listitem>
- 	  <para>BSD 802.11 support (Atheros, etc.).</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>ndis</term>
- 	<listitem>
- 	  <para>Windows NDIS driver.</para>
- 	</listitem>
-       </varlistentry>
-     </variablelist>
-   </refsect1>
- 
-   <refsect1>
-     <title>Command Line Options</title>
-     <variablelist>
-       <varlistentry>
- 	<term>-B</term>
- 	<listitem>
- 	  <para>Run daemon in the background.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-i ifname</term>
- 	<listitem>
- 	  <para>Interface to listen on.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-c filename</term>
- 	<listitem>
- 	  <para>Path to configuration file.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-P PID_file</term>
- 	<listitem>
- 	  <para>Path to PID file.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-C ctrl_interface</term>
- 	<listitem>
- 	  <para>Path to ctrl_interface socket (only used if -c is not).</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-g global ctrl_interface</term>
- 	<listitem>
- 	  <para>Path to global ctrl_interface socket.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-D driver</term>
- 	<listitem>
- 	  <para>Driver to use.  See the available options below.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-d</term>
- 	<listitem>
- 	  <para>Increase debugging verbosity (-dd even more).</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-K</term>
- 	<listitem>
- 	  <para>Include keys (passwords, etc.) in debug output.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-t</term>
- 	<listitem>
- 	  <para>Include timestamp in debug messages.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-e</term>
- 	<listitem>
- 	  <para>Use external IEEE 802.1X Supplicant (e.g.,
-           <command>xsupplicant</command>) (this disables the internal
-           Supplicant).</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-h</term>
- 	<listitem>
- 	  <para>Help.  Show a usage message.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-L</term>
- 	<listitem>
- 	  <para>Show license (GPL and BSD).</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-q</term>
- 	<listitem>
- 	  <para>Decrease debugging verbosity (-qq even less).</para>
- 	</listitem>
-       </varlistentry>
-       <varlistentry>
- 	<term>-v</term>
- 	<listitem>
- 	  <para>Show version.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-w</term>
- 	<listitem>
- 	  <para>wait for interface to be added, if needed.  normally,
- 	  <command>wpa_supplicant</command> will exit if the interface
- 	  is not there yet.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>-N</term>
- 	<listitem>
- 	  <para>Start describing new interface.</para>
- 	</listitem>
-       </varlistentry>
-     </variablelist>
-   </refsect1>
- 
-   <refsect1>
-     <title>Examples</title>
- 
-     <para>In most common cases, <command>wpa_supplicant</command> is
-     started with:</para>
- 
- <blockquote><programlisting>
- wpa_supplicant -Bw -c/etc/wpa_supplicant.conf -iwlan0
- </programlisting></blockquote>
- 
-     <para>This makes the process fork into background and wait for the wlan0
-     interface if it is not available at startup time.</para>
- 
-     <para>The easiest way to debug problems, and to get debug log for
-     bug reports, is to start <command>wpa_supplicant</command> on
-     foreground with debugging enabled:</para>
- 
- <blockquote><programlisting>
- wpa_supplicant -c/etc/wpa_supplicant.conf -iwlan0 -d
- </programlisting></blockquote>
- 
-     <para><command>wpa_supplicant</command> can control multiple
-     interfaces (radios) either by running one process for each
-     interface separately or by running just one process and list of
-     options at command line. Each interface is separated with -N
-     argument. As an example, following command would start
-     wpa_supplicant for two interfaces:</para>
- 
- <blockquote><programlisting>
- wpa_supplicant \
- 	-c wpa1.conf -i wlan0 -D hostap -N \
- 	-c wpa2.conf -i ath0 -D madwifi
- </programlisting></blockquote>
-   </refsect1>
- 
-   <refsect1>
-     <title>OS Requirements</title>
-     <para>Current hardware/software requirements:</para>
- 
-     <itemizedlist>
-       <listitem>
- 	<para>Linux kernel 2.4.x or 2.6.x with Linux Wireless
- 	Extensions v15 or newer</para>
-       </listitem>
- 
- 
-       <listitem>
- 	<para>FreeBSD 6-CURRENT</para>
-       </listitem>
- 
-       <listitem>
- 	<para>Microsoft Windows with WinPcap (at least WinXP, may work
- 	with other versions)</para>
-       </listitem>
-     </itemizedlist>
-   </refsect1>
- 
-   <refsect1>
-     <title>Supported Drivers</title>
-     <variablelist>
-       <varlistentry>
- 	<term>Host AP driver for Prism2/2.5/3 (development
- 	snapshot/v0.2.x)</term>
- 	<listitem>
- 	  <para> (http://hostap.epitest.fi/) Driver needs to be set in
- 	Managed mode ('iwconfig wlan0 mode managed').  Please note
- 	that station firmware version needs to be 1.7.0 or newer to
- 	work in WPA mode.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>Linuxant DriverLoader</term>
- 	<listitem>
- 	  <para>(http://www.linuxant.com/driverloader/)
- 	with Windows NDIS driver for your wlan card supporting WPA.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>Agere Systems Inc. Linux Driver</term>
- 	<listitem>
- 	  <para> (http://www.agere.com/support/drivers/) Please note
- 	that the driver interface file (driver_hermes.c) and hardware
- 	specific include files are not included in the wpa_supplicant
- 	distribution. You will need to copy these from the source
- 	package of the Agere driver.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>madwifi driver for cards based on Atheros chip set (ar521x)</term>
- 	<listitem>
- 	  <para> (http://sourceforge.net/projects/madwifi/) Please
- 	note that you will need to modify the wpa_supplicant .config
- 	file to use the correct path for the madwifi driver root
- 	directory (CFLAGS += -I../madwifi/wpa line in example
- 	defconfig).</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>ATMEL AT76C5XXx driver for USB and PCMCIA cards</term>
- 	<listitem>
- 	  <para> (http://atmelwlandriver.sourceforge.net/).</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>Linux ndiswrapper</term>
- 	<listitem>
- 	  <para> (http://ndiswrapper.sourceforge.net/) with Windows
- 	NDIS driver.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>Broadcom wl.o driver</term>
- 	<listitem>
- 	  <para> This is a generic Linux driver for Broadcom IEEE
- 	802.11a/g cards.  However, it is proprietary driver that is
- 	not publicly available except for couple of exceptions, mainly
- 	Broadcom-based APs/wireless routers that use Linux. The driver
- 	binary can be downloaded, e.g., from Linksys support site
- 	(http://www.linksys.com/support/gpl.asp) for Linksys
- 	WRT54G. The GPL tarball includes cross-compiler and the needed
- 	header file, wlioctl.h, for compiling wpa_supplicant.  This
- 	driver support in wpa_supplicant is expected to work also with
- 	other devices based on Broadcom driver (assuming the driver
- 	includes client mode support).</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term> Intel ipw2100 driver</term>
- 	<listitem>
- 	  <para> (http://sourceforge.net/projects/ipw2100/)</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>Intel ipw2200 driver</term>
- 	<listitem>
- 	  <para> (http://sourceforge.net/projects/ipw2200/)</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>Linux wireless extensions</term>
- 	<listitem>
- 	  <para>In theory, any driver that supports Linux wireless
- 	extensions can be used with IEEE 802.1X (i.e., not WPA) when
- 	using ap_scan=0 option in configuration file.</para>
- 	</listitem>
-       </varlistentry>
-       
-       <varlistentry>
- 	<term>Wired Ethernet drivers</term>
- 	<listitem>
- 	  <para>Use ap_scan=0.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>BSD net80211 layer (e.g., Atheros driver)</term>
- 	<listitem>
- 	  <para>At the moment, this is for FreeBSD 6-CURRENT branch.</para>
- 	</listitem>
-       </varlistentry>
- 
-       <varlistentry>
- 	<term>Windows NDIS</term>
- 	<listitem>
- 	  <para>The current Windows port requires WinPcap
- 	(http://winpcap.polito.it/).  See README-Windows.txt for more
- 	information.</para>
- 	</listitem>
-       </varlistentry>
-     </variablelist>
- 
- 	
-     <para>wpa_supplicant was designed to be portable for different
-     drivers and operating systems. Hopefully, support for more wlan
-     cards and OSes will be added in the future. See developer.txt for
-     more information about the design of wpa_supplicant and porting to
-     other drivers. One main goal is to add full WPA/WPA2 support to
-     Linux wireless extensions to allow new drivers to be supported
-     without having to implement new driver-specific interface code in
-     wpa_supplicant.</para>
-   </refsect1>
- 
-   <refsect1>
-     <title>Architecture</title> <para>The
-     <command>wpa_supplicant</command> system consists of the following
-     components:</para>
- 
-     <variablelist>
-       <varlistentry>
- 	<term><filename>wpa_supplicant.conf</filename> </term>
- 	<listitem>
-         <para>the configuration file describing all networks that the
-         user wants the computer to connect to.  </para>
- 	</listitem>
-       </varlistentry>
-       <varlistentry>
- 	<term><command>wpa_supplicant</command></term>
-         <listitem><para>the program that directly interacts with the
-         network interface.  </para></listitem>
-       </varlistentry>
-       <varlistentry>
- 	<term><command>wpa_cli</command></term> <listitem><para> the
- 	client program that provides a high-level interface to the
- 	functionality of the daemon.  </para></listitem>
-       </varlistentry>
-       <varlistentry>
- 	<term><command>wpa_passphrase</command></term>
-         <listitem><para>a utility needed to construct
-         <filename>wpa_supplicant.conf</filename> files that include
-         encrypted passwords.</para></listitem>
-       </varlistentry>
-     </variablelist>
-   </refsect1>
- 
-   <refsect1>
-     <title>Quick Start</title>
- 
-     <para>First, make a configuration file, e.g.
-     <filename>/etc/wpa_supplicant.conf</filename>, that describes the networks
-     you are interested in.  See <citerefentry>
- 	<refentrytitle>wpa_supplicant.conf</refentrytitle>
- 	<manvolnum>5</manvolnum>
-       </citerefentry>
-     for details.</para>
- 
-     <para>Once the configuration is ready, you can test whether the
-     configuration works by running <command>wpa_supplicant</command>
-     with following command to start it on foreground with debugging
-     enabled:</para>
- 
-     <blockquote><programlisting>
- wpa_supplicant -iwlan0 -c/etc/wpa_supplicant.conf -d
-     </programlisting></blockquote>
- 
-     <para>Assuming everything goes fine, you can start using following
-     command to start <command>wpa_supplicant</command> on background
-     without debugging:</para>
- 
-     <blockquote><programlisting>
- wpa_supplicant -iwlan0 -c/etc/wpa_supplicant.conf -B
-     </programlisting></blockquote>
- 
-     <para>Please note that if you included more than one driver
-     interface in the build time configuration (.config), you may need
-     to specify which interface to use by including -D&lt;driver
-     name&gt; option on the command line.</para>
- 
-     <!-- XXX at this point, the page could include a little script
-          based on wpa_cli to wait for a connection and then run
-          dhclient -->
- 
-   </refsect1>
- 
-   <refsect1>
-     <title>Interface to pcmcia-cs/cardmrg</title>
- 
-     <para>For example, following small changes to pcmcia-cs scripts
-     can be used to enable WPA support:</para>
- 
-     <para>Add MODE="Managed" and WPA="y" to the network scheme in
-     <filename>/etc/pcmcia/wireless.opts</filename>.</para>
- 
-     <para>Add the following block to the end of 'start' action handler
-     in <filename>/etc/pcmcia/wireless</filename>:</para>
- 
-     <blockquote><programlisting>
- if [ "$WPA" = "y" -a -x /usr/local/bin/wpa_supplicant ]; then
-     /usr/local/bin/wpa_supplicant -Bw -c/etc/wpa_supplicant.conf -i$DEVICE
- fi
-     </programlisting></blockquote>
- 
- 
-     <para>Add the following block to the end of 'stop' action handler
-     (may need to be separated from other actions) in
-     <filename>/etc/pcmcia/wireless</filename>:</para>
- 
-     <blockquote><programlisting>
- if [ "$WPA" = "y" -a -x /usr/local/bin/wpa_supplicant ]; then
-     killall wpa_supplicant
- fi
-     </programlisting></blockquote>
- 
-     <para>This will make <command>cardmgr</command> start
-     <command>wpa_supplicant</command> when the card is plugged
-     in. <command>wpa_supplicant</command> will wait until the
-     interface is set up--either when a static IP address is configured
-     or when DHCP client is started--and will then negotiate keys with
-     the AP.</para>
-   </refsect1>
- 
-   <refsect1>
-     <title>See Also</title>
-     <para>
-       <citerefentry>
- 	<refentrytitle>wpa_background</refentrytitle>
- 	<manvolnum>8</manvolnum>
-       </citerefentry>
-       <citerefentry>
- 	<refentrytitle>wpa_supplicant.conf</refentrytitle>
- 	<manvolnum>5</manvolnum>
-       </citerefentry>
-       <citerefentry>
- 	<refentrytitle>wpa_cli</refentrytitle>
- 	<manvolnum>8</manvolnum>
-       </citerefentry>
-       <citerefentry>
- 	<refentrytitle>wpa_passphrase</refentrytitle>
- 	<manvolnum>8</manvolnum>
-       </citerefentry>
-     </para>
-   </refsect1>
-   <refsect1>
-     <title>Legal</title>
-     <para>wpa_supplicant is copyright (c) 2003-2005,
-     Jouni Malinen <email>jkmaline@cc.hut.fi</email> and
-     contributors.
-     All Rights Reserved.</para>
- 
-     <para>This program is dual-licensed under both the GPL version 2
-     and BSD license. Either license may be used at your option.</para>
-   </refsect1>
- </refentry>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/doxygen.fast wpa_view/wpa_suppl/doc/doxygen.fast
*** wpa_supplicant-0.5.7/doc/doxygen.fast	Thu Feb 23 06:22:44 2006
--- wpa_view/wpa_suppl/doc/doxygen.fast	Thu Jan  1 02:00:00 1970
***************
*** 1,243 ****
- # Doxyfile 1.4.1
- 
- #---------------------------------------------------------------------------
- # Project related configuration options
- #---------------------------------------------------------------------------
- PROJECT_NAME           = wpa_supplicant
- PROJECT_NUMBER         = 0.5.x
- OUTPUT_DIRECTORY       = doc
- CREATE_SUBDIRS         = NO
- OUTPUT_LANGUAGE        = English
- USE_WINDOWS_ENCODING   = NO
- BRIEF_MEMBER_DESC      = YES
- REPEAT_BRIEF           = YES
- ABBREVIATE_BRIEF       = "The $name class" \
-                          "The $name widget" \
-                          "The $name file" \
-                          is \
-                          provides \
-                          specifies \
-                          contains \
-                          represents \
-                          a \
-                          an \
-                          the
- ALWAYS_DETAILED_SEC    = NO
- INLINE_INHERITED_MEMB  = NO
- FULL_PATH_NAMES        = YES
- STRIP_FROM_PATH        =
- STRIP_FROM_INC_PATH    = 
- SHORT_NAMES            = NO
- JAVADOC_AUTOBRIEF      = NO
- MULTILINE_CPP_IS_BRIEF = NO
- DETAILS_AT_TOP         = NO
- INHERIT_DOCS           = YES
- DISTRIBUTE_GROUP_DOC   = NO
- TAB_SIZE               = 8
- ALIASES                = 
- OPTIMIZE_OUTPUT_FOR_C  = YES
- OPTIMIZE_OUTPUT_JAVA   = NO
- SUBGROUPING            = YES
- #---------------------------------------------------------------------------
- # Build related configuration options
- #---------------------------------------------------------------------------
- EXTRACT_ALL            = NO
- EXTRACT_PRIVATE        = NO
- EXTRACT_STATIC         = NO
- EXTRACT_LOCAL_CLASSES  = YES
- EXTRACT_LOCAL_METHODS  = NO
- HIDE_UNDOC_MEMBERS     = NO
- HIDE_UNDOC_CLASSES     = NO
- HIDE_FRIEND_COMPOUNDS  = NO
- HIDE_IN_BODY_DOCS      = NO
- INTERNAL_DOCS          = NO
- CASE_SENSE_NAMES       = YES
- HIDE_SCOPE_NAMES       = NO
- SHOW_INCLUDE_FILES     = YES
- INLINE_INFO            = YES
- SORT_MEMBER_DOCS       = YES
- SORT_BRIEF_DOCS        = NO
- SORT_BY_SCOPE_NAME     = NO
- GENERATE_TODOLIST      = YES
- GENERATE_TESTLIST      = YES
- GENERATE_BUGLIST       = YES
- GENERATE_DEPRECATEDLIST= YES
- ENABLED_SECTIONS       = 
- MAX_INITIALIZER_LINES  = 30
- SHOW_USED_FILES        = YES
- SHOW_DIRECTORIES       = NO
- FILE_VERSION_FILTER    = 
- #---------------------------------------------------------------------------
- # configuration options related to warning and progress messages
- #---------------------------------------------------------------------------
- QUIET                  = NO
- WARNINGS               = YES
- WARN_IF_UNDOCUMENTED   = YES
- WARN_IF_DOC_ERROR      = YES
- WARN_NO_PARAMDOC       = YES
- WARN_FORMAT            = "$file:$line: $text"
- WARN_LOGFILE           = 
- #---------------------------------------------------------------------------
- # configuration options related to the input files
- #---------------------------------------------------------------------------
- INPUT                  = . \
- 	../hostapd/aes.c \
- 	../hostapd/rc4.c \
- 	../hostapd/rc4.h \
- 	../hostapd/md5.c \
- 	../hostapd/md5.h \
- 	../hostapd/sha1.c \
- 	../hostapd/sha1.h \
- 	../hostapd/common.c \
- 	../hostapd/common.h \
- 	../hostapd/eloop.c \
- 	../hostapd/eloop.h \
- 	../hostapd/aes_wrap.c \
- 	../hostapd/aes_wrap.h
- FILE_PATTERNS          = *.c *.h *.doxygen
- RECURSIVE              = YES
- EXCLUDE                = 
- EXCLUDE_SYMLINKS       = NO
- EXCLUDE_PATTERNS       = 
- EXAMPLE_PATH           = 
- EXAMPLE_PATTERNS       = *
- EXAMPLE_RECURSIVE      = NO
- IMAGE_PATH             = doc
- INPUT_FILTER           = kerneldoc2doxygen.pl
- FILTER_PATTERNS        = 
- FILTER_SOURCE_FILES    = YES
- #---------------------------------------------------------------------------
- # configuration options related to source browsing
- #---------------------------------------------------------------------------
- SOURCE_BROWSER         = YES
- INLINE_SOURCES         = NO
- STRIP_CODE_COMMENTS    = YES
- REFERENCED_BY_RELATION = NO
- REFERENCES_RELATION    = NO
- VERBATIM_HEADERS       = NO
- #---------------------------------------------------------------------------
- # configuration options related to the alphabetical class index
- #---------------------------------------------------------------------------
- ALPHABETICAL_INDEX     = YES
- COLS_IN_ALPHA_INDEX    = 3
- IGNORE_PREFIX          = 
- #---------------------------------------------------------------------------
- # configuration options related to the HTML output
- #---------------------------------------------------------------------------
- GENERATE_HTML          = YES
- HTML_OUTPUT            = html
- HTML_FILE_EXTENSION    = .html
- HTML_HEADER            = 
- HTML_FOOTER            = 
- HTML_STYLESHEET        = 
- HTML_ALIGN_MEMBERS     = YES
- GENERATE_HTMLHELP      = NO
- CHM_FILE               = 
- HHC_LOCATION           = 
- GENERATE_CHI           = NO
- BINARY_TOC             = NO
- TOC_EXPAND             = NO
- DISABLE_INDEX          = NO
- ENUM_VALUES_PER_LINE   = 4
- GENERATE_TREEVIEW      = NO
- TREEVIEW_WIDTH         = 250
- #---------------------------------------------------------------------------
- # configuration options related to the LaTeX output
- #---------------------------------------------------------------------------
- GENERATE_LATEX         = NO
- LATEX_OUTPUT           = latex
- LATEX_CMD_NAME         = latex
- MAKEINDEX_CMD_NAME     = makeindex
- COMPACT_LATEX          = NO
- PAPER_TYPE             = a4wide
- EXTRA_PACKAGES         = 
- LATEX_HEADER           = 
- PDF_HYPERLINKS         = YES
- USE_PDFLATEX           = YES
- LATEX_BATCHMODE        = NO
- LATEX_HIDE_INDICES     = NO
- #---------------------------------------------------------------------------
- # configuration options related to the RTF output
- #---------------------------------------------------------------------------
- GENERATE_RTF           = NO
- RTF_OUTPUT             = rtf
- COMPACT_RTF            = NO
- RTF_HYPERLINKS         = NO
- RTF_STYLESHEET_FILE    = 
- RTF_EXTENSIONS_FILE    = 
- #---------------------------------------------------------------------------
- # configuration options related to the man page output
- #---------------------------------------------------------------------------
- GENERATE_MAN           = NO
- MAN_OUTPUT             = man
- MAN_EXTENSION          = .3
- MAN_LINKS              = NO
- #---------------------------------------------------------------------------
- # configuration options related to the XML output
- #---------------------------------------------------------------------------
- GENERATE_XML           = NO
- XML_OUTPUT             = xml
- XML_SCHEMA             = 
- XML_DTD                = 
- XML_PROGRAMLISTING     = YES
- #---------------------------------------------------------------------------
- # configuration options for the AutoGen Definitions output
- #---------------------------------------------------------------------------
- GENERATE_AUTOGEN_DEF   = NO
- #---------------------------------------------------------------------------
- # configuration options related to the Perl module output
- #---------------------------------------------------------------------------
- GENERATE_PERLMOD       = NO
- PERLMOD_LATEX          = NO
- PERLMOD_PRETTY         = YES
- PERLMOD_MAKEVAR_PREFIX = 
- #---------------------------------------------------------------------------
- # Configuration options related to the preprocessor   
- #---------------------------------------------------------------------------
- ENABLE_PREPROCESSING   = YES
- MACRO_EXPANSION        = NO
- EXPAND_ONLY_PREDEF     = NO
- SEARCH_INCLUDES        = YES
- INCLUDE_PATH           = 
- INCLUDE_FILE_PATTERNS  = 
- PREDEFINED             = IEEE8021X_EAPOL
- EXPAND_AS_DEFINED      = 
- SKIP_FUNCTION_MACROS   = YES
- #---------------------------------------------------------------------------
- # Configuration::additions related to external references   
- #---------------------------------------------------------------------------
- TAGFILES               = 
- GENERATE_TAGFILE       = 
- ALLEXTERNALS           = NO
- EXTERNAL_GROUPS        = YES
- PERL_PATH              = /usr/bin/perl
- #---------------------------------------------------------------------------
- # Configuration options related to the dot tool   
- #---------------------------------------------------------------------------
- CLASS_DIAGRAMS         = NO
- HIDE_UNDOC_RELATIONS   = YES
- HAVE_DOT               = NO
- CLASS_GRAPH            = YES
- COLLABORATION_GRAPH    = YES
- GROUP_GRAPHS           = YES
- UML_LOOK               = NO
- TEMPLATE_RELATIONS     = NO
- INCLUDE_GRAPH          = YES
- INCLUDED_BY_GRAPH      = YES
- CALL_GRAPH             = YES
- GRAPHICAL_HIERARCHY    = YES
- DIRECTORY_GRAPH        = NO
- DOT_IMAGE_FORMAT       = png
- DOT_PATH               = 
- DOTFILE_DIRS           = 
- MAX_DOT_GRAPH_WIDTH    = 1024
- MAX_DOT_GRAPH_HEIGHT   = 1024
- MAX_DOT_GRAPH_DEPTH    = 1000
- DOT_TRANSPARENT        = NO
- DOT_MULTI_TARGETS      = NO
- GENERATE_LEGEND        = YES
- DOT_CLEANUP            = YES
- #---------------------------------------------------------------------------
- # Configuration::additions related to the search engine   
- #---------------------------------------------------------------------------
- SEARCHENGINE           = NO
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/doxygen.full wpa_view/wpa_suppl/doc/doxygen.full
*** wpa_supplicant-0.5.7/doc/doxygen.full	Sat Feb 25 20:55:17 2006
--- wpa_view/wpa_suppl/doc/doxygen.full	Thu Jan  1 02:00:00 1970
***************
*** 1,230 ****
- # Doxyfile 1.4.1
- 
- #---------------------------------------------------------------------------
- # Project related configuration options
- #---------------------------------------------------------------------------
- PROJECT_NAME           = wpa_supplicant
- PROJECT_NUMBER         = 0.5.x
- OUTPUT_DIRECTORY       = doc
- CREATE_SUBDIRS         = NO
- OUTPUT_LANGUAGE        = English
- USE_WINDOWS_ENCODING   = NO
- BRIEF_MEMBER_DESC      = YES
- REPEAT_BRIEF           = YES
- ABBREVIATE_BRIEF       = "The $name class" \
-                          "The $name widget" \
-                          "The $name file" \
-                          is \
-                          provides \
-                          specifies \
-                          contains \
-                          represents \
-                          a \
-                          an \
-                          the
- ALWAYS_DETAILED_SEC    = NO
- INLINE_INHERITED_MEMB  = NO
- FULL_PATH_NAMES        = YES
- STRIP_FROM_PATH        =
- STRIP_FROM_INC_PATH    = 
- SHORT_NAMES            = NO
- JAVADOC_AUTOBRIEF      = NO
- MULTILINE_CPP_IS_BRIEF = NO
- DETAILS_AT_TOP         = NO
- INHERIT_DOCS           = YES
- DISTRIBUTE_GROUP_DOC   = NO
- TAB_SIZE               = 8
- ALIASES                = 
- OPTIMIZE_OUTPUT_FOR_C  = YES
- OPTIMIZE_OUTPUT_JAVA   = NO
- SUBGROUPING            = YES
- #---------------------------------------------------------------------------
- # Build related configuration options
- #---------------------------------------------------------------------------
- EXTRACT_ALL            = NO
- EXTRACT_PRIVATE        = NO
- EXTRACT_STATIC         = NO
- EXTRACT_LOCAL_CLASSES  = YES
- EXTRACT_LOCAL_METHODS  = NO
- HIDE_UNDOC_MEMBERS     = NO
- HIDE_UNDOC_CLASSES     = NO
- HIDE_FRIEND_COMPOUNDS  = NO
- HIDE_IN_BODY_DOCS      = NO
- INTERNAL_DOCS          = NO
- CASE_SENSE_NAMES       = YES
- HIDE_SCOPE_NAMES       = NO
- SHOW_INCLUDE_FILES     = YES
- INLINE_INFO            = YES
- SORT_MEMBER_DOCS       = YES
- SORT_BRIEF_DOCS        = NO
- SORT_BY_SCOPE_NAME     = NO
- GENERATE_TODOLIST      = YES
- GENERATE_TESTLIST      = YES
- GENERATE_BUGLIST       = YES
- GENERATE_DEPRECATEDLIST= YES
- ENABLED_SECTIONS       = 
- MAX_INITIALIZER_LINES  = 30
- SHOW_USED_FILES        = YES
- SHOW_DIRECTORIES       = NO
- FILE_VERSION_FILTER    = 
- #---------------------------------------------------------------------------
- # configuration options related to warning and progress messages
- #---------------------------------------------------------------------------
- QUIET                  = NO
- WARNINGS               = YES
- WARN_IF_UNDOCUMENTED   = YES
- WARN_IF_DOC_ERROR      = YES
- WARN_NO_PARAMDOC       = YES
- WARN_FORMAT            = "$file:$line: $text"
- WARN_LOGFILE           = 
- #---------------------------------------------------------------------------
- # configuration options related to the input files
- #---------------------------------------------------------------------------
- INPUT                  = .
- FILE_PATTERNS          = *.c *.h *.doxygen
- RECURSIVE              = YES
- EXCLUDE                = 
- EXCLUDE_SYMLINKS       = NO
- EXCLUDE_PATTERNS       = 
- EXAMPLE_PATH           = 
- EXAMPLE_PATTERNS       = *
- EXAMPLE_RECURSIVE      = NO
- IMAGE_PATH             = doc
- INPUT_FILTER           = kerneldoc2doxygen.pl
- FILTER_PATTERNS        = 
- FILTER_SOURCE_FILES    = YES
- #---------------------------------------------------------------------------
- # configuration options related to source browsing
- #---------------------------------------------------------------------------
- SOURCE_BROWSER         = YES
- INLINE_SOURCES         = NO
- STRIP_CODE_COMMENTS    = YES
- REFERENCED_BY_RELATION = NO
- REFERENCES_RELATION    = NO
- VERBATIM_HEADERS       = NO
- #---------------------------------------------------------------------------
- # configuration options related to the alphabetical class index
- #---------------------------------------------------------------------------
- ALPHABETICAL_INDEX     = YES
- COLS_IN_ALPHA_INDEX    = 3
- IGNORE_PREFIX          = 
- #---------------------------------------------------------------------------
- # configuration options related to the HTML output
- #---------------------------------------------------------------------------
- GENERATE_HTML          = YES
- HTML_OUTPUT            = html
- HTML_FILE_EXTENSION    = .html
- HTML_HEADER            = 
- HTML_FOOTER            = 
- HTML_STYLESHEET        = 
- HTML_ALIGN_MEMBERS     = YES
- GENERATE_HTMLHELP      = NO
- CHM_FILE               = 
- HHC_LOCATION           = 
- GENERATE_CHI           = NO
- BINARY_TOC             = NO
- TOC_EXPAND             = NO
- DISABLE_INDEX          = NO
- ENUM_VALUES_PER_LINE   = 4
- GENERATE_TREEVIEW      = NO
- TREEVIEW_WIDTH         = 250
- #---------------------------------------------------------------------------
- # configuration options related to the LaTeX output
- #---------------------------------------------------------------------------
- GENERATE_LATEX         = YES
- LATEX_OUTPUT           = latex
- LATEX_CMD_NAME         = latex
- MAKEINDEX_CMD_NAME     = makeindex
- COMPACT_LATEX          = NO
- PAPER_TYPE             = a4wide
- EXTRA_PACKAGES         = 
- LATEX_HEADER           = 
- PDF_HYPERLINKS         = YES
- USE_PDFLATEX           = YES
- LATEX_BATCHMODE        = NO
- LATEX_HIDE_INDICES     = NO
- #---------------------------------------------------------------------------
- # configuration options related to the RTF output
- #---------------------------------------------------------------------------
- GENERATE_RTF           = NO
- RTF_OUTPUT             = rtf
- COMPACT_RTF            = NO
- RTF_HYPERLINKS         = NO
- RTF_STYLESHEET_FILE    = 
- RTF_EXTENSIONS_FILE    = 
- #---------------------------------------------------------------------------
- # configuration options related to the man page output
- #---------------------------------------------------------------------------
- GENERATE_MAN           = NO
- MAN_OUTPUT             = man
- MAN_EXTENSION          = .3
- MAN_LINKS              = NO
- #---------------------------------------------------------------------------
- # configuration options related to the XML output
- #---------------------------------------------------------------------------
- GENERATE_XML           = NO
- XML_OUTPUT             = xml
- XML_SCHEMA             = 
- XML_DTD                = 
- XML_PROGRAMLISTING     = YES
- #---------------------------------------------------------------------------
- # configuration options for the AutoGen Definitions output
- #---------------------------------------------------------------------------
- GENERATE_AUTOGEN_DEF   = NO
- #---------------------------------------------------------------------------
- # configuration options related to the Perl module output
- #---------------------------------------------------------------------------
- GENERATE_PERLMOD       = NO
- PERLMOD_LATEX          = NO
- PERLMOD_PRETTY         = YES
- PERLMOD_MAKEVAR_PREFIX = 
- #---------------------------------------------------------------------------
- # Configuration options related to the preprocessor   
- #---------------------------------------------------------------------------
- ENABLE_PREPROCESSING   = YES
- MACRO_EXPANSION        = NO
- EXPAND_ONLY_PREDEF     = NO
- SEARCH_INCLUDES        = YES
- INCLUDE_PATH           = 
- INCLUDE_FILE_PATTERNS  = 
- PREDEFINED             = IEEE8021X_EAPOL CONFIG_CTRL_IFACE
- EXPAND_AS_DEFINED      = 
- SKIP_FUNCTION_MACROS   = YES
- #---------------------------------------------------------------------------
- # Configuration::additions related to external references   
- #---------------------------------------------------------------------------
- TAGFILES               = 
- GENERATE_TAGFILE       = 
- ALLEXTERNALS           = NO
- EXTERNAL_GROUPS        = YES
- PERL_PATH              = /usr/bin/perl
- #---------------------------------------------------------------------------
- # Configuration options related to the dot tool   
- #---------------------------------------------------------------------------
- CLASS_DIAGRAMS         = NO
- HIDE_UNDOC_RELATIONS   = YES
- HAVE_DOT               = YES
- CLASS_GRAPH            = YES
- COLLABORATION_GRAPH    = YES
- GROUP_GRAPHS           = YES
- UML_LOOK               = NO
- TEMPLATE_RELATIONS     = NO
- INCLUDE_GRAPH          = YES
- INCLUDED_BY_GRAPH      = YES
- CALL_GRAPH             = YES
- GRAPHICAL_HIERARCHY    = YES
- DIRECTORY_GRAPH        = NO
- DOT_IMAGE_FORMAT       = png
- DOT_PATH               = 
- DOTFILE_DIRS           = 
- MAX_DOT_GRAPH_WIDTH    = 1024
- MAX_DOT_GRAPH_HEIGHT   = 1024
- MAX_DOT_GRAPH_DEPTH    = 1000
- DOT_TRANSPARENT        = NO
- DOT_MULTI_TARGETS      = NO
- GENERATE_LEGEND        = YES
- DOT_CLEANUP            = YES
- #---------------------------------------------------------------------------
- # Configuration::additions related to the search engine   
- #---------------------------------------------------------------------------
- SEARCHENGINE           = YES
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/driver_wrapper.doxygen wpa_view/wpa_suppl/doc/driver_wrapper.doxygen
*** wpa_supplicant-0.5.7/doc/driver_wrapper.doxygen	Tue Nov 22 06:16:02 2005
--- wpa_view/wpa_suppl/doc/driver_wrapper.doxygen	Thu Jan  1 02:00:00 1970
***************
*** 1,180 ****
- /**
- \page driver_wrapper Driver wrapper implementation (driver.h, drivers.c)
- 
- All hardware and driver dependent functionality is in separate C files
- that implement defined wrapper functions. Other parts
- of the %wpa_supplicant are designed to be hardware, driver, and operating
- system independent.
- 
- Driver wrappers need to implement whatever calls are used in the
- target operating system/driver for controlling wireless LAN
- devices. As an example, in case of Linux, these are mostly some glue
- code and ioctl() calls and netlink message parsing for Linux Wireless
- Extensions (WE). Since features required for WPA were added only recently to
- Linux Wireless Extensions (in version 18), some driver specific code is used
- in number of driver interface implementations. These driver dependent parts
- can be replaced with generic code in driver_wext.c once the target driver
- includes full support for WE-18. After that, all Linux drivers, at
- least in theory, could use the same driver wrapper code.
- 
- A driver wrapper needs to implement some or all of the functions
- defined in driver.h. These functions are registered by filling struct
- wpa_driver_ops with function pointers. Hardware independent parts of
- %wpa_supplicant will call these functions to control the driver/wlan
- card. In addition, support for driver events is required. The event
- callback function, wpa_supplicant_event(), and its parameters are
- documented in wpa_supplicant.h. In addition, a pointer to the 'struct
- wpa_driver_ops' needs to be registered in drivers.c file.
- 
- When porting to other operating systems, the driver wrapper should be
- modified to use the native interface of the target OS. It is possible
- that some extra requirements for the interface between the driver
- wrapper and generic %wpa_supplicant code are discovered during porting
- to a new operating system. These will be addressed on case by case
- basis by modifying the interface and updating the other driver
- wrappers for this. The goal is to avoid changing this interface
- without very good reasons in order to limit the number of changes
- needed to other wrappers and hardware independent parts of
- %wpa_supplicant. When changes are required, recommended way is to
- make them in backwards compatible way that allows existing driver
- interface implementations to be compiled without any modification.
- 
- Generic Linux Wireless Extensions functions are implemented in
- driver_wext.c. All Linux driver wrappers can use these when the kernel
- driver supports the generic ioctl()s and wireless events. Driver
- specific functions are implemented in separate C files, e.g.,
- driver_hostap.c. These files need to define struct wpa_driver_ops
- entry that will be used in wpa_supplicant.c when calling driver
- functions. struct wpa_driver_ops entries are registered in drivers.c.
- 
- In general, it is likely to be useful to first take a look at couple
- of driver interface examples before starting on implementing a new
- one. driver_hostap.c and driver_wext.c include a complete
- implementation for Linux drivers that use %wpa_supplicant-based control
- of WPA IE and roaming. driver_ndis.c (with help from driver_ndis_.c)
- is an example of a complete interface for Windows NDIS interface for
- drivers that generate WPA IE themselves and decide when to roam. These
- example implementations include full support for all security modes.
- 
- 
- \section driver_req Driver requirements for WPA
- 
- WPA introduces new requirements for the device driver. At least some
- of these need to be implemented in order to provide enough support for
- %wpa_supplicant.
- 
- \subsection driver_tkip_ccmp TKIP/CCMP
- 
- WPA requires that the pairwise cipher suite (encryption algorithm for
- unicast data packets) is TKIP or CCMP. These are new encryption
- protocols and thus, the driver will need to be modified to support
- them. Depending on the used wlan hardware, some parts of these may be
- implemented by the hardware/firmware.
- 
- Specification for both TKIP and CCMP is available from IEEE (IEEE
- 802.11i amendment). Fully functional, hardware independent
- implementation of both encryption protocols is also available in Host
- AP driver (driver/modules/hostap_{tkip,ccmp}.c). In addition, Linux 2.6
- kernel tree has generic implementations for WEP, TKIP, and CCMP that can
- be used in Linux drivers.
- 
- The driver will also need to provide configuration mechanism to allow
- user space programs to configure TKIP and CCMP. Linux Wireless Extensions
- v18 added support for configuring these algorithms and
- individual/non-default keys. If the target kernel does not include WE-18,
- private ioctls can be used to provide similar functionality.
- 
- \subsection driver_roaming Roaming control and scanning support
- 
- %wpa_supplicant can optionally control AP selection based on the
- information received from Beacon and/or Probe Response frames
- (ap_scan=1 mode in configuration). This means that the driver should
- support external control for scan process. In case of Linux, use of
- new Wireless Extensions scan support (i.e., 'iwlist wlan0 scan') is
- recommended. The current driver wrapper (driver_wext.c) uses this for
- scan results.
- 
- Scan results must also include the WPA information element. Support for
- this was added in WE-18. With older versions, a custom event can be used
- to provide the full WPA IE (including element id and length) as a hex
- string that is included in the scan results.
- 
- %wpa_supplicant needs to also be able to request the driver to
- associate with a specific BSS. Current Host AP driver and matching
- driver_hostap.c wrapper uses following sequence for this
- request. Similar/identical mechanism should be usable also with other
- drivers.
- 
- - set WPA IE for AssocReq with private ioctl
- - set SSID with SIOCSIWESSID
- - set channel/frequency with SIOCSIWFREQ
- - set BSSID with SIOCSIWAP
-   (this last ioctl will trigger the driver to request association)
- 
- \subsection driver_wpa_ie WPA IE generation
- 
- %wpa_supplicant selects which cipher suites and key management suites
- are used. Based on this information, it generates a WPA IE. This is
- provided to the driver interface in the associate call. This does not
- match with Windows NDIS drivers which generate the WPA IE
- themselves.
- 
- %wpa_supplicant allows Windows NDIS-like behavior by providing the
- selected cipher and key management suites in the associate call. If
- the driver generates its own WPA IE and that differs from the one
- generated by %wpa_supplicant, the driver has to inform %wpa_supplicant
- about the used WPA IE (i.e., the one it used in (Re)Associate
- Request). This notification is done using EVENT_ASSOCINFO event (see
- wpa_supplicant.h). %wpa_supplicant is normally configured to use
- ap_scan=2 mode with drivers that control WPA IE generation and roaming.
- 
- \subsection driver_events Driver events
- 
- %wpa_supplicant needs to receive event callbacks when certain events
- occur (association, disassociation, Michael MIC failure, scan results
- available, PMKSA caching candidate). These events and the callback
- details are defined in wpa_supplicant.h (wpa_supplicant_event() function
- and enum wpa_event_type).
- 
- On Linux, association and disassociation can use existing Wireless
- Extensions event that is reporting new AP with SIOCGIWAP
- event. Similarly, completion of a scan can be reported with SIOCGIWSCAN
- event.
- 
- Michael MIC failure event was added in WE-18. Older versions of Wireless
- Extensions will need to use a custom event. Host AP driver used a custom
- event with following contents: MLME-MICHAELMICFAILURE.indication(keyid=#
- broadcast/unicast addr=addr2). This is the recommended format until
- the driver can be moved to use WE-18 mechanism.
- 
- \subsection driver_wext_summary Summary of Linux Wireless Extensions use
- 
- AP selection depends on ap_scan configuration:
- 
- ap_scan=1:
- 
- - %wpa_supplicant requests scan with SIOCSIWSCAN
- - driver reports scan complete with wireless event SIOCGIWSCAN
- - %wpa_supplicant reads scan results with SIOCGIWSCAN (multiple call if
-   a larget buffer is needed)
- - %wpa_supplicant decides which AP to use based on scan results
- - %wpa_supplicant configures driver to associate with the selected BSS
-   (SIOCSIWMODE, SIOCSIWGENIE, SIOCSIWAUTH, SIOCSIWFREQ,
-    SIOCSIWESSID, SIOCSIWAP)
- 
- ap_scan=2:
- 
- - %wpa_supplicant configures driver to associate with an SSID
-   (SIOCSIWMODE, SIOCSIWGENIE, SIOCSIWAUTH, SIOCSIWESSID)
- 
- 
- After this, both modes use similar steps:
- 
- - optionally (or required for drivers that generate WPA/RSN IE for
-   (Re)AssocReq), driver reports association parameters (AssocReq IEs)
-   with wireless event IWEVASSOCREQIE (and optionally IWEVASSOCRESPIE)
- - driver reports association with wireless event SIOCGIWAP
- - %wpa_supplicant takes care of EAPOL frame handling (validating
-   information from associnfo and if needed, from scan results if WPA/RSN
-   IE from the Beacon frame is not reported through associnfo)
- */
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/eap.doxygen wpa_view/wpa_suppl/doc/eap.doxygen
*** wpa_supplicant-0.5.7/doc/eap.doxygen	Sat Jun 10 19:42:37 2006
--- wpa_view/wpa_suppl/doc/eap.doxygen	Thu Jan  1 02:00:00 1970
***************
*** 1,56 ****
- /**
- \page eap_module EAP peer implementation
- 
- Extensible Authentication Protocol (EAP) is an authentication framework
- defined in RFC 3748. %wpa_supplicant uses a separate code module for EAP
- peer implementation. This module was designed to use only a minimal set
- of direct function calls (mainly, to debug/event functions) in order for
- it to be usable in other programs. The design of the EAP
- implementation is based loosely on RFC 4137. The state machine is
- defined in this RFC and so is the interface between the peer state
- machine and methods. As such, this RFC provides useful information for
- understanding the EAP peer implementation in %wpa_supplicant.
- 
- Some of the terminology used in EAP state machine is referring to
- EAPOL (IEEE 802.1X), but there is no strict requirement on the lower
- layer being IEEE 802.1X if EAP module is built for other programs than
- %wpa_supplicant. These terms should be understood to refer to the
- lower layer as defined in RFC 4137.
- 
- 
- \section adding_eap_methods Adding EAP methods
- 
- Each EAP method is implemented as a separate module, usually as one C
- file named eap_<name of the method>.c, e.g., eap_md5.c. All EAP
- methods use the same interface between the peer state machine and
- method specific functions. This allows new EAP methods to be added
- without modifying the core EAP state machine implementation.
- 
- New EAP methods need to be registered by adding them into the build
- (Makefile) and the EAP method registration list in the
- eap_peer_register_methods() function of eap_methods.c. Each EAP
- method should use a build-time configuration option, e.g., EAP_TLS, in
- order to make it possible to select which of the methods are included
- in the build.
- 
- EAP methods must implement the interface defined in eap_i.h. struct
- eap_method defines the needed function pointers that each EAP method
- must provide. In addition, the EAP type and name are registered using
- this structure. This interface is based on section 4.4 of RFC 4137.
- 
- It is recommended that the EAP methods would use generic helper
- functions, eap_msg_alloc() and eap_hdr_validate() when processing
- messages. This allows code sharing and can avoid missing some of the
- needed validation steps for received packets. In addition, these
- functions make it easier to change between expanded and legacy EAP
- header, if needed.
- 
- When adding an EAP method that uses a vendor specific EAP type
- (Expanded Type as defined in RFC 3748, Chapter 5.7), the new method
- must be registered by passing vendor id instead of EAP_VENDOR_IETF to
- eap_peer_method_alloc(). These methods must not try to emulate
- expanded types by registering a legacy EAP method for type 254. See
- eap_vendor_test.c for an example of an EAP method implementation that
- is implemented as an expanded type.
- 
- */
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/kerneldoc2doxygen.pl wpa_view/wpa_suppl/doc/kerneldoc2doxygen.pl
*** wpa_supplicant-0.5.7/doc/kerneldoc2doxygen.pl	Thu Jan  5 06:09:12 2006
--- wpa_view/wpa_suppl/doc/kerneldoc2doxygen.pl	Thu Jan  1 02:00:00 1970
***************
*** 1,129 ****
- #!/usr/bin/perl -w
- #
- ##########################################################################
- # Convert kernel-doc style comments to Doxygen comments.
- ##########################################################################
- #
- # This script reads a C source file from stdin, and writes
- # to stdout.  Normal usage:
- #
- # $ mv file.c file.c.gtkdoc
- # $ kerneldoc2doxygen.pl <file.c.gtkdoc >file.c
- #
- # Or to do the same thing with multiple files:
- # $ perl -i.gtkdoc kerneldoc2doxygen.pl *.c *.h
- #
- # This script may also be suitable for use as a Doxygen input filter,
- # but that has not been tested.
- #
- # Back up your source files before using this script!!
- #
- ##########################################################################
- # Copyright (C) 2003 Jonathan Foster <jon@jon-foster.co.uk>
- # Copyright (C) 2005 Jouni Malinen <jkmaline@cc.hut.fi>
- # (modified for kerneldoc format used in wpa_supplicant)
- #
- # This program is free software; you can redistribute it and/or modify
- # it under the terms of the GNU General Public License version 2 as
- # published by the Free Software Foundation.
- #
- # This program is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- # GNU General Public License for more details.
- #
- # You should have received a copy of the GNU General Public License
- # along with this program; if not, write to the Free Software
- # Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- # or look at http://www.gnu.org/licenses/gpl.html
- ##########################################################################
- 
- 
- ##########################################################################
- #
- # This function converts a single comment from gtk-doc to Doxygen format.
- # The parameter does not include the opening or closing lines
- # (i.e. given a comment like this:
- #    "/**\n"
- #    " * FunctionName:\n"
- #    " * @foo: This describes the foo parameter\n"
- #    " * @bar: This describes the bar parameter\n"
- #    " * @Returns: This describes the return value\n"
- #    " *\n"
- #    " * This describes the function.\n"
- #    " */\n"
- # This function gets:
- #    " * FunctionName:\n"
- #    " * @foo: This describes the foo parameter\n"
- #    " * @bar: This describes the bar parameter\n"
- #    " * @Returns: This describes the return value\n"
- #    " *\n"
- #    " * This describes the function.\n"
- # And it returns:
- #    " * This describes the function.\n"
- #    " *\n"
- #    " * @param foo This describes the foo parameter\n"
- #    " * @param bar This describes the bar parameter\n"
- #    " * @return This describes the return value\n"
- # )
- #
- sub fixcomment {
-     $t = $_[0];
- 
-     # " * func: foo" --> "\brief foo\n"
-     # " * struct bar: foo" --> "\brief foo\n"
-     # If this fails, not a kernel-doc comment ==> return unmodified.
-     ($t =~ s/^[\t ]*\*[\t ]*(struct )?([^ \t\n]*) - ([^\n]*)/\\brief $3\n/s)
-       or return $t;
- 
-     # " * Returns: foo" --> "\return foo"
-     $t =~ s/\n[\t ]*\*[\t ]*Returns:/\n\\return/sig;
- 
-     # " * @foo: bar" --> "\param foo bar"
-     # Handle two common typos: No ":", or "," instead of ":".
-     $t =~ s/\n[\t ]*\*[\t ]*\@([^ :,]*)[:,]?[\t ]*/\n\\param $1 /sg;
- 
-     return $t;
- }
- 
- ##########################################################################
- # Start of main code
- 
- # Read entire stdin into memory - one multi-line string.
- $_ = do { local $/; <> };
- 
- s{^/\*\n \*}{/\*\* \\file\n\\brief};
- s{ \* Copyright}{\\par Copyright\nCopyright};
- 
- # Fix any comments like "/*************" so they don't match.
- # "/***" ===> "/* *"
- s{/\*\*\*}{/\* \*}gs;
- 
- # The main comment-detection code.
- s{
-     (               # $1 = Open comment
-         /\*\*       # Open comment
-         (?!\*)      # Do not match /*** (redundant due to fixup above).
-         [\t ]*\n?   # If 1st line is whitespace, match the lot (including the newline).
-     )
-     (.*?)           # $2 = Body of comment (multi-line)
-     (               # $3 = Close comment
-         (           # If possible, match the whitespace before the close-comment
-             (?<=\n) # This part only matches after a newline
-             [\t ]*  # Eat whitespace
-         )?
-         \*/         # Close comment
-     )
-  }
-  {
-     $1 . fixcomment($2) . $3
-  }gesx;
- # ^^^^ Modes: g - Global, match all occurances.
- #             e - Evaluate the replacement as an expression.
- #             s - Single-line - allows the pattern to match across newlines.
- #             x - eXtended pattern, ignore embedded whitespace
- #                 and allow comments.
- 
- # Write results to stdout
- print $_;
- 
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/mainpage.doxygen wpa_view/wpa_suppl/doc/mainpage.doxygen
*** wpa_supplicant-0.5.7/doc/mainpage.doxygen	Mon Oct 24 05:02:58 2005
--- wpa_view/wpa_suppl/doc/mainpage.doxygen	Thu Jan  1 02:00:00 1970
***************
*** 1,56 ****
- /**
- \mainpage Developers' documentation for %wpa_supplicant
- 
- %wpa_supplicant is a WPA Supplicant for Linux, BSD and Windows with
- support for WPA and WPA2 (IEEE 802.11i / RSN). Supplicant is the IEEE
- 802.1X/WPA component that is used in the client stations. It
- implements key negotiation with a WPA Authenticator and it can optionally
- control roaming and IEEE 802.11 authentication/association of the wlan
- driver.
- 
- The goal of this documentation and comments in the source code is to
- give enough information for other developers to understand how
- %wpa_supplicant has been implemented, how it can be modified, how new
- drivers can be supported, and how %wpa_supplicant can be ported to
- other operating systems. If any information is missing, feel free to
- contact Jouni Malinen <jkmaline@cc.hut.fi> for more
- information. Contributions as patch files are also very welcome at the
- same address. Please note that %wpa_supplicant is licensed under dual
- license, GPLv2 or BSD at user's choice. All contributions to
- %wpa_supplicant are expected to use compatible licensing terms.
- 
- The source code and read-only access to %wpa_supplicant CVS repository
- is available from the project home page at
- http://hostap.epitest.fi/wpa_supplicant/. This developers' documentation
- is also available as a PDF file from
- http://hostap.epitest.fi/wpa_supplicant/wpa_supplicant-devel.pdf .
- 
- The design goal for %wpa_supplicant was to use hardware, driver, and
- OS independent, portable C code for all WPA functionality. The source
- code is divided into separate C files as shown on the \ref
- code_structure "code structure page". All hardware/driver specific
- functionality is in separate files that implement a \ref
- driver_wrapper "well-defined driver API". Information about porting
- to different target boards and operating systems is available on
- the \ref porting "porting page".
- 
- EAPOL (IEEE 802.1X) state machines are implemented as a separate
- module that interacts with \ref eap_module "EAP peer implementation".
- In addition to programs aimed at normal production use,
- %wpa_supplicant source tree includes number of \ref testing_tools
- "testing and development tools" that make it easier to test the
- programs without having to setup a full test setup with wireless
- cards. These tools can also be used to implement automatic test
- suites.
- 
- %wpa_supplicant implements a
- \ref ctrl_iface_page "control interface" that can be used by
- external programs to control the operations of the %wpa_supplicant
- daemon and to get status information and event notifications. There is
- a small C library that provides helper functions to facilitate the use of the
- control interface. This library can also be used with C++.
- 
- \image html wpa_supplicant.png "wpa_supplicant modules"
- \image latex wpa_supplicant.eps "wpa_supplicant modules" width=15cm
- 
- */
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/porting.doxygen wpa_view/wpa_suppl/doc/porting.doxygen
*** wpa_supplicant-0.5.7/doc/porting.doxygen	Sat Nov 26 02:29:18 2005
--- wpa_view/wpa_suppl/doc/porting.doxygen	Thu Jan  1 02:00:00 1970
***************
*** 1,170 ****
- /**
- \page porting Porting to different target boards and operating systems
- 
- %wpa_supplicant was designed to be easily portable to different
- hardware (board, CPU) and software (OS, drivers) targets. It is
- already used with number of operating systems and numerous wireless
- card models and drivers. The main %wpa_supplicant repository includes
- support for Linux, FreeBSD, and Windows. In addition, at least VxWorks
- and PalmOS are supported in separate repositories. On the hardware
- side, %wpa_supplicant is used on various systems: desktops, laptops,
- PDAs, and embedded devices with CPUs including x86, PowerPC,
- arm/xscale, and MIPS. Both big and little endian configurations are
- supported.
- 
- 
- \section ansi_c_extra Extra functions on top of ANSI C
- 
- %wpa_supplicant is mostly using ANSI C functions that are available on
- most targets. However, couple of additional functions that are common
- on modern UNIX systems are used. Number of these are listed with
- prototypes in common.h (the #ifdef CONFIG_ANSI_C_EXTRA block). These
- functions may need to be implemented or at least defined as macros to
- native functions in the target OS or C library.
- 
- 
- \section driver_iface_porting Driver interface
- 
- Unless the target OS and driver is already supported, most porting
- projects have to implement a driver wrapper. This may be done by
- adding a new driver interface module or modifying an existing module
- (driver_*.c) if the new target is similar to one of them. \ref
- driver_wrapper "Driver wrapper implementation" describes the details
- of the driver interface and discusses the tasks involved in porting
- this part of %wpa_supplicant.
- 
- 
- \section l2_packet_porting l2_packet (link layer access)
- 
- %wpa_supplicant needs to have access to sending and receiving layer 2
- (link layer) packets with two Ethertypes: EAP-over-LAN (EAPOL) 0x888e
- and RSN pre-authentication 0x88c7. l2_packet.h defines the interfaces
- used for this in the core %wpa_supplicant implementation.
- 
- If the target operating system supports a generic mechanism for link
- layer access, that is likely the best mechanism for providing the
- needed functionality for %wpa_supplicant. Linux packet socket is an
- example of such a generic mechanism. If this is not available, a
- separate interface may need to be implemented to the network stack or
- driver. This is usually an intermediate or protocol driver that is
- operating between the device driver and the OS network stack. If such
- a mechanism is not feasible, the interface can also be implemented
- directly in the device driver.
- 
- The main %wpa_supplicant repository includes l2_packet implementations
- for Linux using packet sockets (l2_packet_linux.c), more portable
- version using libpcap/libdnet libraries (l2_packet_pcap.c; this
- supports WinPcap, too), and FreeBSD specific version of libpcap
- interface (l2_packet_freebsd.c).
- 
- If the target operating system is supported by libpcap (receiving) and
- libdnet (sending), l2_packet_pcap.c can likely be used with minimal or
- no changes. If this is not a case or a proprietary interface for link
- layer is required, a new l2_packet module may need to be
- added. Alternatively, struct wpa_driver_ops::send_eapol() handler can
- be used to override the l2_packet library if the link layer access is
- integrated with the driver interface implementation.
- 
- 
- \section eloop_porting Event loop
- 
- %wpa_supplicant uses a single process/thread model and an event loop
- to provide callbacks on events (registered timeout, received packet,
- signal). eloop.h defines the event loop interface. eloop.c is an
- implementation of such an event loop using select() and sockets. This
- is suitable for most UNIX/POSIX systems. When porting to other
- operating systems, it may be necessary to replace that implementation
- with OS specific mechanisms that provide similar functionality.
- 
- 
- \section ctrl_iface_porting Control interface
- 
- %wpa_supplicant uses a \ref ctrl_iface_page "control interface"
- to allow external processed
- to get status information and to control the operations. Currently,
- this is implemented with socket based communication; both UNIX domain
- sockets and UDP sockets are supported. If the target OS does not
- support sockets, this interface will likely need to be modified to use
- another mechanism like message queues. The control interface is
- optional component, so it is also possible to run %wpa_supplicant
- without porting this part.
- 
- The %wpa_supplicant side of the control interface is implemented in
- ctrl_iface.c. Matching client side is implemented as a control
- interface library in wpa_ctrl.c.
- 
- 
- \section entry_point Program entry point
- 
- %wpa_supplicant defines a set of functions that can be used to
- initialize main supplicant processing. Each operating system has a
- mechanism for starting new processing or threads. This is usually a
- function with a specific set of arguments and calling convention. This
- function is responsible on initializing %wpa_supplicant.
- 
- main.c includes an entry point for UNIX-like operating system, i.e.,
- main() function that uses command line arguments for setting
- parameters for %wpa_supplicant. When porting to other operating
- systems, similar OS-specific entry point implementation is needed. It
- can be implemented in a new file that is then linked with
- %wpa_supplicant instead of main.o. main.c is also a good example on
- how the initialization process should be done.
- 
- The supplicant initialization functions are defined in
- wpa_supplicant_i.h. In most cases, the entry point function should
- start by fetching configuration parameters. After this, a global
- %wpa_supplicant context is initialized with a call to
- wpa_supplicant_init(). After this, existing network interfaces can be
- added with wpa_supplicant_add_iface(). wpa_supplicant_run() is then
- used to start the main event loop. Once this returns at program
- termination time, wpa_supplicant_deinit() is used to release global
- context data.
- 
- wpa_supplicant_add_iface() and wpa_supplicant_remove_iface() can be
- used dynamically to add and remove interfaces based on when
- %wpa_supplicant processing is needed for them. This can be done, e.g.,
- when hotplug network adapters are being inserted and ejected. It is
- also possible to do this when a network interface is being
- enabled/disabled if it is desirable that %wpa_supplicant processing
- for the interface is fully enabled/disabled at the same time.
- 
- 
- \section simple_build Simple build example
- 
- One way to start a porting project is to begin with a very simple
- build of %wpa_supplicant with WPA-PSK support and once that is
- building correctly, start adding features.
- 
- Following command can be used to build very simple version of
- %wpa_supplicant:
- 
- \verbatim
- cc -o wpa_supplicant config.c eloop.c common.c md5.c rc4.c sha1.c \
- 	config_none.c l2_packet_none.c tls_none.c wpa.c preauth.c \
- 	aes_wrap.c wpa_supplicant.c events.c main_none.c drivers.c
- \endverbatim
- 
- The end result is not really very useful since it uses empty functions
- for configuration parsing and layer 2 packet access and does not
- include a driver interface. However, this is a good starting point
- since the build is complete in the sense that all functions are
- present and this is easy to configure to a build system by just
- including the listed C files.
- 
- Once this version can be build successfully, the end result can be
- made functional by adding a proper program entry point (main*.c),
- driver interface (driver_*.c and matching CONFIG_DRIVER_* define for
- registration in drivers.c), configuration parser/writer (config_*.c),
- and layer 2 packet access implementation (l2_packet_*.c). After these
- components have been added, the end result should be a working
- WPA/WPA2-PSK enabled supplicant.
- 
- After the basic functionality has been verified to work, more features
- can be added by linking in more files and defining C pre-processor
- defines. Currently, the best source of information for what options
- are available and which files needs to be included is in the Makefile
- used for building the supplicant with make. Similar configuration will
- be needed for build systems that either use different type of make
- tool or a GUI-based project configuration.
- 
- */
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/testing_tools.doxygen wpa_view/wpa_suppl/doc/testing_tools.doxygen
*** wpa_supplicant-0.5.7/doc/testing_tools.doxygen	Sun Apr 16 20:03:36 2006
--- wpa_view/wpa_suppl/doc/testing_tools.doxygen	Thu Jan  1 02:00:00 1970
***************
*** 1,295 ****
- /**
- \page testing_tools Testing and development tools
- 
- [ \ref eapol_test "eapol_test" |
- \ref preauth_test "preauth_test" |
- \ref driver_test "driver_test" |
- \ref unit_tests "Unit tests" ]
- 
- %wpa_supplicant source tree includes number of testing and development
- tools that make it easier to test the programs without having to setup
- a full test setup with wireless cards. In addition, these tools can be
- used to implement automatic tests suites.
- 
- \section eapol_test eapol_test - EAP peer and RADIUS client testing
- 
- eapol_test is a program that links together the same EAP peer
- implementation that %wpa_supplicant is using and the RADIUS
- authentication client code from hostapd. In addition, it has minimal
- glue code to combine these two components in similar ways to IEEE
- 802.1X/EAPOL Authenticator state machines. In other words, it
- integrates IEEE 802.1X Authenticator (normally, an access point) and
- IEEE 802.1X Supplicant (normally, a wireless client) together to
- generate a single program that can be used to test EAP methods without
- having to setup an access point and a wireless client.
- 
- The main uses for eapol_test are in interoperability testing of EAP
- methods against RADIUS servers and in development testing for new EAP
- methods. It can be easily used to automate EAP testing for
- interoperability and regression since the program can be run from
- shell scripts without require additional test components apart from a
- RADIUS server. For example, the automated EAP tests described in
- eap_testing.txt are implemented with eapol_test. Similarly, eapol_test
- could be used to implement an automated regression test suite for a
- RADIUS authentication server.
- 
- eapol_test uses the same build time configuration file, .config, as
- %wpa_supplicant. This file is used to select which EAP methods are
- included in eapol_test. This program is not built with the default
- Makefile target, so a separate make command needs to be used to
- compile the tool:
- 
- \verbatim
- make eapol_test
- \endverbatim
- 
- The resulting eapol_test binary has following command like options:
- 
- \verbatim
- usage:
- eapol_test [-nWS] -c<conf> [-a<AS IP>] [-p<AS port>] [-s<AS secret>] \
-            [-r<count>] [-t<timeout>] [-C<Connect-Info>] \
-            [-M<client MAC address>]
- eapol_test scard
- eapol_test sim <PIN> <num triplets> [debug]
- 
- options:
-   -c<conf> = configuration file
-   -a<AS IP> = IP address of the authentication server, default 127.0.0.1
-   -p<AS port> = UDP port of the authentication server, default 1812
-   -s<AS secret> = shared secret with the authentication server, default 'radius'
-   -r<count> = number of re-authentications
-   -W = wait for a control interface monitor before starting
-   -S = save configuration after authentiation
-   -n = no MPPE keys expected
-   -t<timeout> = sets timeout in seconds (default: 30 s)
-   -C<Connect-Info> = RADIUS Connect-Info (default: CONNECT 11Mbps 802.11b)
-   -M<client MAC address> = Set own MAC address (Calling-Station-Id,
-                            default: 02:00:00:00:00:01)
- \endverbatim
- 
- 
- As an example,
- \verbatim
- eapol_test -ctest.conf -a127.0.0.1 -p1812 -ssecret -r1
- \endverbatim
- tries to complete EAP authentication based on the network
- configuration from test.conf against the RADIUS server running on the
- local host. A re-authentication is triggered to test fast
- re-authentication. The configuration file uses the same format for
- network blocks as %wpa_supplicant.
- 
- 
- \section preauth_test preauth_test - WPA2 pre-authentication and EAP peer testing
- 
- preauth_test is similar to eapol_test in the sense that in combines
- EAP peer implementation with something else, in this case, with WPA2
- pre-authentication. This tool can be used to test pre-authentication
- based on the code that %wpa_supplicant is using. As such, it tests
- both the %wpa_supplicant implementation and the functionality of an
- access point.
- 
- preauth_test is built with:
- 
- \verbatim
- make preauth_test
- \endverbatim
- 
- and it uses following command line arguments:
- 
- \verbatim
- usage: preauth_test <conf> <target MAC address> <ifname>
- \endverbatim
- 
- For example,
- \verbatim
- preauth_test test.conf 02:11:22:33:44:55 eth0
- \endverbatim
- would use network configuration from test.conf to try to complete
- pre-authentication with AP using BSSID 02:11:22:33:44:55. The
- pre-authentication packets would be sent using the eth0 interface.
- 
- 
- \section driver_test driver_test - driver interface for testing wpa_supplicant
- 
- %wpa_supplicant was designed to support number of different ways to
- communicate with a network device driver. This design uses \ref
- driver_wrapper "driver interface API" and number of driver interface
- implementations. One of these is driver_test.c, i.e., a test driver
- interface that is actually not using any drivers. Instead, it provides
- a mechanism for running %wpa_supplicant without having to have a
- device driver or wireless LAN hardware for that matter.
- 
- driver_test can be used to talk directly with hostapd's driver_test
- component to create a test setup where one or more clients and access
- points can be tested within one test host and without having to have
- multiple wireless cards. This makes it easier to test the core code in
- %wpa_supplicant, and hostapd for that matter. Since driver_test uses
- the same driver API than any other driver interface implementation,
- the core code of %wpa_supplicant and hostapd can be tested with the
- same coverage as one would get when using real wireless cards. The
- only area that is not tested is the driver interface implementation
- (driver_*.c).
- 
- Having the possibility to use simulated network components makes it
- much easier to do development testing while adding new features and to
- reproduce reported bugs. As such, it is often easiest to just do most
- of the development and bug fixing without using real hardware. Once
- the driver_test setup has been used to implement a new feature or fix
- a bug, the end result can be verified with wireless LAN cards. In many
- cases, this may even be unnecessary, depending on what area the
- feature/bug is relating to. Of course, changes to driver interfaces
- will still require use of real hardware.
- 
- Since multiple components can be run within a single host, testing of
- complex network configuration, e.g., large number of clients
- association with an access point, becomes quite easy. All the tests
- can also be automated without having to resort to complex test setup
- using remote access to multiple computers.
- 
- driver_test can be included in the %wpa_supplicant build in the same
- way as any other driver interface, i.e., by adding the following line
- into .config:
- 
- \verbatim
- CONFIG_DRIVER_TEST=y
- \endverbatim
- 
- When running %wpa_supplicant, the test interface is selected by using
- \a -Dtest command line argument. The interface name (\a -i argument)
- can be selected arbitrarily, i.e., it does not need to match with any
- existing network interface. The interface name is used to generate a
- MAC address, so when using multiple clients, each should use a
- different interface, e.g., \a sta1, \a sta2, and so on.
- 
- %wpa_supplicant and hostapd are configured in the same way as they
- would be for normal use. Following example shows a simple test setup
- for WPA-PSK.
- 
- hostapd is configured with following psk-test.conf configuration file:
- 
- \verbatim
- driver=test
- 
- interface=ap1
- logger_stdout=-1
- logger_stdout_level=0
- debug=2
- dump_file=/tmp/hostapd.dump
- 
- test_socket=/tmp/Test/ap1
- 
- ssid=jkm-test-psk
- 
- wpa=1
- wpa_key_mgmt=WPA-PSK
- wpa_pairwise=TKIP
- wpa_passphrase=12345678
- \endverbatim
- 
- and started with following command:
- 
- \verbatim
- hostapd psk-test.conf
- \endverbatim
- 
- %wpa_supplicant uses following configuration file:
- 
- \verbatim
- driver_param=test_socket=/tmp/Test/ap1
- 
- network={
-     ssid="jkm-test-psk"
-     key_mgmt=WPA-PSK
-     psk="12345678"
- }
- \endverbatim
- 
- %wpa_supplicant can then be started with following command:
- 
- \verbatim
- wpa_supplicant -Dtest -cpsk-test.conf -ista1 -ddK
- \endverbatim
- 
- If run without debug information, i.e., with
- 
- \verbatim
- wpa_supplicant -Dtest -cpsk-test.conf -ista1
- \endverbatim
- 
- %wpa_supplicant completes authentication and prints following events:
- 
- \verbatim
- Trying to associate with 02:b8:a6:62:08:5a (SSID='jkm-test-psk' freq=0 MHz)
- Associated with 02:b8:a6:62:08:5a
- WPA: Key negotiation completed with 02:b8:a6:62:08:5a [PTK=TKIP GTK=TKIP]
- CTRL-EVENT-CONNECTED - Connection to 02:b8:a6:62:08:5a completed (auth)
- \endverbatim
- 
- If test setup is using multiple clients, it is possible to run
- multiple %wpa_supplicant processes. Alternatively, the support for
- multiple interfaces can be used with just one process to save some
- resources on single-CPU systems. For example, following command runs
- two clients:
- 
- \verbatim
- ./wpa_supplicant -Dtest -cpsk-test.conf -ista1 \
- 	-N -Dtest -cpsk-test.conf -ista2
- \endverbatim
- 
- This shows following event log:
- 
- \verbatim
- Trying to associate with 02:b8:a6:62:08:5a (SSID='jkm-test-psk' freq=0 MHz)
- Associated with 02:b8:a6:62:08:5a
- WPA: Key negotiation completed with 02:b8:a6:62:08:5a [PTK=TKIP GTK=TKIP]
- CTRL-EVENT-CONNECTED - Connection to 02:b8:a6:62:08:5a completed (auth)
- Trying to associate with 02:b8:a6:62:08:5a (SSID='jkm-test-psk' freq=0 MHz)
- Associated with 02:b8:a6:62:08:5a
- WPA: Key negotiation completed with 02:b8:a6:62:08:5a [PTK=TKIP GTK=TKIP]
- CTRL-EVENT-CONNECTED - Connection to 02:b8:a6:62:08:5a completed (auth)
- \endverbatim
- 
- hostapd shows this with following events:
- 
- \verbatim
- ap1: STA 02:b5:64:63:30:63 IEEE 802.11: associated
- ap1: STA 02:b5:64:63:30:63 WPA: pairwise key handshake completed (WPA)
- ap1: STA 02:b5:64:63:30:63 WPA: group key handshake completed (WPA)
- ap1: STA 02:2a:c4:18:5b:f3 IEEE 802.11: associated
- ap1: STA 02:2a:c4:18:5b:f3 WPA: pairwise key handshake completed (WPA)
- ap1: STA 02:2a:c4:18:5b:f3 WPA: group key handshake completed (WPA)
- \endverbatim
- 
- By default, driver_param is simulating a driver that uses the WPA/RSN
- IE generated by %wpa_supplicant. Driver-generated IE and AssocInfo
- events can be tested by adding \a use_associnfo=1 to the \a driver_param
- line in the configuration file. For example:
- 
- \verbatim
- driver_param=test_socket=/tmp/Test/ap1 use_associnfo=1
- \endverbatim
- 
- 
- \section unit_tests Unit tests
- 
- Number of the components (.c files) used in %wpa_supplicant define
- their own unit tests for automated validation of the basic
- functionality. Most of the tests for cryptographic algorithms are
- using standard test vectors to validate functionality. These tests can
- be useful especially when verifying port to a new CPU target.
- 
- In most cases, these tests are implemented in the end of the same file
- with functions that are normally commented out, but ca be included by
- defining a pre-processor variable when building the file separately.
- The details of the needed build options are included in the Makefile
- (test-* targets). All automated unit tests can be run with
- 
- \verbatim
- make tests
- \endverbatim
- 
- This make target builds and runs each test and terminates with zero
- exit code if all tests were completed successfully.
- 
- */
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/doc/wpa_supplicant.fig wpa_view/wpa_suppl/doc/wpa_supplicant.fig
*** wpa_supplicant-0.5.7/doc/wpa_supplicant.fig	Mon May 30 08:04:21 2005
--- wpa_view/wpa_suppl/doc/wpa_supplicant.fig	Thu Jan  1 02:00:00 1970
***************
*** 1,247 ****
- #FIG 3.2
- Landscape
- Center
- Inches
- Letter  
- 100.00
- Single
- -2
- 1200 2
- 6 1875 4050 2925 4350
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 1875 4050 2925 4050 2925 4350 1875 4350 1875 4050
- 4 0 0 50 -1 0 12 0.0000 4 180 735 2025 4275 l2_packet\001
- -6
- 6 3450 1200 4275 1500
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 3450 1200 4275 1200 4275 1500 3450 1500 3450 1200
- 4 0 0 50 -1 0 12 0.0000 4 180 585 3600 1425 wpa_cli\001
- -6
- 6 4725 1200 5925 1500
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 4725 1200 5925 1200 5925 1500 4725 1500 4725 1200
- 4 0 0 50 -1 0 12 0.0000 4 135 1005 4800 1425 GUI frontend\001
- -6
- 6 6000 2700 7200 3225
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 6000 2700 7200 2700 7200 3225 6000 3225 6000 2700
- 4 0 0 50 -1 0 12 0.0000 4 135 975 6075 2925 WPA/WPA2\001
- 4 0 0 50 -1 0 12 0.0000 4 135 1065 6075 3150 state machine\001
- -6
- 6 6000 4950 7200 5475
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 6000 4950 7200 4950 7200 5475 6000 5475 6000 4950
- 4 0 0 50 -1 0 12 0.0000 4 135 360 6075 5175 EAP\001
- 4 0 0 50 -1 0 12 0.0000 4 135 1065 6075 5400 state machine\001
- -6
- 6 8700 3000 9375 3300
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 8700 3000 9375 3000 9375 3300 8700 3300 8700 3000
- 4 0 0 50 -1 0 12 0.0000 4 150 480 8775 3225 crypto\001
- -6
- 6 4350 3900 5025 4425
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 4350 3900 5025 3900 5025 4425 4350 4425 4350 3900
- 4 0 0 50 -1 0 12 0.0000 4 105 420 4500 4125 event\001
- 4 0 0 50 -1 0 12 0.0000 4 180 315 4500 4350 loop\001
- -6
- 6 4275 2550 5100 2850
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 4275 2550 5100 2550 5100 2850 4275 2850 4275 2550
- 4 0 0 50 -1 0 12 0.0000 4 135 450 4425 2775 ctrl i/f\001
- -6
- 6 6000 3900 7200 4425
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 6000 3900 7200 3900 7200 4425 6000 4425 6000 3900
- 4 0 0 50 -1 0 12 0.0000 4 135 600 6075 4125 EAPOL\001
- 4 0 0 50 -1 0 12 0.0000 4 135 1065 6075 4350 state machine\001
- -6
- 6 1800 6000 7800 8100
- 6 1800 6000 7800 7200
- 6 1800 6900 2700 7200
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 1800 6900 2700 6900 2700 7200 1800 7200 1800 6900
- 4 0 0 50 -1 0 12 0.0000 4 105 375 1875 7125 wext\001
- -6
- 6 4725 6900 5625 7200
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 4725 6900 5625 6900 5625 7200 4725 7200 4725 6900
- 4 0 0 50 -1 0 12 0.0000 4 135 555 4800 7125 hermes\001
- -6
- 6 6675 6900 7800 7200
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 6675 6900 7800 6900 7800 7200 6675 7200 6675 6900
- 4 0 0 50 -1 0 12 0.0000 4 180 930 6750 7125 ndiswrapper\001
- -6
- 6 5700 6900 6600 7200
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 5700 6900 6600 6900 6600 7200 5700 7200 5700 6900
- 4 0 0 50 -1 0 12 0.0000 4 135 420 5775 7125 atmel\001
- -6
- 6 4275 6000 5100 6300
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 4275 6000 5100 6000 5100 6300 4275 6300 4275 6000
- 4 0 0 50 -1 0 12 0.0000 4 135 630 4350 6225 driver i/f\001
- -6
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 2775 6900 3675 6900 3675 7200 2775 7200 2775 6900
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 3750 6900 4650 6900 4650 7200 3750 7200 3750 6900
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 4
- 	 2250 6900 2250 6600 7200 6600 7200 6900
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 3225 6900 3225 6600
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 4200 6900 4200 6600
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 5175 6900 5175 6600
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 6150 6900 6150 6600
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 4650 6600 4650 6300
- 4 0 0 50 -1 0 12 0.0000 4 180 510 2850 7125 hostap\001
- 4 0 0 50 -1 0 12 0.0000 4 135 600 3825 7125 madwifi\001
- -6
- 6 3525 7800 5775 8100
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 3525 7800 5775 7800 5775 8100 3525 8100 3525 7800
- 4 0 0 50 -1 0 12 0.0000 4 135 2145 3600 8025 kernel network device driver\001
- -6
- 2 1 1 1 0 7 50 -1 -1 4.000 0 0 -1 0 0 2
- 	 2250 7200 4200 7800
- 2 1 1 1 0 7 50 -1 -1 4.000 0 0 -1 0 0 2
- 	 7200 7200 5100 7800
- -6
- 6 9600 3000 10275 3300
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 9600 3000 10275 3000 10275 3300 9600 3300 9600 3000
- 4 0 0 50 -1 0 12 0.0000 4 135 315 9750 3225 TLS\001
- -6
- 6 8100 4425 10425 7350
- 6 8175 4725 9225 5025
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 8175 4725 9225 4725 9225 5025 8175 5025 8175 4725
- 4 0 0 50 -1 0 12 0.0000 4 135 735 8250 4950 EAP-TLS\001
- -6
- 6 9300 4725 10350 5025
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 9300 4725 10350 4725 10350 5025 9300 5025 9300 4725
- 4 0 0 50 -1 0 12 0.0000 4 135 810 9375 4950 EAP-MD5\001
- -6
- 6 8175 5100 9225 5400
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 8175 5100 9225 5100 9225 5400 8175 5400 8175 5100
- 4 0 0 50 -1 0 12 0.0000 4 135 885 8250 5325 EAP-PEAP\001
- -6
- 6 9300 5100 10350 5400
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 9300 5100 10350 5100 10350 5400 9300 5400 9300 5100
- 4 0 0 50 -1 0 12 0.0000 4 135 840 9375 5325 EAP-TTLS\001
- -6
- 6 8175 5475 9225 5775
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 8175 5475 9225 5475 9225 5775 8175 5775 8175 5475
- 4 0 0 50 -1 0 12 0.0000 4 135 780 8250 5700 EAP-GTC\001
- -6
- 6 9300 5475 10350 5775
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 9300 5475 10350 5475 10350 5775 9300 5775 9300 5475
- 4 0 0 50 -1 0 12 0.0000 4 135 765 9375 5700 EAP-OTP\001
- -6
- 6 8175 5850 9225 6150
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 8175 5850 9225 5850 9225 6150 8175 6150 8175 5850
- 4 0 0 50 -1 0 12 0.0000 4 135 750 8250 6075 EAP-SIM\001
- -6
- 6 9300 6225 10350 6525
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 9300 6225 10350 6225 10350 6525 9300 6525 9300 6225
- 4 0 0 50 -1 0 12 0.0000 4 135 465 9375 6450 LEAP\001
- -6
- 6 8175 6225 9225 6525
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 8175 6225 9225 6225 9225 6525 8175 6525 8175 6225
- 4 0 0 50 -1 0 12 0.0000 4 135 765 8250 6450 EAP-PSK\001
- -6
- 6 9300 5850 10350 6150
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 9300 5850 10350 5850 10350 6150 9300 6150 9300 5850
- 4 0 0 50 -1 0 12 0.0000 4 135 825 9375 6075 EAP-AKA\001
- -6
- 6 8175 6975 9675 7275
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 8175 6975 9675 6975 9675 7275 8175 7275 8175 6975
- 4 0 0 50 -1 0 12 0.0000 4 135 1365 8250 7200 EAP-MSCHAPv2\001
- -6
- 6 9300 6600 10350 6900
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 9300 6600 10350 6600 10350 6900 9300 6900 9300 6600
- 4 0 0 50 -1 0 12 0.0000 4 135 870 9375 6825 EAP-FAST\001
- -6
- 6 8175 6600 9225 6900
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 8175 6600 9225 6600 9225 6900 8175 6900 8175 6600
- 4 0 0 50 -1 0 12 0.0000 4 135 795 8250 6825 EAP-PAX\001
- -6
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 8100 7350 10425 7350 10425 4425 8100 4425 8100 7350
- 4 0 0 50 -1 0 12 0.0000 4 135 1050 8700 4650 EAP methods\001
- -6
- 6 2775 5025 4050 5325
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 2775 5025 4050 5025 4050 5325 2775 5325 2775 5025
- 4 0 0 50 -1 0 12 0.0000 4 135 990 2925 5250 driver events\001
- -6
- 6 2775 3150 4050 3450
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 2775 3150 4050 3150 4050 3450 2775 3450 2775 3150
- 4 0 0 50 -1 0 12 0.0000 4 180 990 2925 3375 configuration\001
- -6
- 2 1 1 1 0 7 50 -1 -1 3.000 0 0 -1 0 0 2
- 	 1275 4200 1875 4200
- 2 1 1 1 0 7 50 -1 -1 4.000 0 0 -1 0 0 2
- 	 4500 2550 3900 1500
- 2 1 1 1 0 7 50 -1 -1 4.000 0 0 -1 0 0 2
- 	 4800 2550 5400 1500
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 2925 4200 4350 4200
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 5025 3900 6000 3000
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 5025 4200 6000 4200
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 4650 6000 4650 4425
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 6600 4425 6600 4950
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 6600 3225 6600 3900
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 7200 5250 8100 5250
- 2 1 0 1 2 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 9075 4425 9075 3300
- 2 1 0 1 2 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 7200 3000 8700 3150
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 4650 3900 4650 2850
- 2 1 0 1 2 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 7200 4125 8700 3300
- 2 1 0 1 2 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 6000 4350 5025 6000
- 2 1 0 1 2 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 6000 3150 4875 6000
- 2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
- 	 1500 2100 10800 2100 10800 7500 1500 7500 1500 2100
- 2 1 0 1 2 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 9900 4425 9900 3300
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 1
- 	 4350 3900
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 4350 3900 4050 3450
- 2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
- 	 4350 4425 4050 5025
- 4 0 0 50 -1 0 12 0.0000 4 135 915 375 3975 EAPOL and\001
- 4 0 0 50 -1 0 12 0.0000 4 180 630 375 4200 pre-auth\001
- 4 0 0 50 -1 0 12 0.0000 4 180 810 375 4425 ethertypes\001
- 4 0 0 50 -1 0 12 0.0000 4 135 1050 375 4650 from/to kernel\001
- 4 0 0 50 -1 0 12 0.0000 4 135 1920 3675 1875 frontend control interface\001
- 4 0 0 50 -1 2 14 0.0000 4 210 1440 1637 2371 wpa_supplicant\001
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/driver.h wpa_view/wpa_suppl/driver.h
*** wpa_supplicant-0.5.7/driver.h	Sun Oct 29 20:27:49 2006
--- wpa_view/wpa_suppl/driver.h	Wed Jun  9 13:29:51 2010
***************
*** 752,757 ****
--- 752,771 ----
  	 * (management frame processing) to wpa_supplicant.
  	 */
  	 int (*mlme_remove_sta)(void *priv, const u8 *addr);
+ 
+ #ifdef CONFIG_EAP_WSC
+ 	/**
+ 	 * set_wsc_mode - set the driver wsc mode
+ 	 * @priv: Private driver interface data
+ 	 * @WscMode: wsc mode
+ 	 * @probeReqBuf: the probe request
+ 	 * Returns: 0 on success, -1 on failure
+ 	 *
+ 	 * This function is only needed for drivers that export MLME
+ 	 * (management frame processing) to wpa_supplicant.
+ 	 */
+ 	 int (*set_wsc_mode)(void *priv, const u32 WscMode, const void* probeReqBuf, int probeReqBufLen);	
+ #endif
  };
  
  #endif /* DRIVER_H */
diff -BNcr wpa_supplicant-0.5.7/driver_wext.c wpa_view/wpa_suppl/driver_wext.c
*** wpa_supplicant-0.5.7/driver_wext.c	Sun Dec 31 20:11:37 2006
--- wpa_view/wpa_suppl/driver_wext.c	Wed Jun  9 13:29:56 2010
***************
*** 1,6 ****
  /*
   * WPA Supplicant - driver interaction with generic Linux Wireless Extensions
!  * Copyright (c) 2003-2006, Jouni Malinen <jkmaline@cc.hut.fi>
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 as
--- 1,6 ----
  /*
   * WPA Supplicant - driver interaction with generic Linux Wireless Extensions
!  * Copyright (c) 2003-2008, Jouni Malinen <jkmaline@cc.hut.fi>
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 as
***************
*** 32,37 ****
--- 32,44 ----
  #include "driver_wext.h"
  #include "wpa.h"
  
+ #ifdef CONFIG_EAP_WSC
+ #ifdef TI_WLAN_DRIVER
+ #include "TWDriver.h"
+ #include "STADExternalIf.h"
+ #endif
+ #endif
+ 
  #ifdef CONFIG_CLIENT_MLME
  #include <netpacket/packet.h>
  #include <hostapd_ioctl.h>
***************
*** 120,126 ****
  	wpa_printf(MSG_DEBUG, "WEXT: Operstate: linkmode=%d, operstate=%d",
  		   linkmode, operstate);
  
! 	ret = send(drv->event_sock, &req, req.hdr.nlmsg_len, 0);
  	if (ret < 0) {
  		wpa_printf(MSG_DEBUG, "WEXT: Sending operstate IFLA failed: "
  			   "%s (assume operstate is not supported)",
--- 127,133 ----
  	wpa_printf(MSG_DEBUG, "WEXT: Operstate: linkmode=%d, operstate=%d",
  		   linkmode, operstate);
  
!  	ret = send(drv->event_sock, &req, req.hdr.nlmsg_len, 0);
  	if (ret < 0) {
  		wpa_printf(MSG_DEBUG, "WEXT: Sending operstate IFLA failed: "
  			   "%s (assume operstate is not supported)",
***************
*** 190,202 ****
  	struct iwreq iwr;
  	int ret = 0;
  
! 	os_memset(&iwr, 0, sizeof(iwr));
  	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
  	iwr.u.ap_addr.sa_family = ARPHRD_ETHER;
  	if (bssid)
! 		os_memcpy(iwr.u.ap_addr.sa_data, bssid, ETH_ALEN);
  	else
! 		os_memset(iwr.u.ap_addr.sa_data, 0, ETH_ALEN);
  
  	if (ioctl(drv->ioctl_sock, SIOCSIWAP, &iwr) < 0) {
  		perror("ioctl[SIOCSIWAP]");
--- 197,209 ----
  	struct iwreq iwr;
  	int ret = 0;
  
!     os_memset(&iwr, 0, sizeof(iwr));
  	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
  	iwr.u.ap_addr.sa_family = ARPHRD_ETHER;
  	if (bssid)
!         os_memcpy(iwr.u.ap_addr.sa_data, bssid, ETH_ALEN);
  	else
!         os_memset(iwr.u.ap_addr.sa_data, 0, ETH_ALEN);
  
  	if (ioctl(drv->ioctl_sock, SIOCSIWAP, &iwr) < 0) {
  		perror("ioctl[SIOCSIWAP]");
***************
*** 386,391 ****
--- 393,406 ----
  		wpa_supplicant_event(ctx, EVENT_STKSTART, &data);
  #endif /* CONFIG_PEERKEY */
  	}
+ #ifdef TI_WLAN_DRIVER
+ #ifdef CONFIG_EAP_WSC
+ 	else if(((IPC_EV_DATA*)custom)->EvParams.uEventType == IPC_EVENT_WPS_SESSION_OVERLAP)
+ 	{
+ 		wpa_supplicant_event(ctx, EVENT_WSC_PBC_OVERLAP, NULL);
+ 	}
+ #endif /* CONFIG_EAP_WSC */
+ #endif /* TI_WLAN_DRIVER */
  }
  
  
***************
*** 791,797 ****
  					      const char *ifname, int *flags)
  {
  	struct ifreq ifr;
! 
  	os_memset(&ifr, 0, sizeof(ifr));
  	os_strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
  	if (ioctl(drv->ioctl_sock, SIOCGIFFLAGS, (caddr_t) &ifr) < 0) {
--- 806,812 ----
  					      const char *ifname, int *flags)
  {
  	struct ifreq ifr;
! 	
  	os_memset(&ifr, 0, sizeof(ifr));
  	os_strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
  	if (ioctl(drv->ioctl_sock, SIOCGIFFLAGS, (caddr_t) &ifr) < 0) {
***************
*** 1679,1685 ****
  				    reason_code);
  }
  
! 
  static int wpa_driver_wext_set_gen_ie(void *priv, const u8 *ie,
  				      size_t ie_len)
  {
--- 1694,1700 ----
  				    reason_code);
  }
  
! #ifndef TI_WLAN_DRIVER
  static int wpa_driver_wext_set_gen_ie(void *priv, const u8 *ie,
  				      size_t ie_len)
  {
***************
*** 1699,1704 ****
--- 1714,1720 ----
  
  	return ret;
  }
+ #endif
  
  
  static int wpa_driver_wext_cipher2wext(int cipher)
***************
*** 1802,1813 ****
--- 1818,1831 ----
  
  	if (wpa_driver_wext_set_mode(drv, params->mode) < 0)
  		ret = -1;
+ #ifndef TI_WLAN_DRIVER
  	/* TODO: should consider getting wpa version and cipher/key_mgmt suites
  	 * from configuration, not from here, where only the selected suite is
  	 * available */
  	if (wpa_driver_wext_set_gen_ie(drv, params->wpa_ie, params->wpa_ie_len)
  	    < 0)
  		ret = -1;
+ #endif
  	if (params->wpa_ie == NULL || params->wpa_ie_len == 0)
  		value = IW_AUTH_WPA_VERSION_DISABLED;
  	else if (params->wpa_ie[0] == RSN_INFO_ELEM)
***************
*** 1845,1862 ****
  		allow_unencrypted_eapol = 0;
  	else
  		allow_unencrypted_eapol = 1;
! 	
  	if (wpa_driver_wext_set_auth_param(drv,
  					   IW_AUTH_RX_UNENCRYPTED_EAPOL,
  					   allow_unencrypted_eapol) < 0)
  		ret = -1;
  	if (params->freq && wpa_driver_wext_set_freq(drv, params->freq) < 0)
  		ret = -1;
- 	if (wpa_driver_wext_set_ssid(drv, params->ssid, params->ssid_len) < 0)
- 		ret = -1;
  	if (params->bssid &&
  	    wpa_driver_wext_set_bssid(drv, params->bssid) < 0)
  		ret = -1;
  
  	return ret;
  }
--- 1863,1881 ----
  		allow_unencrypted_eapol = 0;
  	else
  		allow_unencrypted_eapol = 1;
! 
  	if (wpa_driver_wext_set_auth_param(drv,
  					   IW_AUTH_RX_UNENCRYPTED_EAPOL,
  					   allow_unencrypted_eapol) < 0)
  		ret = -1;
  	if (params->freq && wpa_driver_wext_set_freq(drv, params->freq) < 0)
  		ret = -1;
  	if (params->bssid &&
  	    wpa_driver_wext_set_bssid(drv, params->bssid) < 0)
  		ret = -1;
+ 	if (wpa_driver_wext_set_ssid(drv, params->ssid, params->ssid_len) < 0)
+ 		ret = -1;
+ 
  
  	return ret;
  }
***************
*** 2263,2268 ****
--- 2282,2331 ----
  
  #endif /* CONFIG_CLIENT_MLME */
  
+ #ifdef CONFIG_EAP_WSC
+ static int wpa_driver_wext_set_wsc_mode(void *priv, const u32 WscMode, const void* probeReqBuf, int probeReqBufLen)
+ {
+ #ifdef TI_WLAN_DRIVER
+ 	struct wpa_driver_wext_data *drv = priv;
+ 	struct iwreq iwr;
+ 	ti_private_cmd_t private_cmd;
+ 	TWscMode WcsModeStruct;
+ 	int ret = 0;
+ 	
+ 	WcsModeStruct.WSCMode = WscMode;
+     WcsModeStruct.uWscIeSize = probeReqBufLen;
+ 	memset(WcsModeStruct.probeReqWSCIE, 0, DOT11_WSC_PROBE_REQ_MAX_LENGTH);
+ 	memcpy(WcsModeStruct.probeReqWSCIE, probeReqBuf, probeReqBufLen);
+ 
+ 	private_cmd.cmd = SITE_MGR_SIMPLE_CONFIG_MODE;
+ 	private_cmd.flags = PRIVATE_CMD_SET_FLAG;
+ 	private_cmd.in_buffer = &WcsModeStruct;
+    	private_cmd.in_buffer_len = sizeof(TWscMode);
+ 	private_cmd.out_buffer = NULL;
+    	private_cmd.out_buffer_len = 0;
+ 
+ 	os_memset(&iwr, 0, sizeof(iwr));
+ 	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);	
+ 
+ 	iwr.u.data.pointer = &private_cmd;
+ 	iwr.u.data.length = sizeof(ti_private_cmd_t);
+ 	iwr.u.data.flags = 0;	
+ 
+ 	if (ioctl(drv->ioctl_sock, SIOCIWFIRSTPRIV, &iwr) < 0) {
+ 		perror("ioctl[SIOCIWFIRSTPRIV]");
+ 		ret = -1;
+ 	}
+ 
+ 	return ret;
+ #else
+ 	wpa_printf(MSG_ERROR,"wpa_driver_wext_set_wsc_mode: wpa_driver_wext_set_wsc_mode: this implementation is working only for TI WLAN driver\n");
+ 	return -1;
+ #endif
+ 
+ }
+ #endif
+ 
+ 
  
  static int wpa_driver_wext_set_param(void *priv, const char *param)
  {
***************
*** 2340,2343 ****
--- 2403,2409 ----
  	.mlme_add_sta = wpa_driver_wext_mlme_add_sta,
  	.mlme_remove_sta = wpa_driver_wext_mlme_remove_sta,
  #endif /* CONFIG_CLIENT_MLME */
+ #ifdef CONFIG_EAP_WSC
+ 	.set_wsc_mode = wpa_driver_wext_set_wsc_mode,
+ #endif
  };
diff -BNcr wpa_supplicant-0.5.7/eap.c wpa_view/wpa_suppl/eap.c
*** wpa_supplicant-0.5.7/eap.c	Sun Nov 12 02:47:56 2006
--- wpa_view/wpa_suppl/eap.c	Wed Jun  9 13:29:59 2010
***************
*** 50,55 ****
--- 50,59 ----
  static const char * eap_sm_decision_txt(EapDecision decision);
  #endif /* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
  
+ #ifdef CONFIG_EAP_WSC
+ void EapWsc_EapFailureRecv(void *priv);			
+ #endif
+ 
  
  
  static Boolean eapol_get_bool(struct eap_sm *sm, enum eapol_bool_var var)
***************
*** 1126,1131 ****
--- 1130,1144 ----
  	case EAP_CODE_FAILURE:
  		wpa_printf(MSG_DEBUG, "EAP: Received EAP-Failure");
  		sm->rxFailure = TRUE;
+ 
+ #ifdef CONFIG_EAP_WSC
+ 
+ 		if (sm->m && sm->eap_method_priv)
+ 		{
+ 			EapWsc_EapFailureRecv(sm->eap_method_priv);
+ 		}
+ 		
+ #endif /* CONFIG_EAP_WSC */
  		break;
  	default:
  		wpa_printf(MSG_DEBUG, "EAP: Ignored EAP-Packet with unknown "
diff -BNcr wpa_supplicant-0.5.7/eap_defs.h wpa_view/wpa_suppl/eap_defs.h
*** wpa_supplicant-0.5.7/eap_defs.h	Sun Dec 10 05:31:14 2006
--- wpa_view/wpa_suppl/eap_defs.h	Wed Jun  9 13:30:00 2010
***************
*** 58,64 ****
--- 58,70 ----
  	EAP_TYPE_PAX = 46 /* draft-clancy-eap-pax-11.txt */,
  	EAP_TYPE_PSK = 47 /* draft-bersani-eap-psk-11.txt */,
  	EAP_TYPE_SAKE = 48 /* RFC 4763 */,
+ #ifdef CONFIG_EAP_WSC
+ 	EAP_TYPE_EXPANDED = 253 /* RFC 3748 */,
+ 	EAP_TYPE_WSC = 254, /*Wireless Simple Config */
+ #else
  	EAP_TYPE_EXPANDED = 254 /* RFC 3748 */,
+ #endif /* CONFIG_DRIVER_TI */
+ 
  	EAP_TYPE_GPSK = 255 /* EXPERIMENTAL - type not yet allocated
  			     * draft-ietf-emu-eap-gpsk-01.txt */
  } EapType;
diff -BNcr wpa_supplicant-0.5.7/eap_methods.c wpa_view/wpa_suppl/eap_methods.c
*** wpa_supplicant-0.5.7/eap_methods.c	Sat Nov 11 06:17:57 2006
--- wpa_view/wpa_suppl/eap_methods.c	Wed Jun  9 13:30:02 2010
***************
*** 455,460 ****
--- 455,467 ----
  	}
  #endif /* EAP_GPSK */
  
+ #ifdef CONFIG_EAP_WSC
+ 	if (ret == 0) {
+ 		int eap_peer_wsc_register(void);
+ 		ret = eap_peer_wsc_register();
+ 	}
+ #endif /* CONFIG_EAP_WSC */
+ 
  #ifdef EAP_VENDOR_TEST
  	if (ret == 0) {
  		int eap_peer_vendor_test_register(void);
diff -BNcr wpa_supplicant-0.5.7/eap_sake.c wpa_view/wpa_suppl/eap_sake.c
*** wpa_supplicant-0.5.7/eap_sake.c	Sun Dec 10 05:35:30 2006
--- wpa_view/wpa_suppl/eap_sake.c	Wed Jun  9 13:30:06 2010
***************
*** 137,151 ****
  		return NULL;
  	}
  
! 	req = (struct eap_sake_hdr *) msg;
! 	req->code = EAP_CODE_RESPONSE;
! 	req->identifier = id;
! 	req->length = htons((u16) *length);
! 	req->type = EAP_TYPE_SAKE;
! 	req->version = EAP_SAKE_VERSION;
! 	req->session_id = data->session_id;
! 	req->subtype = subtype;
! 	*payload = (u8 *) (req + 1);
  
  	return msg;
  }
--- 137,151 ----
  		return NULL;
  	}
  
! 		req = (struct eap_sake_hdr *) msg;
! 		req->code = EAP_CODE_RESPONSE;
! 		req->identifier = id;
! 		req->length = htons((u16) *length);
! 		req->type = EAP_TYPE_SAKE;
! 		req->version = EAP_SAKE_VERSION;
! 		req->session_id = data->session_id;
! 		req->subtype = subtype;
! 		*payload = (u8 *) (req + 1);
  
  	return msg;
  }
***************
*** 393,403 ****
  		return NULL;
  	}
  
! 	req = (const struct eap_sake_hdr *) reqData;
! 	subtype = req->subtype;
! 	session_id = req->session_id;
! 	pos = (const u8 *) (req + 1);
! 	end = reqData + be_to_host16(req->length);
  
  	wpa_printf(MSG_DEBUG, "EAP-SAKE: Received frame: subtype %d "
  		   "session_id %d", subtype, session_id);
--- 393,403 ----
  		return NULL;
  	}
  
! 		req = (const struct eap_sake_hdr *) reqData;
! 		subtype = req->subtype;
! 		session_id = req->session_id;
! 		pos = (const u8 *) (req + 1);
! 		end = reqData + be_to_host16(req->length);
  
  	wpa_printf(MSG_DEBUG, "EAP-SAKE: Received frame: subtype %d "
  		   "session_id %d", subtype, session_id);
diff -BNcr wpa_supplicant-0.5.7/eap_testing.txt wpa_view/wpa_suppl/eap_testing.txt
*** wpa_supplicant-0.5.7/eap_testing.txt	Sat Dec  9 06:06:46 2006
--- wpa_view/wpa_suppl/eap_testing.txt	Thu Jan  1 02:00:00 1970
***************
*** 1,359 ****
- Automatic regression and interoperability testing of wpa_supplicant's
- IEEE 802.1X/EAPOL authentication
- 
- Test program:
- - Linked some parts of IEEE 802.1X Authenticator implementation from
-   hostapd (RADIUS client and RADIUS processing, EAP<->RADIUS
-   encapsulation/decapsulation) into wpa_supplicant.
- - Replaced wpa_supplicant.c and wpa.c with test code that trigger
-   IEEE 802.1X authentication automatically without need for wireless
-   client card or AP.
- - For EAP methods that generate keying material, the key derived by the
-   Supplicant is verified to match with the one received by the (now
-   integrated) Authenticator.
- 
- The full automated test suite can now be run in couple of seconds, but
- I'm more than willing to add new RADIUS authentication servers to make
- this take a bit more time.. ;-) As an extra bonus, this can also be
- seen as automatic regression/interoperability testing for the RADIUS
- server, too.
- 
- In order for me to be able to use a new authentication server, the
- server need to be available from Internet (at least from one static IP
- address) and I will need to get suitable user name/password pairs,
- certificates, and private keys for testing use. Other alternative
- would be to get an evaluation version of the server so that I can
- install it on my own test setup. If you are interested in providing
- either server access or evaluation version, please contact me
- (jkmaline@cc.hut.fi).
- 
- 
- Test matrix
- 
- +) tested successfully
- F) failed
- -) server did not support
- ?) not tested
- 
- Cisco ACS ----------------------------------------------------------.
- hostapd --------------------------------------------------------.   |
- Cisco Aironet 1200 AP (local RADIUS server) ----------------.   |   |
- Periodik Labs Elektron ---------------------------------.   |   |   |
- Lucent NavisRadius ---------------------------------.   |   |   |   |
- Interlink RAD-Series ---------------------------.   |   |   |   |   |
- Radiator -----------------------------------.   |   |   |   |   |   |
- Meetinghouse Aegis ---------------------.   |   |   |   |   |   |   |
- Funk Steel-Belted ------------------.   |   |   |   |   |   |   |   |
- Funk Odyssey -------------------.   |   |   |   |   |   |   |   |   |
- Microsoft IAS --------------.   |   |   |   |   |   |   |   |   |   |
- FreeRADIUS -------------.   |   |   |   |   |   |   |   |   |   |   |
- 			|   |   |   |   |   |   |   |   |   |   |   |
- 
- EAP-MD5			+   -   -   +   +   +   +   +   -   -   +   +
- EAP-GTC			+   -   -   ?   +   +   +   +   -   -   +   -
- EAP-OTP			-   -   -   -   -   +   -   -   -   -   -   -
- EAP-MSCHAPv2		+   -   -   +   +   +   +   +   -   -   +   -
- EAP-TLS			+   +   +   +   +   +   +   +   -   -   +   +
- EAP-PEAPv0/MSCHAPv2	+   +   +   +   +   +   +   +   +   -   +   +
- EAP-PEAPv0/GTC		+   -   +   -   +   +   +   +   -   -   +   +
- EAP-PEAPv0/OTP		-   -   -   -   -   +   -   -   -   -   -   -
- EAP-PEAPv0/MD5		+   -   -   +   +   +   +   +   -   -   +   -
- EAP-PEAPv0/TLS		-   +   -   +   +   +   F   +   -   -   -   -
- EAP-PEAPv1/MSCHAPv2	-   -   +   +   +   +1  +   +5  +8  -   +   +
- EAP-PEAPv1/GTC		-   -   +   +   +   +1  +   +5  +8  -   +   +
- EAP-PEAPv1/OTP		-   -   -   -   -   +1  -   -   -   -   -   -
- EAP-PEAPv1/MD5		-   -   -   +   +   +1  +   +5  -   -   +   -
- EAP-PEAPv1/TLS		-   -   -   +   +   +1  F   +5  -   -   -   -
- EAP-TTLS/CHAP		+   -   +2  +   +   +   +   +   +   -   +   -
- EAP-TTLS/MSCHAP		+   -   +   +   +   +   +   +   +   -   +   -
- EAP-TTLS/MSCHAPv2	+   -   +   +   +   +   +   +   +   -   +   -
- EAP-TTLS/PAP		+   -   +   +   +   +   +   +   +   -   +   -
- EAP-TTLS/EAP-MD5	+   -   +2  +   +   +   +   +   +   -   +   -
- EAP-TTLS/EAP-GTC	+   -   +2  ?   +   +   +   +   -   -   +   -
- EAP-TTLS/EAP-OTP	-   -   -   -   -   +   -   -   -   -   -   -
- EAP-TTLS/EAP-MSCHAPv2	+   -   +2  +   +   +   +   +   +   -   +   -
- EAP-TTLS/EAP-TLS	-   -   +2  +   F   +   +   +   -   -   -   -
- EAP-SIM			+3  -   -   ?   -   +   -   ?   -   -   +   -
- EAP-AKA			-   -   -   -   -   +   -   -   -   -   +   -
- EAP-PSK			+7  -   -   -   -   -   -   -   -   -   +   -
- EAP-PAX			-   -   -   -   -   -   -   -   -   -   +   -
- EAP-SAKE		-   -   -   -   -   -   -   -   -   -   +   -
- EAP-GPSK		-   -   -   -   -   -   -   -   -   -   +   -
- EAP-FAST		-   -   -   +   -   -   -   -   -   +   -   +
- LEAP			+   -   +   +   +   +   F   +6  -   +   -   +
- 
- 1) PEAPv1 required new label, "client PEAP encryption" instead of "client EAP
-    encryption", during key derivation (requires phase1="peaplabel=1" in the
-    network configuration in wpa_supplicant.conf)
- 2) used FreeRADIUS as inner auth server
- 3) required a patch to FreeRADIUS to fix EAP-SIM
- 5) PEAPv1 required termination of negotiation on tunneled EAP-Success and new
-    label in key deriviation
-    (phase1="peap_outer_success=0 peaplabel=1") (in "IETF Draft 5" mode)
- 6) Authenticator simulator required patching for handling Access-Accept within
-    negotiation (for the first EAP-Success of LEAP)
- 7) EAP-PSK is not included in FreeRADIUS distribution; used external
-    rlm_eap_psk implementation from
-    http://perso.rd.francetelecom.fr/bersani/EAP_PSK/
- 	EAP-PSKWindowsimplementations.html
- 8) PEAPv1 used non-standard version negotiation (client had to force v1 even
-    though server reported v0 as the highest supported version)
- 
- 
- Automated tests:
- 
- FreeRADIUS (1.0pre and CVS snapshot)
- - EAP-MD5-Challenge
- - EAP-GTC
- - EAP-MSCHAPv2
- - EAP-TLS
- - EAP-PEAPv0 / MSCHAPv2
- - EAP-PEAPv0 / GTC
- - EAP-PEAPv0 / MD5-Challenge
- - EAP-TTLS / EAP-MD5-Challenge
- - EAP-TTLS / EAP-GTC
- - EAP-TTLS / EAP-MSCHAPv2
- - EAP-TTLS / CHAP
- - EAP-TTLS / PAP
- - EAP-TTLS / MSCHAP
- - EAP-TTLS / MSCHAPv2
- - EAP-SIM
- * not supported in FreeRADIUS
-   - EAP-PEAP / TLS (Unable to tunnel TLS inside of TLS)
-   - EAP-TTLS / EAP-TLS (Unable to tunnel TLS inside of TLS)
- 
- Microsoft Windows Server 2003 / IAS
- - EAP-TLS
- - EAP-PEAPv0 / MSCHAPv2
- - EAP-PEAPv0 / TLS
- - EAP-MD5
- * IAS does not seem to support other EAP methods
- 
- Funk Odyssey 2.01.00.653
- - EAP-TLS
- - EAP-PEAPv0 / MSCHAPv2
- - EAP-PEAPv0 / GTC
- - EAP-PEAPv1 / MSCHAPv2
- - EAP-PEAPv1 / GTC
-   Note: PEAPv1 requires TLS key derivation to use label "client EAP encryption"
- - EAP-TTLS / CHAP (using FreeRADIUS as inner auth srv)
- - EAP-TTLS / MSCHAP
- - EAP-TTLS / MSCHAPv2
- - EAP-TTLS / PAP
- - EAP-TTLS / EAP-MD5-Challenge (using FreeRADIUS as inner auth srv)
- - EAP-TTLS / EAP-GTC (using FreeRADIUS as inner auth srv)
- - EAP-TTLS / EAP-MSCHAPv2 (using FreeRADIUS as inner auth srv)
- - EAP-TTLS / EAP-TLS (using FreeRADIUS as inner auth srv)
- * not supported in Odyssey:
-   - EAP-MD5-Challenge
-   - EAP-GTC
-   - EAP-MSCHAPv2
-   - EAP-PEAP / MD5-Challenge
-   - EAP-PEAP / TLS
- 
- Funk Steel-Belted Radius Enterprise Edition v4.71.739
- - EAP-MD5-Challenge
- - EAP-MSCHAPv2
- - EAP-TLS
- - EAP-PEAPv0 / MSCHAPv2
- - EAP-PEAPv0 / MD5
- - EAP-PEAPv0 / TLS
- - EAP-PEAPv1 / MSCHAPv2
- - EAP-PEAPv1 / MD5
- - EAP-PEAPv1 / GTC
- - EAP-PEAPv1 / TLS
-   Note: PEAPv1 requires TLS key derivation to use label "client EAP encryption"
- - EAP-TTLS / CHAP
- - EAP-TTLS / MSCHAP
- - EAP-TTLS / MSCHAPv2
- - EAP-TTLS / PAP
- - EAP-TTLS / EAP-MD5-Challenge
- - EAP-TTLS / EAP-MSCHAPv2
- - EAP-TTLS / EAP-TLS
- 
- Meetinghouse Aegis 1.1.4
- - EAP-MD5-Challenge
- - EAP-GTC
- - EAP-MSCHAPv2
- - EAP-TLS
- - EAP-PEAPv0 / MSCHAPv2
- - EAP-PEAPv0 / TLS
- - EAP-PEAPv0 / GTC
- - EAP-PEAPv0 / MD5-Challenge
- - EAP-PEAPv1 / MSCHAPv2
- - EAP-PEAPv1 / TLS
- - EAP-PEAPv1 / GTC
- - EAP-PEAPv1 / MD5-Challenge
-   Note: PEAPv1 requires TLS key derivation to use label "client EAP encryption"
- - EAP-TTLS / CHAP
- - EAP-TTLS / MSCHAP
- - EAP-TTLS / MSCHAPv2
- - EAP-TTLS / PAP
- - EAP-TTLS / EAP-MD5-Challenge
- - EAP-TTLS / EAP-GTC
- - EAP-TTLS / EAP-MSCHAPv2
- * did not work
-   - EAP-TTLS / EAP-TLS
-     (Server rejects authentication without any reason in debug log. It
-      looks like the inner TLS negotiation starts properly and the last
-      packet from Supplicant looks like the one sent in the Phase 1. The
-      server generates a valid looking reply in the same way as in Phase
-      1, but then ends up sending Access-Reject. Maybe an issue with TTLS
-      fragmentation in the Aegis server(?) The packet seems to include
-      1328 bytes of EAP-Message and this may go beyond the fragmentation
-      limit with AVP encapsulation and TLS tunneling. Note: EAP-PEAP/TLS
-      did work, so this issue seems to be with something TTLS specific.)
- 
- Radiator 3.9 (eval, with all patches up to and including 2004-08-30)
- - EAP-MD5-Challenge
- - EAP-GTC
- - EAP-OTP
- - EAP-MSCHAPv2
- - EAP-TLS
- - EAP-PEAPv0 / MSCHAPv2
- - EAP-PEAPv0 / GTC
- - EAP-PEAPv0 / OTP
- - EAP-PEAPv0 / MD5-Challenge
- - EAP-PEAPv0 / TLS
-   Note: Needed to use unknown identity in outer auth and some times the server
- 	seems to get confused and fails to send proper Phase 2 data.
- - EAP-PEAPv1 / MSCHAPv2
- - EAP-PEAPv1 / GTC
- - EAP-PEAPv1 / OTP
- - EAP-PEAPv1 / MD5-Challenge
- - EAP-PEAPv1 / TLS
-   Note: This has some additional requirements for EAPTLS_MaxFragmentSize.
-         Using 1300 for outer auth and 500 for inner auth seemed to work.
-   Note: Needed to use unknown identity in outer auth and some times the server
- 	seems to get confused and fails to send proper Phase 2 data.
- - EAP-TTLS / CHAP
- - EAP-TTLS / MSCHAP
- - EAP-TTLS / MSCHAPv2
- - EAP-TTLS / PAP
- - EAP-TTLS / EAP-MD5-Challenge
- - EAP-TTLS / EAP-GTC
- - EAP-TTLS / EAP-OTP
- - EAP-TTLS / EAP-MSCHAPv2
- - EAP-TTLS / EAP-TLS
-   Note: This has some additional requirements for EAPTLS_MaxFragmentSize.
-         Using 1300 for outer auth and 500 for inner auth seemed to work.
- - EAP-SIM
- - EAP-AKA
- 
- Interlink Networks RAD-Series 6.1.2.7
- - EAP-MD5-Challenge
- - EAP-GTC
- - EAP-MSCHAPv2
- - EAP-TLS
- - EAP-PEAPv0 / MSCHAPv2
- - EAP-PEAPv0 / GTC
- - EAP-PEAPv0 / MD5-Challenge
- - EAP-PEAPv1 / MSCHAPv2
- - EAP-PEAPv1 / GTC
- - EAP-PEAPv1 / MD5-Challenge
-   Note: PEAPv1 requires TLS key derivation to use label "client EAP encryption"
- - EAP-TTLS / CHAP
- - EAP-TTLS / MSCHAP
- - EAP-TTLS / MSCHAPv2
- - EAP-TTLS / PAP
- - EAP-TTLS / EAP-MD5-Challenge
- - EAP-TTLS / EAP-GTC
- - EAP-TTLS / EAP-MSCHAPv2
- - EAP-TTLS / EAP-TLS
- * did not work
-   - EAP-PEAPv0 / TLS
-   - EAP-PEAPv1 / TLS
-     (Failed to decrypt Phase 2 data)
- 
- Lucent NavisRadius 4.4.0
- - EAP-MD5-Challenge
- - EAP-GTC
- - EAP-MSCHAPv2
- - EAP-TLS
- - EAP-PEAPv0 / MD5-Challenge
- - EAP-PEAPv0 / MSCHAPv2
- - EAP-PEAPv0 / GTC
- - EAP-PEAPv0 / TLS
- - EAP-PEAPv1 / MD5-Challenge
- - EAP-PEAPv1 / MSCHAPv2
- - EAP-PEAPv1 / GTC
- - EAP-PEAPv1 / TLS
-   "IETF Draft 5" mode requires phase1="peap_outer_success=0 peaplabel=1"
-   'Cisco ACU 5.05' mode works without phase1 configuration
- - EAP-TTLS / CHAP
- - EAP-TTLS / MSCHAP
- - EAP-TTLS / MSCHAPv2
- - EAP-TTLS / PAP
- - EAP-TTLS / EAP-MD5-Challenge
- - EAP-TTLS / EAP-MSCHAPv2
- - EAP-TTLS / EAP-GTC
- - EAP-TTLS / EAP-TLS
- 
- Note: user certificate from NavisRadius had private key in a format
- that wpa_supplicant could not use. Converting this to PKCS#12 and then
- back to PEM allowed wpa_supplicant to use the key.
- 
- 
- hostapd v0.3.3
- - EAP-MD5-Challenge
- - EAP-GTC
- - EAP-MSCHAPv2
- - EAP-TLS
- - EAP-PEAPv0 / MSCHAPv2
- - EAP-PEAPv0 / GTC
- - EAP-PEAPv0 / MD5-Challenge
- - EAP-PEAPv1 / MSCHAPv2
- - EAP-PEAPv1 / GTC
- - EAP-PEAPv1 / MD5-Challenge
- - EAP-TTLS / CHAP
- - EAP-TTLS / MSCHAP
- - EAP-TTLS / MSCHAPv2
- - EAP-TTLS / PAP
- - EAP-TTLS / EAP-MD5-Challenge
- - EAP-TTLS / EAP-GTC
- - EAP-TTLS / EAP-MSCHAPv2
- - EAP-SIM
- - EAP-PAX
- 
- Cisco Secure ACS 3.3(1) for Windows Server
- - PEAPv1/GTC worked, but PEAPv0/GTC failed in the end after password was
-   sent successfully; ACS is replying with empty PEAP packet (TLS ACK);
-   wpa_supplicant tries to decrypt this.. Replying with TLS ACK and and
-   marking the connection completed was enough to make this work.
- 
- 
- PEAPv1:
- 
- Funk Odyssey 2.01.00.653:
- - uses tunneled EAP-Success, expects reply in tunnel or TLS ACK, sends MPPE
-   keys with outer EAP-Success message after this
- - uses label "client EAP encryption"
- - (peap_outer_success 1 and 2 work)
- 
- Funk Steel-Belted Radius Enterprise Edition v4.71.739
- - uses tunneled EAP-Success, expects reply in tunnel or TLS ACK, sends MPPE
-   keys with outer EAP-Success message after this
- - uses label "client EAP encryption"
- - (peap_outer_success 1 and 2 work)
- 
- Radiator 3.9:
- - uses TLV Success and Reply, sends MPPE keys with outer EAP-Success message
-   after this
- - uses label "client PEAP encryption"
- 
- Lucent NavisRadius 4.4.0 (in "IETF Draft 5" mode):
- - sends tunneled EAP-Success with MPPE keys and expects the authentication to
-   terminate at this point (gets somewhat confused with reply to this)
- - uses label "client PEAP encryption"
- - phase1="peap_outer_success=0 peaplabel=1"
- 
- Lucent NavisRadius 4.4.0 (in "Cisco ACU 5.05" mode):
- - sends tunneled EAP-Success with MPPE keys and expects to receive TLS ACK
-   as a reply
- - uses label "client EAP encryption"
- 
- Meetinghouse Aegis 1.1.4
- - uses tunneled EAP-Success, expects reply in tunnel or TLS ACK, sends MPPE
-   keys with outer EAP-Success message after this
- - uses label "client EAP encryption"
- - peap_outer_success 1 and 2 work
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/eap_wsc.c wpa_view/wpa_suppl/eap_wsc.c
*** wpa_supplicant-0.5.7/eap_wsc.c	Thu Jan  1 02:00:00 1970
--- wpa_view/wpa_suppl/eap_wsc.c	Wed Jun  9 13:30:12 2010
***************
*** 0 ****
--- 1,3019 ----
+ /*
+  * eap_wsc.c
+  *
+  * Copyright 2001-2009 Texas Instruments, Inc. - http://www.ti.com/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  * Alternatively, this software may be distributed under the terms of BSD
+  * license.
+  *
+  * See README and COPYING for more details.
+  */
+ 
+ #include "includes.h"
+ 
+ #include "ossl_typ.h"
+ #include "rand.h"
+ #include "bn.h"
+ #include "dh.h"
+ #include "sha.h"
+ #include "openssl-0.9.8e/include/openssl/evp.h"
+ #include "hmac.h"
+ #include "err.h"
+ 
+ #include "common.h"
+ #include "eap_i.h"
+ 
+ #include "bufferObj.h"
+ #include "CipherWrapper.h"
+ #include "WscTypes.h"
+ #include "wsc_supplicant.h"
+ #include "config_ssid.h"
+ 
+ /* WSC Message types (opCode) */
+ #define WSC_Start 			0x01
+ #define WSC_ACK   			0x02
+ #define WSC_NACK  			0x03
+ #define WSC_MSG   			0x04
+ #define WSC_Done  			0x05
+ 
+ #define WSC_EAP_CODE_RESPONSE		2
+ #define WSC_EAP_TYPE				254
+ #define WSC_VENDORID_0				0x00
+ #define WSC_VENDORID_1				0x37
+ #define WSC_VENDORID_2				0x2A
+ #define WSC_VENDORTYPE				0x00000001
+ #define WSC_EAP_PACKET_HEADER_LEN	14
+ 
+ #define MAC_ADDRESS_SIZE	6
+ 
+ #define PERSONALIZATION_STRING  "Wi-Fi Easy and Secure Key Derivation"
+ 
+ typedef enum {
+     WSC_ID_MESSAGE_START= 0x00, 
+     WSC_ID_MESSAGE_M1	= 	0x04,
+     WSC_ID_MESSAGE_M2	= 	0x05,
+     WSC_ID_MESSAGE_M2D = 	0x06,
+     WSC_ID_MESSAGE_M3	= 	0x07,
+     WSC_ID_MESSAGE_M4	= 	0x08,
+     WSC_ID_MESSAGE_M5	= 	0x09,
+     WSC_ID_MESSAGE_M6	= 	0x0A,
+     WSC_ID_MESSAGE_M7	= 	0x0B,
+     WSC_ID_MESSAGE_M8	= 	0x0C,
+ 	WSC_ID_MESSAGE_ACK = 	0x0D,
+ 	WSC_ID_MESSAGE_NACK =	0x0E,
+     WSC_ID_MESSAGE_DONE =	0x0F,
+     WSC_ID_MESSAGE_UNKNOWN = 0xFF
+ } EEapWscMsgType;
+ 
+ /* data structures for each instance of registration protocol */
+ typedef enum {
+     EAP_WSC_STATE_START = 0,
+     EAP_WSC_STATE_CONTINUE,
+     EAP_WSC_STATE_SUCCESS, 
+     EAP_WSC_STATE_FAILURE
+ } EEapWsc_SMState;
+ 
+ typedef struct
+ {
+ 	u16 				category_id;
+ 	u32 				oui; /* =0x0050F204 */
+ 	u16 				sub_category_id;
+ }	TEapWsc_DeviceType;
+ 
+ typedef struct
+ {
+ 	u8					isValid;  
+ 	u8					macAddress[MAC_ADDRESS_SIZE];
+ 	TEapWsc_DeviceType	peerType;
+ 	char				deviceName[MAX_DEVICE_NAME]; /* (0x1011) */
+ 	u8					password[MAX_PASSWORD_SIZE]; /* PIN */
+ 	u8 					uuidR[16]; /* (0x1048) */
+ 	u16 				authenticationTypeFlags; /* (0x1004) */
+ 	u16 				encryptionTypeFlags; /* (0x1010) */
+ 	u8 					connectionTypeFlags; /* (0x100D) */
+ 	u16 				configMethods; /* (0x1008) */
+ 	char 				manufacturer[MAX_MANUFACTURER]; /* (0x1021) */
+ 	char 				modelName[MAX_MODEL_NAME]; /* (0x1023) */
+ 	char 				modelNumber[MAX_MODEL_NUMBER]; /* (0x1024) */
+ 	char 				serialNumber[MAX_SERIAL_NUMBER]; /* (0x1042) */
+ 	u16 				serialNumberLength;
+ 	TEapWsc_DeviceType 	primaryDeviceType; /* (0x1054) */
+ 	u8 					rfBand; /* (0x103C) */
+ 	u16 				assocState; /* (0x1002) */
+ 	u16 				configError; /* (0x1009) */
+ 	u16 				devicePasswordId; /* (0x1012) */
+ 	u32 				osVersion; /* (0x102D) */
+ 
+ } TEapWsc_DeviceInfo;
+ 
+ typedef struct
+ {
+ 	TWscSupplicant* pWscSupplicantConfig;
+ 	EEapWsc_SMState 	smState;
+     struct eap_sm 		*sm;
+ 
+ 	u8       			enrolleeNonce[SIZE_128_BITS]; /* N1 */
+ 	u8       			registrarNonce[SIZE_128_BITS]; /* N2 */
+ 
+ 	BIGNUM      		*DH_PubKey_Peer; /* peer's pub key stored in bignum format */
+ 	DH          		*DHSecret;       /* local key pair in bignum format */
+ 	
+ 	u8       			pke[SIZE_PUB_KEY]; /* enrollee's raw pub key */
+ 	u8					pkr[SIZE_PUB_KEY]; /* registrar's raw pub key */
+ 
+ 	bufferObj			authKey;
+ 	bufferObj   		keyWrapKey;
+     //bufferObj   		emsk;
+ 
+ 	u8       			psk1[SIZE_128_BITS];
+     u8					psk2[SIZE_128_BITS];
+ 
+ 	u8					es1[SIZE_128_BITS];
+     u8					es2[SIZE_128_BITS];
+ 
+ 	u8					eHash1[SIZE_256_BITS];
+     u8					eHash2[SIZE_256_BITS];
+ 
+ 	u8       			rs1[SIZE_128_BITS];
+     u8       			rs2[SIZE_128_BITS];
+ 
+ 	u8					rHash1[SIZE_256_BITS];
+     u8					rHash2[SIZE_256_BITS]; 
+ 
+ 	u32					LastMessageSent;
+ 	u32					LastMessageRecv;
+ 
+ 	/* in/outMsg must store previous message in order to compute hash */
+     bufferObj   		InMsg;      /* Received message will be stored here */
+     bufferObj   		OutMsg;     /* Contains message to be transmitted */
+ 
+ 	TEapWsc_DeviceInfo	*pPeerDeviceInfo;        
+ 
+ 	TStaEncryptSettings	*pStaEncryptSettings;
+ 	
+ } TEapWsc;
+ 
+ typedef struct
+ {
+     u8 	code;
+     u8 	id;
+     u16	len; /* of the entire eap packet, i.e. including header and data */
+     u8 	type;
+     u8 	vendorId[3];
+     u32 vendorType;
+ 	u8 	opCode;
+ 	u8 	flags;	/* The message might be fragmented, flag for first fragment (only he carries the size of the message) */
+ } TEapWscPacketHeader;
+ 
+ /* TLV header */
+ typedef struct {
+     u16 attributeType;
+     u16 dataLength;
+ } TTlvHeader;
+ 
+ 
+ /* process message methods */
+ /* Field verification. Returns the position of the field' value in the msg buffer.*/
+ static u8* EapWsc_ParseField(bufferObj *pInMsg, u16 theType, u32 minDataSize, u32 maxDataSize, u8 complexed, int *dataLen) 
+ {
+     /* Extracts the type and the length. Positions pos to point to the data */
+ 	u16 len;
+ 	u8 *pos;
+ 	u32 remaining = bufferRemaining(pInMsg);
+ 	u16 tmpType, InBufferType;
+ 
+ 	pos = bufferPos(pInMsg);
+ 	if (remaining < sizeof(TTlvHeader) + minDataSize)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ParseField: insufficient buffer size");
+         return NULL;
+ 	}
+ 
+ 	memcpy(&InBufferType, pos, sizeof(u16));
+ 
+ 	tmpType = ntohs(InBufferType);
+ 	if (theType != tmpType) 
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ParseField: unexpected type: %d", tmpType);
+ 				return NULL;
+ 			}
+ 
+     pos += sizeof(u16); /* advance to length field */
+ 
+ 	memcpy(&InBufferType, pos, sizeof(u16));
+ 
+ 	len = ntohs(InBufferType);
+ 
+     if (minDataSize > len)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ParseField: length field of type %d is too small", theType);
+         return NULL;
+ 	}
+     if (maxDataSize && (len > maxDataSize))
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ParseField: length field of type %d is greater than expected", theType);
+         return NULL;
+ 	}
+ 
+     if (len + sizeof(TTlvHeader) > remaining)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ParseField: buffer overflow error");
+         return NULL;
+ 	}
+     
+     pos += sizeof(u16); /* advance to data field */
+ 	if (complexed)
+ 	{
+ 		bufferAdvance(pInMsg, 2 * sizeof(u16));
+ 	}
+ 	else
+ 	{
+ 		bufferAdvance(pInMsg, 2 * sizeof(u16) + len);
+ 	}
+ 
+ 	if (dataLen)
+ 	{
+ 		*dataLen = len; /* return the field data length */
+ 	}
+ 
+ 	return pos; /* holds the current position (of the fields' value) */
+ }
+ 
+ static u32 EapWsc_ParseValue8(bufferObj *pInMsg, u16 theType, u8 *value) 
+ {
+ 	u32 minDataSize = sizeof(u8);
+ 	u8 *valuePos;
+ 	
+ 	valuePos = NULL;
+ 
+ 	valuePos = EapWsc_ParseField(pInMsg, theType, minDataSize, 0, 0, NULL);
+ 	if (valuePos == NULL)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ParseValue8: Invalid field of type: %d", theType);
+ 		return NOK;
+ 	}
+ 
+ 	/* The specific Tlv Object */
+     *value = *(u8 *)valuePos;
+ 	
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_ParseValue16(bufferObj *pInMsg, u16 theType, u16 *value) 
+ {
+ 	u32 minDataSize = sizeof(u16);
+ 	u8 *valuePos;
+ 
+ 	valuePos = NULL;
+ 
+ 	valuePos = EapWsc_ParseField(pInMsg, theType, minDataSize, 0, 0, NULL);
+ 	if (valuePos == NULL)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ParseValue16: Invalid field of type: %d", theType);
+ 		return NOK;
+ 	}
+ 
+ 	/* The specific Tlv Object */
+     memcpy(value, valuePos, 2);
+ 	*value = ntohs(*value);
+ 
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_ParseValue32(bufferObj *pInMsg, u16 theType, u32 *value) 
+ {
+ 	u32 minDataSize = sizeof(u32);
+ 	u8 *valuePos;
+ 	valuePos = NULL;
+ 
+ 	valuePos = EapWsc_ParseField(pInMsg, theType, minDataSize, 0, 0, NULL);
+ 	if (valuePos == NULL)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ParseValue32: Invalid field of type: %d", theType);
+ 		return NOK;
+ 	}
+ 
+ 	/* The specific Tlv Object */
+ 	memcpy(value, valuePos, 4);
+ 	*value = ntohl(*value);
+ 	
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_ParseValuePtr(bufferObj *pInMsg, u16 theType, u32 maxDataSize, TLVPUINT8 *value) 
+ {
+ 	u32 minDataSize = 0;
+ 	u8 *valuePos;
+ 
+ 	valuePos = NULL;
+ 
+ 	valuePos = EapWsc_ParseField(pInMsg, theType, minDataSize, maxDataSize, 0, &(value->length));
+ 	if (valuePos == NULL)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ParseValuePtr: Invalid field of type: %d", theType);
+ 		return NOK;
+ 	}
+ 
+ 	/* The specific Tlv Object - return the pointer itself */
+     value->pValue = (u8 *)valuePos;
+ 	
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_ParseCharPtr(bufferObj *pInMsg, u16 theType, u32 maxDataSize, TLVPCHAR *value)
+ {
+ 	u32 minDataSize = 0;
+ 	u8 *valuePos;
+ 	
+ 	valuePos = NULL;
+ 
+ 	valuePos = EapWsc_ParseField(pInMsg, theType, minDataSize, maxDataSize, 0, &(value->length));
+ 	if (valuePos == NULL)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ParseCharPtr: Invalid field of type: %d", theType);
+ 		return NOK;
+ 	}
+ 
+ 	/* The specific Tlv Object - return the pointer itself */
+     value->pValue = (char *)valuePos;
+ 	
+ 	return OK;
+ }
+ 
+ static void EapWsc_FreeEncryptSettings(TEapWsc *pEapWsc)
+ {
+ 	int i;
+ 	if(pEapWsc->pStaEncryptSettings)
+ 	{
+ 		if(pEapWsc->pStaEncryptSettings->credential.ssid.pValue)
+ 		{
+ 			free(pEapWsc->pStaEncryptSettings->credential.ssid.pValue);			
+ 		}
+ 
+ 		for (i=0; i<MAX_NETWORK_KEY_NUM; i++)
+ 		{
+ 			if(pEapWsc->pStaEncryptSettings->credential.nwKey[i].pValue)
+ 		{
+ 				free(pEapWsc->pStaEncryptSettings->credential.nwKey[i].pValue);
+ 			}
+ 		}
+ 		if(pEapWsc->pStaEncryptSettings->credential.macAddr.pValue)
+ 		{
+ 			free(pEapWsc->pStaEncryptSettings->credential.macAddr.pValue);			
+ 		}
+ 		if(pEapWsc->pStaEncryptSettings->credential.eapType.pValue)
+ 		{
+ 			free(pEapWsc->pStaEncryptSettings->credential.eapType.pValue);
+ 		}
+ 		if(pEapWsc->pStaEncryptSettings->credential.eapIdentity.pValue)
+ 		{
+ 			free(pEapWsc->pStaEncryptSettings->credential.eapIdentity.pValue);
+ 		}
+ 		if(pEapWsc->pStaEncryptSettings->credential.rekeyKey.pValue)
+ 		{
+ 			free(pEapWsc->pStaEncryptSettings->credential.rekeyKey.pValue);
+ 		}
+ 		if(pEapWsc->pStaEncryptSettings->credential.x509Cert.pValue)
+ 		{
+ 			free(pEapWsc->pStaEncryptSettings->credential.x509Cert.pValue);
+ 		}
+ 		if(pEapWsc->pStaEncryptSettings->new_pwd.pValue)
+ 		{
+ 			free(pEapWsc->pStaEncryptSettings->new_pwd.pValue);
+ 		}
+ 		if(pEapWsc->pStaEncryptSettings->keyWrapAuth.pValue)
+ 		{
+ 			free(pEapWsc->pStaEncryptSettings->keyWrapAuth.pValue);
+ 		}
+ 
+ 		free(pEapWsc->pStaEncryptSettings);
+ 		pEapWsc->pStaEncryptSettings = NULL;
+ 	}
+ 	
+ }
+ 
+ static u32 EapWsc_BuildMsgAck(TEapWsc *pEapWsc, bufferObj* pOutMsg)
+ {
+ 	u8 msgType = WSC_ID_MESSAGE_ACK;
+ 
+ 	/* create Msg */
+ 	bufferCreateChunk(pOutMsg);
+ 
+ 	/* u8 version */
+ 	wsc_supplicant_SerializeField(WSC_ID_VERSION, pOutMsg, SIZE_VERSION, &(pEapWsc->pWscSupplicantConfig->version));
+ 
+ 	/* u8 msgType */
+ 	wsc_supplicant_SerializeField(WSC_ID_MSG_TYPE, pOutMsg, SIZE_MSG_TYPE, &msgType);
+ 
+ 	/* u8 *enrolleeNonce ;16B=128 bits */
+ 	wsc_supplicant_SerializeField(WSC_ID_ENROLLEE_NONCE, pOutMsg, SIZE_ENROLLEE_NONCE, pEapWsc->enrolleeNonce);
+ 
+ 	/* u8 *registrarNonce ;16B=128 bits */
+ 	wsc_supplicant_SerializeField(WSC_ID_REGISTRAR_NONCE, pOutMsg, SIZE_REGISTRAR_NONCE, pEapWsc->registrarNonce);
+ 
+ 	wpa_printf(MSG_INFO,"EAP-WSC: EapWsc_BuildMsgAck: built %d byte message", bufferLength(pOutMsg));
+ 
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_BuildMsgM1(TEapWsc *pEapWsc, bufferObj* pOutMsg)
+ {
+ 	u8 msgType = WSC_ID_MESSAGE_M1;
+ 	int len;
+ 
+     /* First generate/gather all the required data.*/
+ 
+     /* Enrollee nonce N1 (openssl-generated) */
+     RAND_bytes(pEapWsc->enrolleeNonce, SIZE_128_BITS);
+ 
+     if(!pEapWsc->DHSecret)
+     {
+         if (cipherGenerateDHKeyPair(&pEapWsc->DHSecret) != OK)
+ 		{
+ 			wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_BuildMsgM1: Failure in cipherGenerateDHKeyPair.");
+ 			return NOK;
+ 		}
+     }
+ 
+     /* Extract the DH public key */
+     len = BN_bn2bin(pEapWsc->DHSecret->pub_key, pEapWsc->pke);
+     if (len == 0)
+     {
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_BuildMsgM1: Failure in BN_bn2bin: %s", ERR_error_string(ERR_get_error(), NULL));
+         return NOK;
+     }
+ 
+ 	/* create Msg */
+ 	bufferCreateChunk(pOutMsg);
+ 
+     /* Now start composing the message */
+ 
+ 	/* u8 version */
+ 	wsc_supplicant_SerializeField(WSC_ID_VERSION, pOutMsg, SIZE_VERSION, &(pEapWsc->pWscSupplicantConfig->version));
+ 
+ 	/* u8 msgType */
+ 	wsc_supplicant_SerializeField(WSC_ID_MSG_TYPE, pOutMsg, SIZE_MSG_TYPE, &msgType);
+ 
+ 	/* u8 *uuid ;16B=128 bits */
+ 	wsc_supplicant_SerializeField(WSC_ID_UUID_E, pOutMsg, SIZE_UUID, pEapWsc->pWscSupplicantConfig->uuidE);
+ 
+ 	/* u8 *macAddr; 6B */
+ 	wsc_supplicant_SerializeField(WSC_ID_MAC_ADDR, pOutMsg, ETH_ALEN, pEapWsc->pWscSupplicantConfig->macAddress);
+ 
+ 	/* u8 *enrolleeNonce ;16B=128 bits */
+ 	wsc_supplicant_SerializeField(WSC_ID_ENROLLEE_NONCE, pOutMsg, SIZE_ENROLLEE_NONCE, pEapWsc->enrolleeNonce);
+ 
+ 	/* u8 *publicKey ;192B */
+ 	wsc_supplicant_SerializeField(WSC_ID_PUBLIC_KEY, pOutMsg, SIZE_PUB_KEY, pEapWsc->pke);
+ 
+ 	/* u16 authTypeFlags */
+ 	wsc_supplicant_SerializeField(WSC_ID_AUTH_TYPE_FLAGS, pOutMsg, SIZE_AUTH_TYPE_FLAGS, (u8 *)&(pEapWsc->pWscSupplicantConfig->authenticationTypeFlags));
+ 
+ 	/* u16 encryptionTypeFlags */
+ 	wsc_supplicant_SerializeField(WSC_ID_ENCR_TYPE_FLAGS, pOutMsg, SIZE_ENCR_TYPE_FLAGS, (u8 *)&(pEapWsc->pWscSupplicantConfig->encryptionTypeFlags));
+ 
+ 	/* u8 connectionTypeFlags */
+ 	wsc_supplicant_SerializeField(WSC_ID_CONN_TYPE_FLAGS, pOutMsg, SIZE_CONN_TYPE_FLAGS, &(pEapWsc->pWscSupplicantConfig->connectionTypeFlags));
+ 
+ 	/* u16 configMethods */
+ 	wsc_supplicant_SerializeField(WSC_ID_CONFIG_METHODS, pOutMsg, SIZE_CONFIG_METHODS, (u8 *)&(pEapWsc->pWscSupplicantConfig->configMethods));
+ 
+ 	/* u8 state */
+ 	wsc_supplicant_SerializeField(WSC_ID_SC_STATE, pOutMsg, SIZE_SC_STATE, &(pEapWsc->pWscSupplicantConfig->state));
+ 
+ 	/* char *manufacturer; 64B */
+ 	wsc_supplicant_SerializeField(WSC_ID_MANUFACTURER, pOutMsg, SIZE_MANUFACTURER, (u8 *)pEapWsc->pWscSupplicantConfig->manufacturer); /* although it has max. 64B */
+ 
+ 	/* char *modelName; 32B */
+ 	wsc_supplicant_SerializeField(WSC_ID_MODEL_NAME, pOutMsg, SIZE_MODEL_NAME, (u8 *)pEapWsc->pWscSupplicantConfig->modelName);
+ 
+ 	/* char *modelNumber; 32B */
+ 	wsc_supplicant_SerializeField(WSC_ID_MODEL_NUMBER, pOutMsg, SIZE_MODEL_NUMBER, (u8 *)pEapWsc->pWscSupplicantConfig->modelNumber);
+ 
+ 	/* char *serialNumber; 32B */
+ 	wsc_supplicant_SerializeField(WSC_ID_SERIAL_NUM, pOutMsg, SIZE_SERIAL_NUMBER, (u8 *)pEapWsc->pWscSupplicantConfig->serialNumber);
+ 
+ 	/* sc_device_type_t primaryDeviceType; 8B */
+ 	wsc_supplicant_SerializeHeader(WSC_ID_PRIM_DEV_TYPE, SIZE_PRIM_DEV_TYPE, pOutMsg);
+ 	bufferAppend(pOutMsg, SIZE_PRIM_DEV_CAT_ID, (u8 *)&(pEapWsc->pWscSupplicantConfig->primaryDeviceType.category_id));
+ 	bufferAppend(pOutMsg, SIZE_PRIM_DEV_OUI, (u8 *)&(pEapWsc->pWscSupplicantConfig->primaryDeviceType.oui));
+ 	bufferAppend(pOutMsg, SIZE_PRIM_DEV_SUB_CAT_ID, (u8 *)&(pEapWsc->pWscSupplicantConfig->primaryDeviceType.sub_category_id));
+ 
+ 	/* char *deviceName; 32B */
+ 	wsc_supplicant_SerializeField(WSC_ID_DEVICE_NAME, pOutMsg, SIZE_DEVICE_NAME, (u8 *)pEapWsc->pWscSupplicantConfig->deviceName);
+ 
+ 	/* u8 rfBand */
+ 	wsc_supplicant_SerializeField(WSC_ID_RF_BAND, pOutMsg, SIZE_RF_BAND, &(pEapWsc->pWscSupplicantConfig->rfBand));
+ 
+ 	/* u16 assocState */
+ 	wsc_supplicant_SerializeField(WSC_ID_ASSOC_STATE, pOutMsg, SIZE_ASSOC_STATE, (u8 *)&(pEapWsc->pWscSupplicantConfig->assocState));
+ 
+ 	/* u16 devicePasswordId */
+ 	wsc_supplicant_SerializeField(WSC_ID_DEVICE_PWD_ID, pOutMsg, SIZE_DEVICE_PWD_ID, (u8 *)&(pEapWsc->pWscSupplicantConfig->devicePasswordId));
+ 
+ 	/* u16 configError */
+ 	wsc_supplicant_SerializeField(WSC_ID_CONFIG_ERROR, pOutMsg, SIZE_CONFIG_ERROR, (u8 *)&(pEapWsc->pWscSupplicantConfig->configError));
+ 
+ 	/* u32 osVersion */
+ 	wsc_supplicant_SerializeField(WSC_ID_OS_VERSION, pOutMsg, SIZE_OS_VERSION, (u8 *)&(pEapWsc->pWscSupplicantConfig->osVersion));
+ 
+     /* skip optional attributes */
+ 
+ 	/* Store the outgoing message */
+ 	bufferReset(&(pEapWsc->OutMsg));
+ 	bufferAppend(&(pEapWsc->OutMsg), bufferLength(pOutMsg), bufferGetBuf(pOutMsg));
+ 
+ 	
+ 	wpa_printf(MSG_INFO,"EAP-WSC: EapWsc_BuildMsgM1: built %d byte message", bufferLength(pOutMsg));
+ 
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_ProcessMsgM2D(TEapWsc *pEapWsc, bufferObj* pInMsg)
+ {
+ 	u8 version;
+ 	u8 msgType;
+ 	TLVPUINT8 tmpLVPUINT8;
+ 	TLVPCHAR tmpLVPCHAR;
+ 	u8 *tmpPos;
+ 	u16 TempInBuffer;
+ 
+ 	wpa_printf(MSG_INFO,"EAP-WSC: EapWsc_ProcessMsgM2D: EapWsc_ProcessMsgM2D of %d byte message", bufferLength(pInMsg));
+ 
+ 	/* First and foremost, check the version and message number.*/
+ 	/* Don't deserialize (parse) incompatible messages! */
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_VERSION, &version) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_VERSION);
+ 		return NOK;
+ 	}
+ 
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_MSG_TYPE, &msgType) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_MSG_TYPE);
+ 		return NOK;
+ 	}
+ 
+ 	/* u8 *enrolleeNonce ;16B=128 bits */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_ENROLLEE_NONCE, MAX_ENROLLEE_NONCE, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_ENROLLEE_NONCE);
+ 		return NOK;
+ 	}
+ 
+ 	/* confirm the enrollee nonce */
+ 	if (memcmp(pEapWsc->enrolleeNonce, tmpLVPUINT8.pValue, tmpLVPUINT8.length))
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Incorrect enrollee nonce received");
+ 		return NOK;
+ 	}
+ 
+ 	/* u8 *registrarNonce ;16B=128 bits */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_REGISTRAR_NONCE, MAX_REGISTRAR_NONCE, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_REGISTRAR_NONCE);
+ 		return NOK;
+ 	}
+     memcpy(pEapWsc->registrarNonce, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 
+     /* First, check if we need to allocate peerDeviceInfo */
+     if (!pEapWsc->pPeerDeviceInfo)
+ 	{
+ 		pEapWsc->pPeerDeviceInfo = malloc(sizeof(TEapWsc_DeviceInfo));
+ 		if (pEapWsc->pPeerDeviceInfo == NULL)
+ 		{
+ 			wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to allocate memory (peerDeviceInfo)");
+ 			return NOK;
+ 		}
+ 		memset(pEapWsc->pPeerDeviceInfo, 0, sizeof(TEapWsc_DeviceInfo));
+ 	}
+ 
+ 	/* u8 *uuid ;16B=128 bits */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_UUID_R, MAX_UUID, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_UUID_R);
+ 		free(pEapWsc->pPeerDeviceInfo);
+ 		return NOK;
+ 	}
+     memcpy(pEapWsc->pPeerDeviceInfo->uuidR, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 
+ 	/* u16 authTypeFlags */
+ 	if (EapWsc_ParseValue16(pInMsg, WSC_ID_AUTH_TYPE_FLAGS, &(pEapWsc->pPeerDeviceInfo->authenticationTypeFlags)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_AUTH_TYPE_FLAGS);
+ 		free(pEapWsc->pPeerDeviceInfo);
+ 		return NOK;
+ 	}
+ 
+ 	/* u16 encrTypeFlags */
+ 	if (EapWsc_ParseValue16(pInMsg, WSC_ID_ENCR_TYPE_FLAGS, &(pEapWsc->pPeerDeviceInfo->encryptionTypeFlags)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_ENCR_TYPE_FLAGS);
+ 		free(pEapWsc->pPeerDeviceInfo);
+ 		return NOK;
+ 	}
+             
+ 	/* u8 connectionTypeFlags */
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_CONN_TYPE_FLAGS, &(pEapWsc->pPeerDeviceInfo->connectionTypeFlags)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_CONN_TYPE_FLAGS);
+ 		free(pEapWsc->pPeerDeviceInfo);
+ 		return NOK;
+ 	}
+ 
+ 	/* u16 configMethods */
+ 	if (EapWsc_ParseValue16(pInMsg, WSC_ID_CONFIG_METHODS, &(pEapWsc->pPeerDeviceInfo->configMethods)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_CONFIG_METHODS);
+ 		free(pEapWsc->pPeerDeviceInfo);
+ 		return NOK;
+ 	}
+ 
+ 	/* char *manufacturer; 64B */
+ 	if (EapWsc_ParseCharPtr(pInMsg, WSC_ID_MANUFACTURER, MAX_MANUFACTURER, &tmpLVPCHAR) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_MANUFACTURER);
+ 		free(pEapWsc->pPeerDeviceInfo);
+ 		return NOK;
+ 	}
+ 	strncpy(pEapWsc->pPeerDeviceInfo->manufacturer, tmpLVPCHAR.pValue, tmpLVPCHAR.length);
+ 
+ 	/* char *modelName; 32B */
+ 	if (EapWsc_ParseCharPtr(pInMsg, WSC_ID_MODEL_NAME, MAX_MODEL_NAME, &tmpLVPCHAR) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_MODEL_NAME);
+ 		free(pEapWsc->pPeerDeviceInfo);
+ 		return NOK;
+ 	}
+ 	strncpy(pEapWsc->pPeerDeviceInfo->modelName, tmpLVPCHAR.pValue, tmpLVPCHAR.length);
+ 
+ 	/* char *modelNumber; 32B */
+ 	if (EapWsc_ParseCharPtr(pInMsg, WSC_ID_MODEL_NUMBER, MAX_MODEL_NUMBER, &tmpLVPCHAR) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_MODEL_NUMBER);
+ 		free(pEapWsc->pPeerDeviceInfo);
+ 		return NOK;
+ 	}
+ 	strncpy(pEapWsc->pPeerDeviceInfo->modelNumber, tmpLVPCHAR.pValue, tmpLVPCHAR.length);
+ 
+ 	/* char *serialNumber; 32B */
+ 	if (EapWsc_ParseCharPtr(pInMsg, WSC_ID_SERIAL_NUM, MAX_SERIAL_NUMBER, &tmpLVPCHAR) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_SERIAL_NUM);
+ 		free(pEapWsc->pPeerDeviceInfo);
+ 		return NOK;
+ 	}
+ 	strncpy(pEapWsc->pPeerDeviceInfo->serialNumber, tmpLVPCHAR.pValue, tmpLVPCHAR.length);
+ 
+ 	/* sc_device_type_t primaryDeviceType; 8B */
+ 	tmpPos = EapWsc_ParseField(pInMsg, WSC_ID_PRIM_DEV_TYPE, SIZE_PRIM_DEV_TYPE, 0, 1 /* complexed field */, NULL);
+ 	if (!tmpPos) {
+ 		wpa_printf(MSG_ERROR, "EAP-WSC: %s: tmpPos is NULL", __FUNCTION__);
+ 		os_free(pEapWsc->pPeerDeviceInfo);
+ 		return NOK;
+ 	}
+ 	memcpy(&pEapWsc->pPeerDeviceInfo->primaryDeviceType.category_id, tmpPos, SIZE_PRIM_DEV_CAT_ID);
+     memcpy(&pEapWsc->pPeerDeviceInfo->primaryDeviceType.oui, bufferAdvance(pInMsg, SIZE_PRIM_DEV_CAT_ID), SIZE_PRIM_DEV_OUI);
+     memcpy(&pEapWsc->pPeerDeviceInfo->primaryDeviceType.sub_category_id, bufferAdvance(pInMsg, SIZE_PRIM_DEV_OUI), SIZE_PRIM_DEV_SUB_CAT_ID);
+     bufferAdvance(pInMsg, SIZE_PRIM_DEV_SUB_CAT_ID);
+ 
+ 	/* char *deviceName; 32B */
+ 	if (EapWsc_ParseCharPtr(pInMsg, WSC_ID_DEVICE_NAME, MAX_DEVICE_NAME, &tmpLVPCHAR) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_DEVICE_NAME);
+ 		free(pEapWsc->pPeerDeviceInfo);
+ 		return NOK;
+ 	}
+ 	strncpy(pEapWsc->pPeerDeviceInfo->deviceName, tmpLVPCHAR.pValue, tmpLVPCHAR.length);
+ 
+ 	/* u8 rfBand */
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_RF_BAND, &(pEapWsc->pPeerDeviceInfo->rfBand)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_RF_BAND);
+ 		free(pEapWsc->pPeerDeviceInfo);
+ 		return NOK;
+ 	}
+ 
+ 	/* u16 assocState */
+ 	if (EapWsc_ParseValue16(pInMsg, WSC_ID_ASSOC_STATE, &(pEapWsc->pPeerDeviceInfo->assocState)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_ASSOC_STATE);
+ 		free(pEapWsc->pPeerDeviceInfo);
+ 		return NOK;
+ 	}
+ 
+ 	/* u16 configError */
+ 	if (EapWsc_ParseValue16(pInMsg, WSC_ID_CONFIG_ERROR, &(pEapWsc->pPeerDeviceInfo->configError)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_CONFIG_ERROR);
+ 		free(pEapWsc->pPeerDeviceInfo);
+ 		return NOK;
+ 	}
+     
+ 	/* u32 osVersion */
+ 	if (EapWsc_ParseValue32(pInMsg, WSC_ID_OS_VERSION, &(pEapWsc->pPeerDeviceInfo->osVersion)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2D: Failed to parse field of type: %d", WSC_ID_OS_VERSION);
+ 		free(pEapWsc->pPeerDeviceInfo);
+ 		return NOK;
+ 	}
+ 
+ 	/* other attributes */
+ 	while (bufferRemaining(pInMsg) >= sizeof(TTlvHeader))
+ 	{
+ 		tmpPos = bufferPos(pInMsg);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 
+ 		switch (ntohs(TempInBuffer))
+ 		{
+ 			default:
+ 				/* advance past the TLV */
+ 				tmpPos += sizeof(u16); /* advance to length field */
+ 				memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 				bufferAdvance(pInMsg, sizeof(TTlvHeader) + ntohs(TempInBuffer));
+ 				break;
+ 		}
+ 	}
+ 
+ 	/* Store the received buffer */
+ 	bufferReset(&pEapWsc->InMsg);
+ 	bufferAppend(&pEapWsc->InMsg, bufferLength(pInMsg), bufferGetBuf(pInMsg));  
+ 
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_ProcessMsgM2(TEapWsc *pEapWsc, bufferObj* pInMsg)
+ {
+ 	u8 version;
+ 	u8 msgType;
+ 	TLVPUINT8 tmpLVPUINT8;
+ 	TLVPCHAR tmpLVPCHAR;
+ 	u8 *tmpPos;
+ 
+ 	u8 secret[SIZE_PUB_KEY]; /* holds g^(AB) mod P */
+ 	int secretLen = 0;
+ 	u8 DHKey[SIZE_256_BITS];
+ 	bufferObj kdkData;
+     u8 kdk[SIZE_256_BITS];
+     bufferObj kdkBuf;
+     bufferObj personalString;
+     bufferObj keys;
+ 	bufferObj hmacData;
+ 	u8 dataMac[BUF_SIZE_256_BITS];
+ 	u16 TempInBuffer, tmpType;
+ 
+ 	wpa_printf(MSG_INFO,"EAP-WSC: EapWsc_ProcessMsgM2: EapWsc_ProcessMsgM2 of %d byte message", bufferLength(pInMsg));
+ 
+ 	/* First and foremost, check the version and message number.*/
+ 	/* Don't deserialize (parse) incompatible messages! */
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_VERSION, &version) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_VERSION);
+ 		return NOK;
+ 	}
+ 
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_MSG_TYPE, &msgType) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_MSG_TYPE);
+ 		return NOK;
+ 	}
+ 
+ 	/* u8 *enrolleeNonce ;16B=128 bits */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_ENROLLEE_NONCE, MAX_ENROLLEE_NONCE, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_ENROLLEE_NONCE);
+ 		return NOK;
+ 	}
+ 	/* confirm the enrollee nonce */
+ 	if (memcmp(pEapWsc->enrolleeNonce, tmpLVPUINT8.pValue, tmpLVPUINT8.length))
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Incorrect enrollee nonce received");
+ 		return NOK;
+ 	}
+ 
+ 	/* u8 *registrarNonce ;16B=128 bits */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_REGISTRAR_NONCE, MAX_REGISTRAR_NONCE, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_REGISTRAR_NONCE);
+ 		return NOK;
+ 	}
+     memcpy(pEapWsc->registrarNonce, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 
+     /* First, check if we need to allocate peerDeviceInfo */
+     if (!pEapWsc->pPeerDeviceInfo)
+ 	{
+ 		pEapWsc->pPeerDeviceInfo = malloc(sizeof(TEapWsc_DeviceInfo));
+ 		if (pEapWsc->pPeerDeviceInfo == NULL)
+ 		{
+ 			wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to allocate memory (peerDeviceInfo)");
+ 			return NOK;
+ 		}
+ 		memset(pEapWsc->pPeerDeviceInfo, 0, sizeof(TEapWsc_DeviceInfo));
+ 	}
+ 
+ 	/* u8 *uuid ;16B=128 bits */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_UUID_R, MAX_UUID, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_UUID_R);
+ 		return NOK;
+ 	}
+     memcpy(pEapWsc->pPeerDeviceInfo->uuidR, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 
+ 	/* u8 *publicKey ;192B */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_PUBLIC_KEY, MAX_PUB_KEY, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_PUBLIC_KEY);
+ 		return NOK;
+ 	}
+ 	/* read the registrar's public key */
+     /* First store the raw public key (to be used for e/rhash computation) */
+     memcpy(pEapWsc->pkr, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 
+ 	/* u16 authTypeFlags */
+ 	if (EapWsc_ParseValue16(pInMsg, WSC_ID_AUTH_TYPE_FLAGS, &(pEapWsc->pPeerDeviceInfo->authenticationTypeFlags)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_AUTH_TYPE_FLAGS);
+ 		return NOK;
+ 	}
+ 
+ 	/* u16 encryptionTypeFlags */
+ 	if (EapWsc_ParseValue16(pInMsg, WSC_ID_ENCR_TYPE_FLAGS, &(pEapWsc->pPeerDeviceInfo->encryptionTypeFlags)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_ENCR_TYPE_FLAGS);
+ 		return NOK;
+ 	}
+ 
+ 	/* u8 connectionTypeFlags */
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_CONN_TYPE_FLAGS, &(pEapWsc->pPeerDeviceInfo->connectionTypeFlags)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_CONN_TYPE_FLAGS);
+ 		return NOK;
+ 	}
+ 
+ 	/* u16 configMethods */
+ 	if (EapWsc_ParseValue16(pInMsg, WSC_ID_CONFIG_METHODS, &(pEapWsc->pPeerDeviceInfo->configMethods)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_CONFIG_METHODS);
+ 		return NOK;
+ 	}
+ 
+ 	/* char *manufacturer; 64B */
+ 	if (EapWsc_ParseCharPtr(pInMsg, WSC_ID_MANUFACTURER, MAX_MANUFACTURER, &tmpLVPCHAR) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_MANUFACTURER);
+ 		return NOK;
+ 	}
+ 	strncpy(pEapWsc->pPeerDeviceInfo->manufacturer, tmpLVPCHAR.pValue, tmpLVPCHAR.length);
+ 
+ 	/* char *modelName; 32B */
+ 	if (EapWsc_ParseCharPtr(pInMsg, WSC_ID_MODEL_NAME, MAX_MODEL_NAME, &tmpLVPCHAR) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_MODEL_NAME);
+ 		return NOK;
+ 	}
+ 	strncpy(pEapWsc->pPeerDeviceInfo->modelName, tmpLVPCHAR.pValue, tmpLVPCHAR.length);
+ 
+ 	/* char *modelNumber; 32B */
+ 	if (EapWsc_ParseCharPtr(pInMsg, WSC_ID_MODEL_NUMBER, MAX_MODEL_NUMBER, &tmpLVPCHAR) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_MODEL_NUMBER);
+ 		return NOK;
+ 	}
+ 	strncpy(pEapWsc->pPeerDeviceInfo->modelNumber, tmpLVPCHAR.pValue, tmpLVPCHAR.length);
+ 
+ 	/* char *serialNumber; 32B */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_SERIAL_NUM, MAX_SERIAL_NUMBER, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_SERIAL_NUM);
+ 		return NOK;
+ 	}
+     memcpy(pEapWsc->pPeerDeviceInfo->serialNumber, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 	pEapWsc->pPeerDeviceInfo->serialNumberLength = tmpLVPUINT8.length;
+ 
+ 	/* sc_device_type_t primaryDeviceType; 8B */
+ 	tmpPos = EapWsc_ParseField(pInMsg, WSC_ID_PRIM_DEV_TYPE, SIZE_PRIM_DEV_TYPE, 0, 1 /* complexed field */, NULL);
+ 	if (!tmpPos) {
+ 		wpa_printf(MSG_ERROR, "EAP-WSC: %s: tmpPos is NULL", __FUNCTION__);
+ 		return NOK;
+ 	}
+ 	memcpy(&pEapWsc->pPeerDeviceInfo->primaryDeviceType.category_id, tmpPos, SIZE_PRIM_DEV_CAT_ID);
+     memcpy(&pEapWsc->pPeerDeviceInfo->primaryDeviceType.oui, bufferAdvance(pInMsg, SIZE_PRIM_DEV_CAT_ID), SIZE_PRIM_DEV_OUI);
+     memcpy(&pEapWsc->pPeerDeviceInfo->primaryDeviceType.sub_category_id, bufferAdvance(pInMsg, SIZE_PRIM_DEV_OUI), SIZE_PRIM_DEV_SUB_CAT_ID);
+     bufferAdvance(pInMsg, SIZE_PRIM_DEV_SUB_CAT_ID);
+ 
+ 	/* char *deviceName; 32B */
+ 	if (EapWsc_ParseCharPtr(pInMsg, WSC_ID_DEVICE_NAME, MAX_DEVICE_NAME, &tmpLVPCHAR) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_DEVICE_NAME);
+ 		return NOK;
+ 	}
+ 	strncpy(pEapWsc->pPeerDeviceInfo->deviceName, tmpLVPCHAR.pValue, tmpLVPCHAR.length);
+ 
+ 	/* u8 rfBand */
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_RF_BAND, &(pEapWsc->pPeerDeviceInfo->rfBand)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_RF_BAND);
+ 		return NOK;
+ 	}
+ 
+ 	/* u16 assocState */
+ 	if (EapWsc_ParseValue16(pInMsg, WSC_ID_ASSOC_STATE, &(pEapWsc->pPeerDeviceInfo->assocState)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_ASSOC_STATE);
+ 		return NOK;
+ 	}
+ 
+ 	/* u16 configError */
+ 	if (EapWsc_ParseValue16(pInMsg, WSC_ID_CONFIG_ERROR, &(pEapWsc->pPeerDeviceInfo->configError)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_CONFIG_ERROR);
+ 		return NOK;
+ 	}
+ 
+ 	/* u16 devicePasswordId */
+ 	if (EapWsc_ParseValue16(pInMsg, WSC_ID_DEVICE_PWD_ID, &(pEapWsc->pPeerDeviceInfo->devicePasswordId)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_DEVICE_PWD_ID);
+ 		return NOK;
+ 	}
+ 
+ 	/* UINT32 osVersion */
+ 	if (EapWsc_ParseValue32(pInMsg, WSC_ID_OS_VERSION, &(pEapWsc->pPeerDeviceInfo->osVersion)) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_OS_VERSION);
+ 		return NOK;
+ 	}
+ 
+ 	/* other attributes */
+ 	while (bufferRemaining(pInMsg) >= sizeof(TTlvHeader))
+ 	{
+ 		tmpPos = bufferPos(pInMsg);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 		tmpType = ntohs(TempInBuffer);
+ 
+ 		switch (tmpType)
+ 		{
+ 			case WSC_ID_AUTHENTICATOR:
+ 				break;
+ 
+ 			default:
+ 				/* advance past the TLV */
+ 				tmpPos += sizeof(u16); /* advance to length field */
+ 				memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 				bufferAdvance(pInMsg, sizeof(TTlvHeader) + ntohs(TempInBuffer));
+ 				break;
+ 		}
+ 
+ 		if (tmpType == WSC_ID_AUTHENTICATOR)
+ 		{
+ 			break;
+ 		}
+ 	}
+ 
+ 	/* u8 *authenticator; 8B */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_AUTHENTICATOR, MAX_AUTHENTICATOR, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to parse field of type: %d", WSC_ID_AUTHENTICATOR);
+ 		return NOK;
+ 	}
+ 	/* tmpLVPUINT8.pValue, tmpLVPUINT8.length - contain authenticator info */
+ 
+ /*------------------------------------------------------------------------------*/
+ 
+     /* to verify the hmac, we need to process the nonces, generate */
+     /* the DH secret, the KDK and finally the auth key */
+ 
+     /* Next, allocate memory for the pub key */
+ 	pEapWsc->DH_PubKey_Peer = BN_new();
+     if (!pEapWsc->DH_PubKey_Peer)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failed to allocate memory (DH_PubKey_Peer with BN_new())");
+         return NOK;	
+ 	}
+ 
+     /* Finally, import the raw key into the bignum datastructure */
+     if(BN_bin2bn(pEapWsc->pkr, SIZE_PUB_KEY, pEapWsc->DH_PubKey_Peer) == NULL)
+     {
+ 		BN_clear_free(pEapWsc->DH_PubKey_Peer);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: FAILED to produce a bignum for the PKr (BN_bin2bn())");
+         return NOK;
+     }
+ 
+     /******* KDK generation *******/
+     /* 1. generate the DH shared secret */
+ 
+ 	/* Calculate g^(AB) mod P into secret[] */
+     secretLen = DH_compute_key(secret, 
+                            pEapWsc->DH_PubKey_Peer, /* g^(B) mod P */
+                            pEapWsc->DHSecret); /* g^(A) mod P == DHSecret->PKe */
+ 
+ 	BN_clear_free(pEapWsc->DH_PubKey_Peer);
+ 
+     if (secretLen == -1)
+     {
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Failure in DH_compute_key: %s", ERR_error_string(ERR_get_error(), NULL));
+         return NOK;
+     }        
+ 
+     /* 2. compute the DHKey based on the DH secret */
+     if (SHA256(secret, secretLen, DHKey) == NULL)
+     {
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: SHA256 calculation failed");
+         return NOK;
+     }
+ 
+     /* 3. Append the enrollee nonce(N1), enrollee mac and registrar nonce(N2) */
+ 	bufferCreateEmpty(&kdkData, SIZE_128_BITS + MAC_ADDRESS_SIZE + SIZE_128_BITS);
+     bufferAppend(&kdkData, SIZE_128_BITS, pEapWsc->enrolleeNonce);
+     bufferAppend(&kdkData, ETH_ALEN, pEapWsc->pWscSupplicantConfig->macAddress);
+     bufferAppend(&kdkData, SIZE_128_BITS, pEapWsc->registrarNonce);
+ 
+     /* 4. now generate the KDK */
+     if (HMAC(EVP_sha256(), DHKey, SIZE_256_BITS, bufferGetBuf(&kdkData), bufferLength(&kdkData), kdk, NULL) == NULL)
+     {
+ 		bufferFree(&kdkData);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Error generating KDK");
+         return NOK;
+     }
+ 
+ 	bufferFree(&kdkData);
+     /******* KDK generation *******/
+ 
+     /******* Derivation of AuthKey, KeyWrapKey and EMSK *******/
+     /* 1. initialize the appropriate buffer objects */
+ 	bufferCreateFill(&kdkBuf, kdk, SIZE_256_BITS);
+ 	bufferCreateFill(&personalString, (u8 *)PERSONALIZATION_STRING, strlen(PERSONALIZATION_STRING));
+ 	bufferCreateEmpty(&keys, KDF_KEY_BITS/8); /* 640bit==80Byte */
+ 
+     /* 2. call the key derivation function */
+     cipherDeriveKey(&kdkBuf, &personalString, KDF_KEY_BITS, &keys);
+ 
+ 	bufferFree(&kdkBuf);
+ 	bufferFree(&personalString);
+ 
+     /* 3. split the key into the component keys and store them */
+     bufferRewindStart(&keys);
+ 
+     bufferAppend(&(pEapWsc->authKey), SIZE_256_BITS, bufferPos(&keys));
+     bufferAdvance(&keys, SIZE_256_BITS);
+ 
+ 	bufferAppend(&(pEapWsc->keyWrapKey), SIZE_128_BITS, bufferPos(&keys));
+     bufferAdvance(&keys, SIZE_128_BITS);
+ 
+ 	/* EMSK is not currently used anywhere else -> this is currently redundant! */
+ 	//bufferAppend(&(pEapWsc->emsk), SIZE_256_BITS, bufferPos(&keys));
+ 
+ 	bufferFree(&keys);
+     /******* Derivation of AuthKey, KeyWrapKey and EMSK *******/
+ 
+     /******* HMAC validation *******/
+     /* append the last message sent */
+ 	bufferCreateFill(&hmacData, bufferGetBuf(&(pEapWsc->OutMsg)), bufferLength(&(pEapWsc->OutMsg)));
+ 	bufferAdvance(&hmacData, bufferLength(&(pEapWsc->OutMsg)));
+ 
+     /* append the current message. Don't append the last TLV (auth) */
+ 	bufferAppend(&hmacData, 
+ 				bufferLength(pInMsg)-(sizeof(TTlvHeader) + tmpLVPUINT8.length /* authenticator length */), 
+ 				bufferGetBuf(pInMsg));
+ 
+     /* First calculate the hmac of the data */
+     if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&hmacData), bufferLength(&hmacData), dataMac, NULL) == NULL)
+     {
+ 		bufferFree(&hmacData);
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: Error generating HMAC");
+         return NOK;
+     }
+ 
+ 	bufferFree(&hmacData);
+ 
+     /* next, compare it against the received hmac */
+     if (memcmp(dataMac, tmpLVPUINT8.pValue, tmpLVPUINT8.length) != 0) /* tmpLVPUINT8 contains parsed authenticator info */
+     {
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM2: HMAC validation failed");
+         return NOK;
+     }
+     /******* HMAC validation *******/
+ 
+     /* Store the received buffer */
+ 	bufferReset(&pEapWsc->InMsg);
+ 	bufferAppend(&pEapWsc->InMsg, bufferLength(pInMsg), bufferGetBuf(pInMsg));
+ 
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_BuildMsgM3(TEapWsc *pEapWsc, bufferObj* pOutMsg)
+ {
+ 	u8 msgType = WSC_ID_MESSAGE_M3;
+ 	bufferObj hmacData;
+ 	u8 hmac[SIZE_256_BITS];
+ 	u8 hashBuf[SIZE_256_BITS];
+ 	bufferObj eHashBuf;
+     
+     /* First, generate or gather all the required data */
+ 
+     /******* PSK1 and PSK2 generation *******/
+     u8 *pwdPtr = pEapWsc->pWscSupplicantConfig->password;
+     int pwdLen = strlen((char *)(pEapWsc->pWscSupplicantConfig->password));
+ 
+     /* Hash 1st half of passwd. If it is an odd length, the extra byte */
+     /* goes along with the first half */ 
+     if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, pwdPtr, (pwdLen/2)+(pwdLen%2), hashBuf, NULL) == NULL)
+     {
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_BuildMsgM3: HMAC failed during PSK1 generation");
+         return NOK;
+     }
+     /* copy first 128 bits into psk1 */
+     memcpy(pEapWsc->psk1, hashBuf, SIZE_128_BITS);
+     
+     /* Hash 2nd half of password */
+     if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, pwdPtr + (pwdLen/2) + (pwdLen%2), (pwdLen/2), hashBuf, NULL) == NULL)
+     {
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_BuildMsgM3: HMAC failed during PSK2 generation");
+         return NOK;
+     }
+     /* copy first 128 bits into psk2 */
+     memcpy(pEapWsc->psk2, hashBuf, SIZE_128_BITS);
+     /******* PSK1 and PSK2 generation *******/
+ 
+     /******* EHash1 and EHash2 generation *******/
+     RAND_bytes(pEapWsc->es1, SIZE_128_BITS);
+     RAND_bytes(pEapWsc->es2, SIZE_128_BITS);
+ 	
+ 
+     /* Append the secret nonce 1(es1), PSK1, enrollee public key (pke) and registrar public key (pkr) */
+ 	bufferCreateEmpty(&eHashBuf, SIZE_128_BITS + SIZE_128_BITS + SIZE_PUB_KEY + SIZE_PUB_KEY);
+     bufferAppend(&eHashBuf, SIZE_128_BITS, pEapWsc->es1);
+     bufferAppend(&eHashBuf, SIZE_128_BITS, pEapWsc->psk1);
+     bufferAppend(&eHashBuf, SIZE_PUB_KEY, pEapWsc->pke);
+     bufferAppend(&eHashBuf, SIZE_PUB_KEY, pEapWsc->pkr);
+ 
+     if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&eHashBuf), bufferLength(&eHashBuf), hashBuf, NULL) == NULL)
+     {
+ 		bufferFree(&eHashBuf);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_BuildMsgM3: HMAC failed during EHash1 generation");
+         return NOK;
+     }
+     memcpy(pEapWsc->eHash1, hashBuf, SIZE_256_BITS);
+ 
+ 	/* Append the secret nonce 2(es2), PSK2, enrollee public key (pke) and registrar public key (pkr) */
+ 	bufferReset(&eHashBuf);
+     bufferAppend(&eHashBuf, SIZE_128_BITS, pEapWsc->es2);
+     bufferAppend(&eHashBuf, SIZE_128_BITS, pEapWsc->psk2);
+     bufferAppend(&eHashBuf, SIZE_PUB_KEY, pEapWsc->pke);
+     bufferAppend(&eHashBuf, SIZE_PUB_KEY, pEapWsc->pkr);
+ 
+     if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&eHashBuf), bufferLength(&eHashBuf), hashBuf, NULL) == NULL)
+     {
+ 		bufferFree(&eHashBuf);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_BuildMsgM3: HMAC failed during EHash2 generation");
+         return NOK;
+     }
+ 
+ 	bufferFree(&eHashBuf);
+ 
+     memcpy(pEapWsc->eHash2, hashBuf, SIZE_256_BITS);
+     /******* EHash1 and EHash2 generation *******/
+ 
+ 	/* create Msg */
+ 	bufferCreateChunk(pOutMsg);
+ 	
+     /* Now assemble the message */
+ 	
+ 	/* u8 version */
+ 	wsc_supplicant_SerializeField(WSC_ID_VERSION, pOutMsg, SIZE_VERSION, &(pEapWsc->pWscSupplicantConfig->version));
+ 
+ 	/* u8 msgType */
+ 	wsc_supplicant_SerializeField(WSC_ID_MSG_TYPE, pOutMsg, SIZE_MSG_TYPE, &msgType);
+ 
+ 	/* u8 *registrarNonce ;16B=128 bits */
+ 	wsc_supplicant_SerializeField(WSC_ID_REGISTRAR_NONCE, pOutMsg, SIZE_REGISTRAR_NONCE, pEapWsc->registrarNonce);
+ 
+ 	/* u8 *eHash1 ;32B=256 bits */
+ 	wsc_supplicant_SerializeField(WSC_ID_E_HASH1, pOutMsg, SIZE_E_HASH, pEapWsc->eHash1);
+ 
+ 	/* u8 *eHash2 ;32B=256 bits */
+ 	wsc_supplicant_SerializeField(WSC_ID_E_HASH2, pOutMsg, SIZE_E_HASH, pEapWsc->eHash2);
+ 
+     /* No vendor extension */
+ 
+ 	/* Calculate the hmac */
+ 	bufferCreateFill(&hmacData, bufferGetBuf(&(pEapWsc->InMsg)), bufferLength(&(pEapWsc->InMsg)));
+ 	bufferAdvance(&hmacData, bufferLength(&(pEapWsc->InMsg)));
+ 
+     /* append the current message excluding the last TLV (auth) */
+ 	bufferAppend(&hmacData, bufferLength(pOutMsg), bufferGetBuf(pOutMsg));
+ 
+     /* First calculate the hmac of the data */
+     if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&hmacData), bufferLength(&hmacData), hmac, NULL) == NULL)
+     {
+ 		bufferFree(&hmacData);
+ 		bufferFree(pOutMsg);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_BuildMsgM3: Error generating HMAC");
+         return NOK;
+     }
+ 
+ 	bufferFree(&hmacData);
+ 
+ 	/* u8 *authenticator; 8B */
+ 	wsc_supplicant_SerializeField(WSC_ID_AUTHENTICATOR, pOutMsg, SIZE_AUTHENTICATOR, hmac);
+ 
+ 	/* Store the outgoing message */
+ 	bufferReset(&(pEapWsc->OutMsg));
+ 	bufferAppend(&(pEapWsc->OutMsg), bufferLength(pOutMsg), bufferGetBuf(pOutMsg));
+ 
+ 	wpa_printf(MSG_INFO,"EAP-WSC: EapWsc_BuildMsgM3: EapWsc_BuildMsgM3 built %d byte message", bufferLength(pOutMsg));
+ 
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_ProcessMsgM4(TEapWsc *pEapWsc, bufferObj* pInMsg)
+ {
+ 	u8 version;
+ 	u8 msgType;
+ 	TLVPUINT8 tmpLVPUINT8, tmpLVPUINT8Auth;
+ 	u8 *tmpPos;
+ 
+ 	u8 *ip_encryptedData = NULL;
+ 	int	encrSettingsLength = 0;
+ 	u16 encrDataLength = 0;
+ 	bufferObj cipherText, iv, plainText;
+ 
+ 	bufferObj hmacData;
+ 	u8 dataMac[BUF_SIZE_256_BITS];
+ 
+ 	bufferObj rHashBuf;
+ 	u8 hashBuf[SIZE_256_BITS];
+ 	u16 TempInBuffer, tmpType;
+ 
+ 	wpa_printf(MSG_INFO,"EAP-WSC: EapWsc_ProcessMsgM4: EapWsc_ProcessMsgM4 of %d byte message", bufferLength(pInMsg));
+ 
+ 	/* First and foremost, check the version and message number.*/
+ 	/* Don't deserialize (parse) incompatible messages! */
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_VERSION, &version) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM4: Failed to parse field of type: %d", WSC_ID_VERSION);
+ 		return NOK;
+ 	}
+ 
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_MSG_TYPE, &msgType) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM4: Failed to parse field of type: %d", WSC_ID_MSG_TYPE);
+ 		return NOK;
+ 	}
+ 
+ 	/* u8 *enrolleeNonce ;16B=128 bits */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_ENROLLEE_NONCE, MAX_ENROLLEE_NONCE, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM4: Failed to parse field of type: %d", WSC_ID_ENROLLEE_NONCE);
+ 		return NOK;
+ 	}
+ 	/* confirm the enrollee nonce */
+ 	if (memcmp(pEapWsc->enrolleeNonce, tmpLVPUINT8.pValue, tmpLVPUINT8.length))
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM4: Incorrect enrollee nonce received");
+ 		return NOK;
+ 	}
+ 
+ 	/* u8 *rHash1; 32B */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_R_HASH1, MAX_R_HASH, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM4: Failed to parse field of type: %d", WSC_ID_R_HASH1);
+ 		return NOK;
+ 	}
+ 	memcpy(pEapWsc->rHash1, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 
+ 	/* u8 *rHash2; 32B */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_R_HASH2, MAX_R_HASH, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM4: Failed to parse field of type: %d", WSC_ID_R_HASH2);
+ 		return NOK;
+ 	}
+ 	memcpy(pEapWsc->rHash2, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 
+     /* encrypted settings */
+ 	tmpPos = bufferPos(pInMsg);
+ 	memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 	if (WSC_ID_ENCR_SETTINGS == ntohs(TempInBuffer))
+     {
+ 		/* Parse Encrypted Settings */
+ 		/* parse the header first. Min data size of the IV + 1 block of data */
+ 		tmpPos = EapWsc_ParseField(pInMsg, WSC_ID_ENCR_SETTINGS, (SIZE_ENCR_IV + ENCR_DATA_BLOCK_SIZE), 0, 1 /* complexed field */, &encrSettingsLength);
+ 		if (!tmpPos) {
+ 			wpa_printf(MSG_ERROR, "EAP-WSC: %s: tmpPos is NULL", __FUNCTION__);
+ 			return NOK;
+ 		}
+ 		bufferCreateFill(&iv, tmpPos, SIZE_ENCR_IV);
+ 		ip_encryptedData = bufferAdvance(pInMsg, SIZE_ENCR_IV);
+ 		encrDataLength = encrSettingsLength - SIZE_ENCR_IV;
+ 		bufferAdvance(pInMsg, encrDataLength);
+     }
+ 
+ 	/* other attributes */
+ 	while (bufferRemaining(pInMsg) >= sizeof(TTlvHeader))
+ 	{
+ 		tmpPos = bufferPos(pInMsg);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 		tmpType = ntohs(TempInBuffer);
+ 
+ 		switch (tmpType)
+ 		{
+ 			case WSC_ID_AUTHENTICATOR:
+ 				break;
+ 
+ 			default:
+ 
+ 			/* advance past the TLV */
+ 			tmpPos += sizeof(u16); /* advance to length field */
+ 			memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 			bufferAdvance(pInMsg, sizeof(TTlvHeader) + ntohs(TempInBuffer));
+ 				break;
+ 		}
+ 
+ 		if (tmpType == WSC_ID_AUTHENTICATOR)
+ 		{
+ 			break;
+ 		}
+ 	}
+ 
+ 	/* u8 *authenticator; 8B */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_AUTHENTICATOR, MAX_AUTHENTICATOR, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM4: Failed to parse field of type: %d", WSC_ID_AUTHENTICATOR);
+ 		return NOK;
+ 	}
+ 	/* tmpLVPUINT8.pValue, tmpLVPUINT8.length - contain authenticator info */
+ 
+     /******* HMAC validation *******/
+     /* append the last message sent */
+ 	bufferCreateFill(&hmacData, bufferGetBuf(&(pEapWsc->OutMsg)), bufferLength(&(pEapWsc->OutMsg)));
+ 	bufferAdvance(&hmacData, bufferLength(&(pEapWsc->OutMsg)));
+ 
+     /* append the current message. Don't append the last TLV (auth) */
+ 	bufferAppend(&hmacData, 
+ 				bufferLength(pInMsg)-(sizeof(TTlvHeader) + tmpLVPUINT8.length /* authenticator length */), 
+ 				bufferGetBuf(pInMsg));
+ 
+     /* First calculate the hmac of the data */
+     if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&hmacData), bufferLength(&hmacData), dataMac, NULL) == NULL)
+     {
+ 		bufferFree(&hmacData);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM4: Error generating HMAC");
+         return NOK;
+     }
+ 
+ 	bufferFree(&hmacData);
+ 
+     /* next, compare it against the received hmac */
+     if (memcmp(dataMac, tmpLVPUINT8.pValue, tmpLVPUINT8.length) != 0) /* tmpLVPUINT8 contains parsed authenticator info */
+     {
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM4: HMAC validation failed");
+         return NOK;
+     }
+     /******* HMAC validation *******/
+ 
+     /******* extract encrypted settings *******/
+ 	bufferCreateFill(&cipherText, ip_encryptedData, encrDataLength);
+ 	bufferCreateChunk(&plainText);
+ 
+ 	cipherDecrypt(	&cipherText, 
+ 					&iv,
+ 					&pEapWsc->keyWrapKey, 
+ 					&pEapWsc->authKey, 
+ 					&plainText);
+ 
+     bufferFree(&iv);
+ 	bufferFree(&cipherText);
+ 
+ 	bufferRewindStart(&plainText);
+ 
+ 	/* Parse M4 Encrypted settings contained in plainText */
+ 
+ 	/* u8 *rs1 ;16B=128 bits */
+ 	if (EapWsc_ParseValuePtr(&plainText, WSC_ID_R_SNONCE1, MAX_R_SNONCE, &tmpLVPUINT8) != OK)
+ 	{
+ 		bufferFree(&plainText);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM4: Failed to parse field of type: %d", WSC_ID_R_SNONCE1);
+ 		return NOK;
+ 	}
+ 	/* tmpLVPUINT8.pValue, tmpLVPUINT8.length - contain rs1 (Registrar Secret Nonce 1) info */
+ 
+ 	/* other attributes */
+ 	while (bufferRemaining(&plainText) >= sizeof(TTlvHeader))
+ 	{
+ 		tmpPos = bufferPos(&plainText);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 		tmpType = ntohs(TempInBuffer);
+ 
+ 		switch (tmpType)
+ 		{
+ 			case WSC_ID_KEY_WRAP_AUTH:
+ 				break;
+ 
+ 			default:
+ 
+ 			/* advance past the TLV */
+ 			tmpPos += sizeof(u16); /* advance to length field */
+ 			memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 			bufferAdvance(&plainText, sizeof(TTlvHeader) + ntohs(TempInBuffer));
+ 				break;
+ 		}
+ 
+ 		if (tmpType == WSC_ID_KEY_WRAP_AUTH)
+ 		{
+ 			break;
+ 		}
+ 	}
+ 
+ 	/* u8 *KeyWrapAuthenticator */
+ 	if (EapWsc_ParseValuePtr(&plainText, WSC_ID_KEY_WRAP_AUTH, MAX_KEY_WRAP_AUTH, &tmpLVPUINT8Auth) != OK)
+ 	{
+ 		bufferFree(&plainText);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM4: Failed to parse field of type: %d", WSC_ID_KEY_WRAP_AUTH);
+ 		return NOK;
+ 	}
+ 	/* tmpLVPUINT8Auth.pValue, tmpLVPUINT8Auth.length - contain Key Wrap authenticator info */
+ 
+ 	/* validate the mac */
+ 
+ 	/* calculate the hmac of the data (data only, not the last auth TLV) */
+ 	if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&plainText), bufferLength(&plainText) - (sizeof(TTlvHeader) + tmpLVPUINT8Auth.length), dataMac, NULL) == NULL)
+ 	{
+ 		bufferFree(&plainText);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM4: Error generating HMAC of extracted encrypted settings");
+ 		return NOK;
+ 	}
+ 
+ 	/* next, compare it against the received hmac */
+ 	if (memcmp(dataMac, tmpLVPUINT8Auth.pValue, tmpLVPUINT8Auth.length) != 0) /* tmpLVPUINT8 contains parsed authenticator info */
+ 	{
+ 		bufferFree(&plainText);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM4: Validation of encrypted settings HMAC - failed");
+ 		return NOK;
+ 	}
+ 
+     /******* extract encrypted settings *******/
+ 
+     /******* RHash1 validation *******/
+     /* 1. Save RS1 */
+     memcpy(pEapWsc->rs1, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 
+ 	bufferFree(&plainText);
+ 
+ 	/* 2. prepare the buffer */
+ 	bufferCreateEmpty(&rHashBuf, SIZE_128_BITS + SIZE_128_BITS + SIZE_PUB_KEY + SIZE_PUB_KEY);
+     bufferAppend(&rHashBuf, SIZE_128_BITS, pEapWsc->rs1);
+     bufferAppend(&rHashBuf, SIZE_128_BITS, pEapWsc->psk1);
+     bufferAppend(&rHashBuf, SIZE_PUB_KEY, pEapWsc->pke);
+     bufferAppend(&rHashBuf, SIZE_PUB_KEY, pEapWsc->pkr);
+ 
+     /* 3. generate the mac */
+ 	if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&rHashBuf), bufferLength(&rHashBuf), hashBuf, NULL) == NULL)
+ 	{
+ 		bufferFree(&rHashBuf);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM4: Error generating HMAC for RHash1");
+ 		return NOK;
+ 	}
+ 
+ 	bufferFree(&rHashBuf);
+ 
+ 	/* 4. compare the mac to rhash1 */
+     if (memcmp(pEapWsc->rHash1, hashBuf, SIZE_256_BITS) != 0)
+     {
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM4: RHash1 HMAC validation failed");
+         return NOK;
+     }
+     /******* RHash1 validation *******/
+ 
+     /* Store the received buffer */
+ 	bufferReset(&pEapWsc->InMsg);
+ 	bufferAppend(&pEapWsc->InMsg, bufferLength(pInMsg), bufferGetBuf(pInMsg));
+ 
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_BuildMsgM5(TEapWsc *pEapWsc, bufferObj* pOutMsg)
+ {
+ 	u8 msgType = WSC_ID_MESSAGE_M5;
+ 	bufferObj cipherText, encData, iv;
+ 	u8 tmpHmac[SIZE_256_BITS];
+ 
+ 	bufferObj hmacData;
+ 	u8 hmac[SIZE_256_BITS];
+ 
+     /* First, generate or gather the required data */
+ 
+ 	/* encrypted settings.*/
+ 	bufferCreateEmpty(&encData, SIZE_192_BYTES);
+ 	wsc_supplicant_SerializeField(WSC_ID_E_SNONCE1, &encData, SIZE_E_SNONCE, pEapWsc->es1);
+ 
+ 	/* calculate the hmac and append the TLV to the buffer */
+     if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&encData), bufferLength(&encData), tmpHmac, NULL) == NULL)
+     {
+ 		bufferFree(&encData);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_BuildMsgM5: Error generating HMAC");
+         return NOK;
+     }
+ 
+ 	/* u8 *KeyWrapAuthenticator */
+ 	wsc_supplicant_SerializeField(WSC_ID_KEY_WRAP_AUTH, &encData, SIZE_KEY_WRAP_AUTH, tmpHmac); /* Only the first 64 bits are sent */
+ 
+ 	bufferCreateEmpty(&cipherText, SIZE_192_BYTES);
+ 	bufferCreateEmpty(&iv, SIZE_ENCR_IV);
+ 
+ 	cipherEncrypt(	&encData,
+ 					&pEapWsc->keyWrapKey,
+ 					&pEapWsc->authKey, 
+ 					&cipherText, 
+ 					&iv);
+ 
+ 	bufferFree(&encData);
+ 
+ 	/* create Msg */
+ 	bufferCreateChunk(pOutMsg);
+ 
+     /* Now assemble the message */
+ 
+ 	/* u8 version */
+ 	wsc_supplicant_SerializeField(WSC_ID_VERSION, pOutMsg, SIZE_VERSION, &(pEapWsc->pWscSupplicantConfig->version));
+ 
+ 	/* u8 msgType */
+ 	wsc_supplicant_SerializeField(WSC_ID_MSG_TYPE, pOutMsg, SIZE_MSG_TYPE, &msgType);
+ 
+ 	/* u8 *registrarNonce ;16B=128 bits */
+ 	wsc_supplicant_SerializeField(WSC_ID_REGISTRAR_NONCE, pOutMsg, SIZE_REGISTRAR_NONCE, pEapWsc->registrarNonce);
+ 
+ 	/* encryption settings */
+ 	wsc_supplicant_SerializeHeader(WSC_ID_ENCR_SETTINGS, (u16)(SIZE_ENCR_IV + bufferLength(&cipherText)), pOutMsg);
+ 	bufferAppend(pOutMsg, SIZE_ENCR_IV, bufferGetBuf(&iv));
+ 	bufferAppend(pOutMsg, bufferLength(&cipherText), bufferGetBuf(&cipherText));
+ 
+ 	bufferFree(&iv);
+ 	bufferFree(&cipherText);
+ 
+ 	/* Calculate the hmac */
+ 	bufferCreateFill(&hmacData, bufferGetBuf(&(pEapWsc->InMsg)), bufferLength(&(pEapWsc->InMsg)));
+ 	bufferAdvance(&hmacData, bufferLength(&(pEapWsc->InMsg)));
+ 
+     /* append the current message excluding the last TLV (auth) */
+ 	bufferAppend(&hmacData, bufferLength(pOutMsg), bufferGetBuf(pOutMsg));
+ 
+     /* First calculate the hmac of the data */
+     if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&hmacData), bufferLength(&hmacData), hmac, NULL) == NULL)
+     {
+ 		bufferFree(&hmacData);
+ 		bufferFree(pOutMsg);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_BuildMsgM5: Error generating HMAC");
+         return NOK;
+     }
+ 
+ 	bufferFree(&hmacData);
+ 
+ 	/* u8 *authenticator; 8B */
+ 	wsc_supplicant_SerializeField(WSC_ID_AUTHENTICATOR, pOutMsg, SIZE_AUTHENTICATOR, hmac);
+ 
+ 	/* Store the outgoing message */
+ 	bufferReset(&(pEapWsc->OutMsg));
+ 	bufferAppend(&(pEapWsc->OutMsg), bufferLength(pOutMsg), bufferGetBuf(pOutMsg));
+ 
+ 	wpa_printf(MSG_INFO,"EAP-WSC: EapWsc_BuildMsgM5: EapWsc_BuildMsgM5 built %d byte message", bufferLength(pOutMsg));
+ 
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_ProcessMsgM6(TEapWsc *pEapWsc, bufferObj* pInMsg)
+ {
+ 	u8 version;
+ 	u8 msgType;
+ 	TLVPUINT8 tmpLVPUINT8, tmpLVPUINT8Auth;
+ 	u8 *tmpPos;
+ 
+ 	u8 *ip_encryptedData = NULL;
+ 	int	encrSettingsLength = 0;
+ 	u16 encrDataLength = 0;
+ 	bufferObj cipherText, iv, plainText;
+ 
+ 	bufferObj hmacData;
+ 	u8 dataMac[BUF_SIZE_256_BITS];
+ 
+ 	bufferObj rHashBuf;
+ 	u8 hashBuf[SIZE_256_BITS];
+ 	u16 TempInBuffer, tmpType;
+ 
+ 	wpa_printf(MSG_INFO,"EAP-WSC: EapWsc_ProcessMsgM6: EapWsc_ProcessMsgM6 of %d byte message", bufferLength(pInMsg));
+ 
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_VERSION, &version) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM6: Failed to parse field of type: %d", WSC_ID_VERSION);
+ 		return NOK;
+ 	}
+ 
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_MSG_TYPE, &msgType) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM6: Failed to parse field of type: %d", WSC_ID_MSG_TYPE);
+ 		return NOK;
+ 	}
+ 
+ 	/* u8 *enrolleeNonce ;16B=128 bits */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_ENROLLEE_NONCE, MAX_ENROLLEE_NONCE, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM6: Failed to parse field of type: %d", WSC_ID_ENROLLEE_NONCE);
+ 		return NOK;
+ 	}
+ 	/* confirm the enrollee nonce */
+ 	if (memcmp(pEapWsc->enrolleeNonce, tmpLVPUINT8.pValue, tmpLVPUINT8.length))
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM6: Incorrect enrollee nonce received");
+ 		return NOK;
+ 	}
+ 
+     /* encrypted settings */
+ 	tmpPos = bufferPos(pInMsg);
+ 	memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 	if (WSC_ID_ENCR_SETTINGS == ntohs(TempInBuffer))
+     {
+ 		/* Parse Encrypted Settings */
+ 		/* parse the header first. Min data size of the IV + 1 block of data */
+ 		tmpPos = EapWsc_ParseField(pInMsg, WSC_ID_ENCR_SETTINGS, (SIZE_ENCR_IV + ENCR_DATA_BLOCK_SIZE), 0, 1 /* complexed field */, &encrSettingsLength);
+ 		if (!tmpPos) {
+ 			wpa_printf(MSG_ERROR, "EAP-WSC: %s: tmpPos is NULL", __FUNCTION__);
+ 			return NOK;
+ 		}
+ 		bufferCreateFill(&iv, tmpPos, SIZE_ENCR_IV);
+ 		ip_encryptedData = bufferAdvance(pInMsg, SIZE_ENCR_IV);
+ 		encrDataLength = encrSettingsLength - SIZE_ENCR_IV;
+ 		bufferAdvance(pInMsg, encrDataLength);
+     }
+ 
+ 	/* other attributes */
+ 	while (bufferRemaining(pInMsg) >= sizeof(TTlvHeader))
+ 	{
+ 		tmpPos = bufferPos(pInMsg);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 		tmpType = ntohs(TempInBuffer);
+ 
+ 		switch (tmpType)
+ 		{
+ 			case WSC_ID_AUTHENTICATOR:
+ 				break;
+ 
+ 			default:
+ 
+ 			/* advance past the TLV */
+ 			tmpPos += sizeof(u16); /* advance to length field */
+ 			memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 			bufferAdvance(pInMsg, sizeof(TTlvHeader) + ntohs(TempInBuffer));
+ 				break;
+ 		}
+ 
+ 		if (tmpType == WSC_ID_AUTHENTICATOR)
+ 		{
+ 			break;
+ 		}
+ 	}
+ 
+ 	/* u8 *authenticator; 8B */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_AUTHENTICATOR, MAX_AUTHENTICATOR, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM6: Failed to parse field of type: %d", WSC_ID_AUTHENTICATOR);
+ 		return NOK;
+ 	}
+     /* tmpLVPUINT8.pValue, tmpLVPUINT8.length - contain authenticator info */
+ 
+     /******* HMAC validation *******/
+     /* append the last message sent */
+ 	bufferCreateFill(&hmacData, bufferGetBuf(&(pEapWsc->OutMsg)), bufferLength(&(pEapWsc->OutMsg)));
+ 	bufferAdvance(&hmacData, bufferLength(&(pEapWsc->OutMsg)));
+ 
+     /* append the current message. Don't append the last TLV (auth) */
+ 	bufferAppend(&hmacData, 
+ 				bufferLength(pInMsg)-(sizeof(TTlvHeader) + tmpLVPUINT8.length /* authenticator length */), 
+ 				bufferGetBuf(pInMsg));
+ 
+     /* First calculate the hmac of the data */
+     if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&hmacData), bufferLength(&hmacData), dataMac, NULL) == NULL)
+     {
+ 		bufferFree(&hmacData);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM6: Error generating HMAC");
+         return NOK;
+     }
+ 
+ 	bufferFree(&hmacData);
+ 
+     /* next, compare it against the received hmac */
+     if (memcmp(dataMac, tmpLVPUINT8.pValue, tmpLVPUINT8.length) != 0) /* tmpLVPUINT8 contains parsed authenticator info */
+     {
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM6: HMAC validation failed");
+         return NOK;
+     }
+     /******* HMAC validation *******/
+ 
+     /******* extract encrypted settings *******/
+ 	bufferCreateFill(&cipherText, ip_encryptedData, encrDataLength);
+ 	bufferCreateChunk(&plainText);
+ 
+ 	cipherDecrypt(	&cipherText, 
+ 					&iv,
+ 					&pEapWsc->keyWrapKey, 
+ 					&pEapWsc->authKey, 
+ 					&plainText);
+ 
+     bufferFree(&iv);
+ 	bufferFree(&cipherText);
+ 
+ 	bufferRewindStart(&plainText);
+ 
+ 	/* Parse M6 Encrypted settings contained in plainText */
+ 
+ 	/* u8 *rs2 ;16B=128 bits */
+ 	if (EapWsc_ParseValuePtr(&plainText, WSC_ID_R_SNONCE2, MAX_R_SNONCE, &tmpLVPUINT8) != OK)
+ 	{
+ 		bufferFree(&plainText);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM6: Failed to parse field of type: %d", WSC_ID_R_SNONCE2);
+ 		return NOK;
+ 	}
+ 	/* tmpLVPUINT8.pValue, tmpLVPUINT8.length - contain rs2 (Registrar Secret Nonce 1) info */
+ 
+ 	/* other attributes */
+ 	while (bufferRemaining(&plainText) >= sizeof(TTlvHeader))
+ 	{
+ 		tmpPos = bufferPos(&plainText);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 		tmpType = ntohs(TempInBuffer);
+ 
+ 		switch (tmpType)
+ 		{
+ 			case WSC_ID_KEY_WRAP_AUTH:
+ 				break;
+ 
+ 			default:
+ 
+ 			/* advance past the TLV */
+ 			tmpPos += sizeof(u16); /* advance to length field */
+ 			memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 			bufferAdvance(&plainText, sizeof(TTlvHeader) + ntohs(TempInBuffer));
+ 				break;
+ 		}
+ 
+ 		if (tmpType == WSC_ID_KEY_WRAP_AUTH)
+ 		{
+ 			break;
+ 		}
+ 	}
+ 
+ 	/* u8 *KeyWrapAuthenticator */
+ 	if (EapWsc_ParseValuePtr(&plainText, WSC_ID_KEY_WRAP_AUTH, MAX_KEY_WRAP_AUTH, &tmpLVPUINT8Auth) != OK)
+ 	{
+ 		bufferFree(&plainText);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM6: Failed to parse field of type: %d", WSC_ID_KEY_WRAP_AUTH);
+ 		return NOK;
+ 	}
+ 	/* tmpLVPUINT8Auth.pValue, tmpLVPUINT8Auth.length - contain Key Wrap authenticator info */
+ 
+ 	/* validate the mac */
+ 
+ 	/* calculate the hmac of the data (data only, not the last auth TLV) */
+ 	if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&plainText), bufferLength(&plainText) - (sizeof(TTlvHeader) + tmpLVPUINT8Auth.length), dataMac, NULL) == NULL)
+ 	{
+ 		bufferFree(&plainText);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM6: Error generating HMAC of extracted encrypted settings");
+ 		return NOK;
+ 	}
+ 
+ 	/* next, compare it against the received hmac */
+ 	if (memcmp(dataMac, tmpLVPUINT8Auth.pValue, tmpLVPUINT8Auth.length) != 0) /* tmpLVPUINT8 contains parsed authenticator info */
+ 	{
+ 		bufferFree(&plainText);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM6: Validation of encrypted settings HMAC - failed");
+ 		return NOK;
+ 	}
+     /******* extract encrypted settings *******/
+ 
+     /******* RHash2 validation *******/
+     /* 1. Save RS2 */
+ 	memcpy(pEapWsc->rs2, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 
+ 	bufferFree(&plainText);
+ 
+ 	/* 2. prepare the buffer */
+ 	bufferCreateEmpty(&rHashBuf, SIZE_128_BITS + SIZE_128_BITS + SIZE_PUB_KEY + SIZE_PUB_KEY);
+ 	bufferAppend(&rHashBuf, SIZE_128_BITS, pEapWsc->rs2);
+ 	bufferAppend(&rHashBuf, SIZE_128_BITS, pEapWsc->psk2);
+ 	bufferAppend(&rHashBuf, SIZE_PUB_KEY, pEapWsc->pke);
+ 	bufferAppend(&rHashBuf, SIZE_PUB_KEY, pEapWsc->pkr);
+ 
+ 	/* 3. generate the mac */
+ 	if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&rHashBuf), bufferLength(&rHashBuf), hashBuf, NULL) == NULL)
+ 	{
+ 		bufferFree(&rHashBuf);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM6: Error generating HMAC for RHash2");
+ 		return NOK;
+ 	}
+ 
+ 	bufferFree(&rHashBuf);
+ 
+     /* 4. compare the mac to rhash2 */
+ 	if (memcmp(pEapWsc->rHash2, hashBuf, SIZE_256_BITS) != 0)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM6: RHash2 HMAC validation failed");
+ 		return NOK;
+ 	}
+     /******* RHash2 validation *******/
+ 
+     /* Store the received buffer */
+ 	bufferReset(&pEapWsc->InMsg);
+ 	bufferAppend(&pEapWsc->InMsg, bufferLength(pInMsg), bufferGetBuf(pInMsg));
+ 
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_BuildMsgM7(TEapWsc *pEapWsc, bufferObj* pOutMsg)
+ {
+ 	u8 msgType = WSC_ID_MESSAGE_M7;
+ 
+ 	bufferObj cipherText, esBuf, iv;
+ 	u8 tmpHmac[SIZE_256_BITS];
+ 
+ 	bufferObj hmacData;
+ 	u8 hmac[SIZE_256_BITS];
+ 
+     /* First, generate or gather the required data */
+ 
+ 	/* encrypted settings.*/
+ 	bufferCreateEmpty(&esBuf, SIZE_192_BYTES);
+ 	wsc_supplicant_SerializeField(WSC_ID_E_SNONCE2, &esBuf, SIZE_E_SNONCE, pEapWsc->es2);
+ 
+ 	/* calculate the hmac and append the TLV to the buffer */
+ 	if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&esBuf), bufferLength(&esBuf), tmpHmac, NULL) == NULL)
+ 	{
+ 		bufferFree(&esBuf);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_BuildMsgM7: Error generating HMAC");
+ 		return NOK;
+ 	}
+ 
+ 	/* u8 *KeyWrapAuthenticator */
+ 	wsc_supplicant_SerializeField(WSC_ID_KEY_WRAP_AUTH, &esBuf, SIZE_KEY_WRAP_AUTH, tmpHmac); /* Only the first 64 bits are sent */
+ 
+ 	bufferCreateEmpty(&cipherText, SIZE_192_BYTES);
+ 	bufferCreateEmpty(&iv, SIZE_ENCR_IV);
+ 
+ 	cipherEncrypt(	&esBuf,
+ 					&pEapWsc->keyWrapKey,
+ 					&pEapWsc->authKey, 
+ 					&cipherText, 
+ 					&iv);
+ 
+ 	bufferFree(&esBuf);
+ 
+ 	/* create Msg */
+ 	bufferCreateChunk(pOutMsg);
+ 
+     /* Now assemble the message */
+ 
+ 	/* u8 version */
+ 	wsc_supplicant_SerializeField(WSC_ID_VERSION, pOutMsg, SIZE_VERSION, &(pEapWsc->pWscSupplicantConfig->version));
+ 
+ 	/* u8 msgType */
+ 	wsc_supplicant_SerializeField(WSC_ID_MSG_TYPE, pOutMsg, SIZE_MSG_TYPE, &msgType);
+ 
+ 	/* u8 *registrarNonce ;16B=128 bits */
+ 	wsc_supplicant_SerializeField(WSC_ID_REGISTRAR_NONCE, pOutMsg, SIZE_REGISTRAR_NONCE, pEapWsc->registrarNonce);
+ 
+ 	/* encryption settings */
+ 	wsc_supplicant_SerializeHeader(WSC_ID_ENCR_SETTINGS, (u16)(SIZE_ENCR_IV + bufferLength(&cipherText)), pOutMsg);
+ 	bufferAppend(pOutMsg, SIZE_ENCR_IV, bufferGetBuf(&iv));
+ 	bufferAppend(pOutMsg, bufferLength(&cipherText), bufferGetBuf(&cipherText));
+ 
+ 	bufferFree(&iv);
+ 	bufferFree(&cipherText);
+ 
+ 	/* Calculate the hmac */
+ 	bufferCreateFill(&hmacData, bufferGetBuf(&(pEapWsc->InMsg)), bufferLength(&(pEapWsc->InMsg)));
+ 	bufferAdvance(&hmacData, bufferLength(&(pEapWsc->InMsg)));
+ 
+     /* append the current message excluding the last TLV (auth) */
+ 	bufferAppend(&hmacData, bufferLength(pOutMsg), bufferGetBuf(pOutMsg));
+ 
+     /* First calculate the hmac of the data */
+     if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&hmacData), bufferLength(&hmacData), hmac, NULL) == NULL)
+     {
+ 		bufferFree(&hmacData);
+ 		bufferFree(pOutMsg);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_BuildMsgM7: Error generating HMAC");
+         return NOK;
+     }
+ 
+ 	bufferFree(&hmacData);
+ 
+ 	/* u8 *authenticator; 8B */
+ 	wsc_supplicant_SerializeField(WSC_ID_AUTHENTICATOR, pOutMsg, SIZE_AUTHENTICATOR, hmac);
+ 
+ 	/* Store the outgoing message */
+ 	bufferReset(&(pEapWsc->OutMsg));
+ 	bufferAppend(&(pEapWsc->OutMsg), bufferLength(pOutMsg), bufferGetBuf(pOutMsg));
+ 
+ 	wpa_printf(MSG_INFO,"EAP-WSC: EapWsc_BuildMsgM7: EapWsc_BuildMsgM7 built %d byte message", bufferLength(pOutMsg));
+ 
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_ProcessMsgM8(TEapWsc *pEapWsc, bufferObj* pInMsg)
+ {
+ 	u8 version;
+ 	u8 msgType;
+ 	TLVPUINT8 tmpLVPUINT8, tmpLVPUINT8Auth;
+ 	TLVPCHAR tmpLVPCHAR;
+ 	u8 *tmpPos;
+ 
+ 	u8 *ip_encryptedData = NULL;
+ 	int	encrSettingsLength = 0;
+ 	u16 encrDataLength = 0;
+ 	bufferObj cipherText, iv, plainText;
+ 
+ 	bufferObj hmacData;
+ 	u8 dataMac[BUF_SIZE_256_BITS];
+ 
+ 	int	StaEncrSettingsLength;
+ 	u16 TempInBuffer, tmpType;
+ 
+ 	wpa_printf(MSG_INFO,"EAP-WSC: EapWsc_ProcessMsgM8: EapWsc_ProcessMsgM8 of %d byte message", bufferLength(pInMsg));
+ 
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_VERSION, &version) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_VERSION);
+ 		return NOK;
+ 	}
+ 
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_MSG_TYPE, &msgType) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_MSG_TYPE);
+ 		return NOK;
+ 	}
+ 	
+ 	/* u8 *enrolleeNonce ;16B=128 bits */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_ENROLLEE_NONCE, MAX_ENROLLEE_NONCE, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_ENROLLEE_NONCE);
+ 		return NOK;
+ 	}
+ 	/* confirm the enrollee nonce */
+ 	if (memcmp(pEapWsc->enrolleeNonce, tmpLVPUINT8.pValue, tmpLVPUINT8.length))
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Incorrect enrollee nonce received");
+ 		return NOK;
+ 	}
+ 
+     /* encrypted settings */
+ 	tmpPos = bufferPos(pInMsg);
+ 	memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 	if (WSC_ID_ENCR_SETTINGS == ntohs(TempInBuffer))
+     {
+ 		/* Parse Encrypted Settings */
+ 		/* parse the header first. Min data size of the IV + 1 block of data */
+ 		tmpPos = EapWsc_ParseField(pInMsg, WSC_ID_ENCR_SETTINGS, (SIZE_ENCR_IV + ENCR_DATA_BLOCK_SIZE), 0, 1 /* complexed field */, &encrSettingsLength);
+ 		bufferCreateFill(&iv, tmpPos, SIZE_ENCR_IV);
+ 		ip_encryptedData = bufferAdvance(pInMsg, SIZE_ENCR_IV);
+ 		encrDataLength = encrSettingsLength - SIZE_ENCR_IV;
+ 		bufferAdvance(pInMsg, encrDataLength);
+     }
+ 
+ 	/* other attributes */
+ 	while (bufferRemaining(pInMsg) >= sizeof(TTlvHeader))
+ 	{
+ 		tmpPos = bufferPos(pInMsg);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 		tmpType = ntohs(TempInBuffer);
+ 
+ 		switch (tmpType)
+ 		{
+ 			case WSC_ID_AUTHENTICATOR:
+ 				break;
+ 
+ 			default:
+ 
+ 			/* advance past the TLV */
+ 			tmpPos += sizeof(u16); /* advance to length field */
+ 			memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 			bufferAdvance(pInMsg, sizeof(TTlvHeader) + ntohs(TempInBuffer));
+ 				break;
+ 		}
+ 
+ 		if (tmpType == WSC_ID_AUTHENTICATOR)
+ 		{
+ 			break;
+ 		}
+ 	}
+ 
+ 	/* u8 *authenticator; 8B */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_AUTHENTICATOR, MAX_AUTHENTICATOR, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_AUTHENTICATOR);
+ 		return NOK;
+ 	}
+     /* tmpLVPUINT8.pValue, tmpLVPUINT8.length - contain authenticator info */
+ 
+     /******* HMAC validation *******/
+     /* append the last message sent */
+ 	bufferCreateFill(&hmacData, bufferGetBuf(&(pEapWsc->OutMsg)), bufferLength(&(pEapWsc->OutMsg)));
+ 	bufferAdvance(&hmacData, bufferLength(&(pEapWsc->OutMsg)));
+ 
+     /* append the current message. Don't append the last TLV (auth) */
+ 	bufferAppend(&hmacData, 
+ 				bufferLength(pInMsg)-(sizeof(TTlvHeader) + tmpLVPUINT8.length /* authenticator length */), 
+ 				bufferGetBuf(pInMsg));
+ 
+     /* First calculate the hmac of the data */
+     if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&hmacData), bufferLength(&hmacData), dataMac, NULL) == NULL)
+     {
+ 		bufferFree(&hmacData);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Error generating HMAC");
+         return NOK;
+     }
+ 
+ 	bufferFree(&hmacData);
+ 
+     /* next, compare it against the received hmac */
+     if (memcmp(dataMac, tmpLVPUINT8.pValue, tmpLVPUINT8.length) != 0) /* tmpLVPUINT8 contains parsed authenticator info */
+     {
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: HMAC validation failed");
+         return NOK;
+     }
+     /******* HMAC validation *******/
+ 
+ 	/******* extract encrypted settings *******/
+ 	bufferCreateFill(&cipherText, ip_encryptedData, encrDataLength);
+ 	bufferCreateChunk(&plainText);
+ 
+ 	cipherDecrypt(	&cipherText, 
+ 					&iv,
+ 					&pEapWsc->keyWrapKey, 
+ 					&pEapWsc->authKey, 
+ 					&plainText);
+ 
+     bufferFree(&iv);
+ 	bufferFree(&cipherText);
+ 
+ 	bufferRewindStart(&plainText);
+ 
+ 	pEapWsc->pStaEncryptSettings = malloc(sizeof(TStaEncryptSettings));
+ 	if (pEapWsc->pStaEncryptSettings == NULL)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to allocate memory (tlvEsM8Sta)");
+ 		return NOK;
+ 	}
+ 	memset(pEapWsc->pStaEncryptSettings, 0, sizeof(TStaEncryptSettings));
+ 
+ 	/* Parse 1st and only Credential settings */
+ 	tmpPos = EapWsc_ParseField(&plainText, WSC_ID_CREDENTIAL, 0, 0, 1, &StaEncrSettingsLength);
+ 	if (tmpPos == NULL)
+ 	{
+ 		bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Invalid field of type: %d", WSC_ID_CREDENTIAL);
+ 		return NOK;
+ 	}
+ 
+ 	/* u8 nwIndex */
+ 	if (EapWsc_ParseValue8(&plainText, WSC_ID_NW_INDEX, &(pEapWsc->pStaEncryptSettings->credential.nwIndex)) != OK)
+ 	{
+ 		bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_NW_INDEX);
+ 		return NOK;
+ 	}
+ 
+ 	/* u8 *ssid ;32B=256 bits */
+ 	pEapWsc->pStaEncryptSettings->credential.ssid.pValue = malloc(SIZE_32_BYTES);
+ 	if (pEapWsc->pStaEncryptSettings->credential.ssid.pValue == NULL)
+ 	{
+ 		bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to allocate memory (credential.ssid)");
+ 		return NOK;
+ 	}
+ 
+ 	if (EapWsc_ParseValuePtr(&plainText, WSC_ID_SSID, MAX_SSID, &tmpLVPUINT8) != OK)
+ 	{
+ 		bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_SSID);
+ 		return NOK;
+ 	}
+ 	pEapWsc->pStaEncryptSettings->credential.ssid.length = tmpLVPUINT8.length;
+ 	memcpy(pEapWsc->pStaEncryptSettings->credential.ssid.pValue, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 	
+ 	wpa_hexdump_ascii(MSG_DEBUG, "EAP-WSC: EapWsc_ProcessMsgM8: ssid", pEapWsc->pStaEncryptSettings->credential.ssid.pValue, pEapWsc->pStaEncryptSettings->credential.ssid.length);		
+ 
+ 	/* u16 authType */
+ 	if (EapWsc_ParseValue16(&plainText, WSC_ID_AUTH_TYPE, &(pEapWsc->pStaEncryptSettings->credential.authType)) != OK)
+ 	{
+ 		bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_AUTH_TYPE);
+ 		return NOK;
+ 	}
+ 
+ 	wpa_printf(MSG_INFO, "EAP-WSC: EapWsc_ProcessMsgM8: authType = %d",pEapWsc->pStaEncryptSettings->credential.authType);
+ 
+ 	/* u16 encrType */
+ 	if (EapWsc_ParseValue16(&plainText, WSC_ID_ENCR_TYPE, &(pEapWsc->pStaEncryptSettings->credential.encrType)) != OK)
+ 	{
+ 		bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_ENCR_TYPE);
+ 		return NOK;
+ 	}
+ 
+ 	wpa_printf(MSG_INFO, "EAP-WSC: EapWsc_ProcessMsgM8: encrType = %d",pEapWsc->pStaEncryptSettings->credential.encrType);
+ 
+     /* Parse optional network key index */
+     pEapWsc->pStaEncryptSettings->credential.nwKeyIndex = DEFAULT_KEY_INDEX; /* According to spec - default network key index is 1 */
+ 
+     tmpPos = bufferPos(&plainText);
+ 	memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 	if (WSC_ID_NW_KEY_INDEX == ntohs(TempInBuffer)) 
+ 	{
+ 		/* INT8 nwKeyIndex */
+ 	    if (EapWsc_ParseValue8(&plainText, WSC_ID_NW_KEY_INDEX, &(pEapWsc->pStaEncryptSettings->credential.nwKeyIndex)) != OK)
+ 	    {
+ 			bufferFree(&plainText);
+ 			EapWsc_FreeEncryptSettings(pEapWsc);
+       
+ 		    wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_NW_KEY_INDEX);
+ 		    return NOK;
+ 	    }
+ 	}
+ 
+ 	/* char *nwKey */
+ 	pEapWsc->pStaEncryptSettings->credential.nwKey[pEapWsc->pStaEncryptSettings->credential.nwKeyIndex].pValue = malloc(SIZE_512_BITS+1);
+ 	if (pEapWsc->pStaEncryptSettings->credential.nwKey[pEapWsc->pStaEncryptSettings->credential.nwKeyIndex].pValue == NULL)
+ 	{
+ 		bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to allocate memory (credential.nwKey)");
+ 		return NOK;
+ 	}
+ 
+ 	if (EapWsc_ParseCharPtr(&plainText, WSC_ID_NW_KEY, MAX_NW_KEY, &tmpLVPCHAR) != OK)
+ 	{
+ 		bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_NW_KEY);
+ 		return NOK;
+ 	}
+ 	pEapWsc->pStaEncryptSettings->credential.nwKey[pEapWsc->pStaEncryptSettings->credential.nwKeyIndex].length = tmpLVPCHAR.length;
+ 	memcpy(pEapWsc->pStaEncryptSettings->credential.nwKey[pEapWsc->pStaEncryptSettings->credential.nwKeyIndex].pValue, tmpLVPCHAR.pValue, tmpLVPCHAR.length);	
+ 
+ 	if ((pEapWsc->pStaEncryptSettings->credential.authType & WSC_AUTHTYPE_WPAPSK) || (pEapWsc->pStaEncryptSettings->credential.authType & WSC_AUTHTYPE_WPA2PSK))
+ 	{
+ 		wpa_hexdump_ascii(MSG_DEBUG, "EAP-WSC: EapWsc_ProcessMsgM8: nwKey", (u8 *)(pEapWsc->pStaEncryptSettings->credential.nwKey[pEapWsc->pStaEncryptSettings->credential.nwKeyIndex].pValue), pEapWsc->pStaEncryptSettings->credential.nwKey[pEapWsc->pStaEncryptSettings->credential.nwKeyIndex].length);
+ 	}
+ 
+    /* Eitan TO DO: Parse multiple network keys */
+ 
+ 	/* u8 *macAddr; 6B */
+ 	pEapWsc->pStaEncryptSettings->credential.macAddr.pValue = malloc(MAX_MAC_ADDR);
+ 	if (pEapWsc->pStaEncryptSettings->credential.macAddr.pValue == NULL)
+ 	{
+ 		bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to allocate memory (credential.macAddr)");
+ 		return NOK;
+ 	}
+ 	if (EapWsc_ParseValuePtr(&plainText, WSC_ID_MAC_ADDR, MAX_MAC_ADDR, &tmpLVPUINT8) != OK)
+ 	{
+ 		bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_MAC_ADDR);
+ 		return NOK;
+ 	}
+ 	pEapWsc->pStaEncryptSettings->credential.macAddr.length = tmpLVPUINT8.length;
+ 	memcpy(pEapWsc->pStaEncryptSettings->credential.macAddr.pValue, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 
+ 	wpa_hexdump_ascii(MSG_DEBUG, "EAP-WSC: EapWsc_ProcessMsgM8: macAddr", pEapWsc->pStaEncryptSettings->credential.macAddr.pValue, pEapWsc->pStaEncryptSettings->credential.macAddr.length);
+ 
+ 	/* Parse optional attributes */
+ 
+     /* 25/9/2006 - parse EAP_TYPE, KEY_PROVIDED_AUTOMATICALLY, IS_802_1_X_ENABLED and WEP_TRANSMIT_KEY TLVs */
+ 
+     /* u8 *eapType */
+     if (bufferRemaining(&plainText) >= sizeof(TTlvHeader))
+ 	{
+ 		/* Nothing is done with the parsed field at this stage */
+ 		/* FOR FUTURE USE - handle field here */
+ 		tmpPos = bufferPos(&plainText);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 		if (WSC_ID_EAP_TYPE == ntohs(TempInBuffer)) 
+ 		{
+ 			if (EapWsc_ParseValuePtr(&plainText, WSC_ID_EAP_TYPE, 0, &tmpLVPUINT8) != OK)
+ 			{
+ 				bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 				wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_EAP_TYPE);
+ 				return NOK;
+ 			}
+ 			pEapWsc->pStaEncryptSettings->credential.eapType.pValue = malloc(tmpLVPUINT8.length);
+ 			if (pEapWsc->pStaEncryptSettings->credential.eapType.pValue == NULL)
+ 			{
+ 				bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 				wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to allocate memory (credential.eapIdentity)");
+ 				return NOK;
+ 			}
+ 			pEapWsc->pStaEncryptSettings->credential.eapType.length = tmpLVPUINT8.length;
+ 			memcpy(pEapWsc->pStaEncryptSettings->credential.eapType.pValue, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 		}
+ 	}
+ 
+  	tmpPos = bufferPos(&plainText);
+ 	memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 	if (WSC_ID_KEY_PROVIDED_AUTO == ntohs(TempInBuffer)) 
+ 	{
+       /* u16 encrType */
+       if (EapWsc_ParseValue8(&plainText, WSC_ID_KEY_PROVIDED_AUTO, &(pEapWsc->pStaEncryptSettings->credential.bKey_Provided_Automatically)) != OK)
+       {
+     	bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+    		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_KEY_PROVIDED_AUTO);
+    		return NOK;
+       }
+     }
+ 
+     tmpPos = bufferPos(&plainText);
+ 	memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 	if (WSC_ID_802_1_X_ENABLED == ntohs(TempInBuffer)) 
+ 	{
+       /* u16 encrType */
+       if (EapWsc_ParseValue8(&plainText, WSC_ID_802_1_X_ENABLED, &(pEapWsc->pStaEncryptSettings->credential.b_Is_802_1x_enabled)) != OK)
+       {
+     	bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+    		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_802_1_X_ENABLED);
+    		return NOK;
+       }
+     }
+ 
+     tmpPos = bufferPos(&plainText);
+ 	memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 	if (WSC_ID_WEP_TRANSMIT_KEY == ntohs(TempInBuffer)) 
+ 	{
+       /* u16 encrType */
+       if (EapWsc_ParseValue8(&plainText, WSC_ID_WEP_TRANSMIT_KEY, &(pEapWsc->pStaEncryptSettings->credential.WEP_transmit_key)) != OK)
+       {
+     	bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+    		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_WEP_TRANSMIT_KEY);
+    		return NOK;
+       }
+     }
+ 
+ /* ------------------------------------------------------- */
+ 
+ 	if (bufferRemaining(&plainText) >= sizeof(TTlvHeader))
+ 	{
+ 		/* u8 *eapIdentity */
+ 		/* Nothing is done with the parsed field at this stage */
+ 		/* FOR FUTURE USE - handle field here */
+ 		tmpPos = bufferPos(&plainText);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 		if (WSC_ID_EAP_IDENTITY == ntohs(TempInBuffer)) 
+ 		{
+ 			if (EapWsc_ParseValuePtr(&plainText, WSC_ID_EAP_IDENTITY, 0, &tmpLVPUINT8) != OK)
+ 			{
+ 				bufferFree(&plainText);
+ 				EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 				wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_EAP_IDENTITY);
+ 				return NOK;
+ 			}
+ 			pEapWsc->pStaEncryptSettings->credential.eapIdentity.pValue = malloc(tmpLVPUINT8.length);
+ 			if (pEapWsc->pStaEncryptSettings->credential.eapIdentity.pValue == NULL)
+ 			{
+ 				bufferFree(&plainText);
+ 				EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 				wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to allocate memory (credential.eapIdentity)");
+ 				return NOK;
+ 			}
+ 			pEapWsc->pStaEncryptSettings->credential.eapIdentity.length = tmpLVPUINT8.length;
+ 			memcpy(pEapWsc->pStaEncryptSettings->credential.eapIdentity.pValue, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 		}
+ 	}
+ 
+ 	if (bufferRemaining(&plainText) >= sizeof(TTlvHeader))
+ 	{
+ 		/* UINT32 keyLifetime */
+ 		/* Nothing is done with the parsed field at this stage */
+ 		/* FOR FUTURE USE - handle field here */
+ 		tmpPos = bufferPos(&plainText);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 		if (WSC_ID_KEY_LIFETIME == ntohs(TempInBuffer)) 
+ 		{
+ 			if (EapWsc_ParseValue32(&plainText, WSC_ID_KEY_LIFETIME, &(pEapWsc->pStaEncryptSettings->credential.keyLifetime)) != OK)
+ 			{
+ 				bufferFree(&plainText);
+ 				EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 				wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_KEY_LIFETIME);
+ 				return NOK;
+ 			}
+ 		}
+ 	}
+ 
+ 	if (bufferRemaining(&plainText) >= sizeof(TTlvHeader))
+ 	{
+ 		/* void *vendorExt */
+ 		/* skip vendor extension fields (there may be multiple TLVs) */
+ 		tmpPos = bufferPos(&plainText);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 		while (WSC_ID_VENDOR_EXT == ntohs(TempInBuffer)) 
+ 		{
+ 			/* advance past the TLV */
+ 			tmpPos += sizeof(u16); /* advance to length field */
+ 			memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 			bufferAdvance(&plainText, sizeof(TTlvHeader) + ntohs(TempInBuffer));
+ 
+ 			tmpPos = bufferPos(&plainText);
+ 		}
+ 	}
+ 
+ 	if (bufferRemaining(&plainText) >= sizeof(TTlvHeader))
+ 	{
+ 		/* u8 *rekeyKey; 32B */
+ 		/* Nothing is done with the parsed field at this stage */
+ 		/* FOR FUTURE USE - handle field here */
+ 		tmpPos = bufferPos(&plainText);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 		if (WSC_ID_REKEY_KEY == ntohs(TempInBuffer)) 
+ 		{
+ 			if (EapWsc_ParseValuePtr(&plainText, WSC_ID_REKEY_KEY, 0, &tmpLVPUINT8) != OK)
+ 			{
+ 				bufferFree(&plainText);
+ 				EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 				wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_REKEY_KEY);
+ 				return NOK;
+ 			}
+ 			pEapWsc->pStaEncryptSettings->credential.rekeyKey.pValue = malloc(tmpLVPUINT8.length);
+ 			if (pEapWsc->pStaEncryptSettings->credential.rekeyKey.pValue == NULL)
+ 			{
+ 				bufferFree(&plainText);
+ 				EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 				wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to allocate memory (credential.eapIdentity)");
+ 				return NOK;
+ 			}
+ 			pEapWsc->pStaEncryptSettings->credential.rekeyKey.length = tmpLVPUINT8.length;
+ 			memcpy(pEapWsc->pStaEncryptSettings->credential.rekeyKey.pValue, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 		}
+ 	}
+ 
+ 	if (bufferRemaining(&plainText) >= sizeof(TTlvHeader))
+ 	{
+ 		/* u8 *x509Cert */
+ 		/* Nothing is done with the parsed field at this stage */
+ 		/* FOR FUTURE USE - handle field here */
+ 		tmpPos = bufferPos(&plainText);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 		if (WSC_ID_X509_CERT == ntohs(TempInBuffer)) 
+ 		{
+ 			if (EapWsc_ParseValuePtr(&plainText, WSC_ID_X509_CERT, 0, &tmpLVPUINT8) != OK)
+ 			{
+ 				bufferFree(&plainText);
+ 				EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 				wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_X509_CERT);
+ 				return NOK;
+ 			}
+ 			pEapWsc->pStaEncryptSettings->credential.x509Cert.pValue = malloc(tmpLVPUINT8.length);
+ 			if (pEapWsc->pStaEncryptSettings->credential.x509Cert.pValue == NULL)
+ 			{
+ 				bufferFree(&plainText);
+ 				EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 				wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to allocate memory (credential.x509Cert)");
+ 				return NOK;
+ 			}
+ 			pEapWsc->pStaEncryptSettings->credential.x509Cert.length = tmpLVPUINT8.length;
+ 			memcpy(pEapWsc->pStaEncryptSettings->credential.x509Cert.pValue, tmpLVPUINT8.pValue, tmpLVPUINT8.length);
+ 		}
+ 	}
+ 
+ 	if (bufferRemaining(&plainText) >= sizeof(TTlvHeader))
+ 	{
+ 		tmpPos = bufferPos(&plainText);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 		if (WSC_ID_NEW_PWD == ntohs(TempInBuffer)) 
+ 		{
+ 			/* If the New Password TLV is included, the Device password ID is required */
+ 			/* char *new_pwd */
+ 			pEapWsc->pStaEncryptSettings->new_pwd.pValue = malloc(SIZE_64_BYTES);
+ 			if (pEapWsc->pStaEncryptSettings->new_pwd.pValue == NULL)
+ 			{
+ 				bufferFree(&plainText);
+ 				EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 				wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to allocate memory (tlvEsM8Sta.new_pwd)");
+ 				return NOK;
+ 			}
+ 				if (EapWsc_ParseCharPtr(&plainText, WSC_ID_NEW_PWD, MAX_NEW_PWD, &tmpLVPCHAR) != OK)
+ 			{
+ 				bufferFree(&plainText);
+ 				EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 				wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_NEW_PWD);
+ 				return NOK;
+ 			}
+ 			pEapWsc->pStaEncryptSettings->new_pwd.length = tmpLVPCHAR.length;
+ 			memcpy(pEapWsc->pStaEncryptSettings->new_pwd.pValue, tmpLVPCHAR.pValue, tmpLVPCHAR.length);
+ 
+ 			/* u16 pwdId */
+ 			if (EapWsc_ParseValue16(&plainText, WSC_ID_DEVICE_PWD_ID, &(pEapWsc->pStaEncryptSettings->pwdId)) != OK)
+ 			{
+ 				bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 				wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_DEVICE_PWD_ID);
+ 				return NOK;
+ 			}
+ 		}
+ 	}
+ 
+ 	if (bufferRemaining(&plainText) >= sizeof(TTlvHeader))
+ 	{
+ 		/* skip vendor extension fields (There may be multiple TLVs) */
+ 		tmpPos = bufferPos(&plainText);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 		while ((WSC_ID_VENDOR_EXT == ntohs(TempInBuffer)) ||
+                        (WSC_ID_RF_BAND == ntohs(TempInBuffer)))
+ 		{
+ 			/* advance past the TLV */
+ 			tmpPos += sizeof(u16); /* advance to length field */
+ 			memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 			bufferAdvance(&plainText, sizeof(TTlvHeader) + ntohs(TempInBuffer));
+ 
+ 			tmpPos = bufferPos(&plainText);
+                         memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 		}
+ 	}
+ 
+ 	/* u8 *KeyWrapAuthenticator */
+ 	bufferSet(&plainText, bufferGetBuf(&plainText)+
+ 			bufferLength(&plainText)-(sizeof(TTlvHeader)+MAX_KEY_WRAP_AUTH));
+ 	if (EapWsc_ParseValuePtr(&plainText, WSC_ID_KEY_WRAP_AUTH, MAX_KEY_WRAP_AUTH, &tmpLVPUINT8Auth) != OK)
+ 	{
+ 		bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Failed to parse field of type: %d", WSC_ID_KEY_WRAP_AUTH);
+ 		return NOK;
+ 	}
+ 	/* tmpLVPUINT8Auth.pValue, tmpLVPUINT8Auth.length - contain Key Wrap authenticator info */
+ 
+ 	/* validate the mac */
+ 
+ 	/* calculate the hmac of the data (data only, not the last auth TLV) */
+ 	if (HMAC(EVP_sha256(), bufferGetBuf(&(pEapWsc->authKey)), SIZE_256_BITS, bufferGetBuf(&plainText), bufferLength(&plainText) - (sizeof(TTlvHeader) + tmpLVPUINT8Auth.length), dataMac, NULL) == NULL)
+ 	{
+ 		bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Error generating HMAC of extracted encrypted settings");
+ 		return NOK;
+ 	}
+ 
+ 	/* next, compare it against the received hmac */
+ 	if (memcmp(dataMac, tmpLVPUINT8Auth.pValue, tmpLVPUINT8Auth.length) != 0) /* tmpLVPUINT8 contains parsed authenticator info */
+ 	{
+ 		bufferFree(&plainText);
+ 		EapWsc_FreeEncryptSettings(pEapWsc);
+ 
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgM8: Validation of encrypted settings HMAC - failed");
+ 		return NOK;
+ 	}
+ 
+ 	bufferFree(&plainText);
+ 	
+ 	/******* extract encrypted settings *******/
+ 
+     /* Store the received buffer */
+ 	bufferReset(&pEapWsc->InMsg);
+ 	bufferAppend(&pEapWsc->InMsg, bufferLength(pInMsg), bufferGetBuf(pInMsg));
+ 
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_BuildMsgDone(TEapWsc *pEapWsc, bufferObj* pOutMsg)
+ {
+ 	u8 msgType = WSC_ID_MESSAGE_DONE;
+ 
+ 	/* create Msg */
+ 	bufferCreateChunk(pOutMsg);
+ 
+ 	/* u8 version */
+ 	wsc_supplicant_SerializeField(WSC_ID_VERSION, pOutMsg, SIZE_VERSION, &(pEapWsc->pWscSupplicantConfig->version));
+ 
+ 	/* u8 msgType */
+ 	wsc_supplicant_SerializeField(WSC_ID_MSG_TYPE, pOutMsg, SIZE_MSG_TYPE, &msgType);
+ 
+ 	/* u8 *enrolleeNonce ;16B=128 bits */
+ 	wsc_supplicant_SerializeField(WSC_ID_ENROLLEE_NONCE, pOutMsg, SIZE_ENROLLEE_NONCE, pEapWsc->enrolleeNonce);
+ 
+ 	/* u8 *registrarNonce ;16B=128 bits */
+ 	wsc_supplicant_SerializeField(WSC_ID_REGISTRAR_NONCE, pOutMsg, SIZE_REGISTRAR_NONCE, pEapWsc->registrarNonce);
+ 
+ 	wpa_printf(MSG_INFO,"EAP-WSC: EapWsc_BuildMsgDone: EapWsc_BuildMsgDone built %d byte message", bufferLength(pOutMsg));
+ 
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_ProcessMsgAck(TEapWsc *pEapWsc, bufferObj* pInMsg)
+ {
+ 	u8 version;
+ 	u8 msgType;
+ 	TLVPUINT8 tmpLVPUINT8;
+ 	u8 *tmpPos;
+ 	u16 TempInBuffer;
+ 
+ 	wpa_printf(MSG_INFO,"EAP-WSC: EapWsc_ProcessMsgAck: EapWsc_ProcessMsgAck of %d byte message", bufferLength(pInMsg));
+ 
+ 	/* deserialize (parse) the message */
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_VERSION, &version) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgAck: Failed to parse field of type: %d", WSC_ID_VERSION);
+ 		return NOK;
+ 	}
+ 
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_MSG_TYPE, &msgType) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgAck: Failed to parse field of type: %d", WSC_ID_MSG_TYPE);
+ 		return NOK;
+ 	}
+ 
+ 	/* u8 *enrolleeNonce ;16B=128 bits */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_ENROLLEE_NONCE, MAX_ENROLLEE_NONCE, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgAck: Failed to parse field of type: %d", WSC_ID_ENROLLEE_NONCE);
+ 		return NOK;
+ 	}
+ 	/* confirm the enrollee nonce */
+ 	if (memcmp(pEapWsc->enrolleeNonce, tmpLVPUINT8.pValue, tmpLVPUINT8.length))
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgAck: Incorrect enrollee nonce received");
+ 		return NOK;
+ 	}
+ 
+ 	/* u8 *registrarNonce ;16B=128 bits */
+ 	if (EapWsc_ParseValuePtr(pInMsg, WSC_ID_REGISTRAR_NONCE, MAX_REGISTRAR_NONCE, &tmpLVPUINT8) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgAck: Failed to parse field of type: %d", WSC_ID_REGISTRAR_NONCE);
+ 		return NOK;
+ 	}
+ 
+ 	/* confirm the registrar nonce */
+ 	if (memcmp(pEapWsc->registrarNonce, tmpLVPUINT8.pValue, tmpLVPUINT8.length))
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_ProcessMsgAck: Incorrect registrar nonce received");
+ 		return NOK;
+ 	}
+ 
+ 	/* other attributes */
+ 	while (bufferRemaining(pInMsg) >= sizeof(TTlvHeader))
+ 	{
+ 		tmpPos = bufferPos(pInMsg);
+ 		memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 
+ 		switch (ntohs(TempInBuffer))
+ 		{
+ 			default:
+ 
+ 				/* advance past the TLV */
+ 				tmpPos += sizeof(u16); /* advance to length field */
+ 				memcpy(&TempInBuffer, tmpPos, sizeof(u16));
+ 				bufferAdvance(pInMsg, sizeof(TTlvHeader) + ntohs(TempInBuffer));
+ 				break;
+ 		}
+ 	}
+ 
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_GetMsgType(TEapWsc *pEapWsc, u8 *msgType, bufferObj* pInMsg)
+ {
+ 	u8 version;
+ 	*msgType = WSC_ID_MESSAGE_UNKNOWN;
+ 
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_VERSION, &version) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_GetMsgType: Failed to parse field of type: %d", WSC_ID_VERSION);
+ 		return NOK;
+ 	}
+ 
+ 	if(version != pEapWsc->pWscSupplicantConfig->version) 
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_GetMsgType: SC Version specified (0x%x) is incompatible with LocalStationConfig SC version: 0x%x", version, pEapWsc->pWscSupplicantConfig->version);
+ 		return NOK;
+ 	}
+ 
+ 	if (EapWsc_ParseValue8(pInMsg, WSC_ID_MSG_TYPE, msgType) != OK)
+ 	{
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_GetMsgType: Failed to parse field of type: %d", WSC_ID_MSG_TYPE);
+ 		return NOK;
+ 	}
+ 
+     bufferRewindStart(pInMsg);
+ 	return OK;
+ }
+ 
+ static u32 EapWsc_HandleMsg(TEapWsc *pEapWsc, bufferObj* pInMsg, bufferObj* pOutMsg)
+ {
+ 	u8 msgType = 0;
+ 	
+ 	switch (pEapWsc->LastMessageSent)
+     {
+ 		case WSC_ID_MESSAGE_UNKNOWN:
+ 
+ 			if (OK != EapWsc_BuildMsgM1(pEapWsc, pOutMsg)) return NOK;
+ 			pEapWsc->LastMessageSent = WSC_ID_MESSAGE_M1;
+ 			break;
+ 			
+ 		case WSC_ID_MESSAGE_M1:
+ 
+ 			if(OK != EapWsc_GetMsgType(pEapWsc, &msgType, pInMsg)) return NOK;
+ 
+ 			switch(msgType)
+ 			{
+ 				case WSC_ID_MESSAGE_M2D:
+ 					
+ 					pEapWsc->LastMessageRecv = WSC_ID_MESSAGE_M2D;
+ 					/* Process message M2D from the registrar */
+ 					if(OK != EapWsc_ProcessMsgM2D(pEapWsc, pInMsg)) return NOK;					
+ 					/* Send an ACK to the registrar */
+ 					EapWsc_BuildMsgAck(pEapWsc, pOutMsg);					
+ 					pEapWsc->LastMessageSent = WSC_ID_MESSAGE_ACK;
+ 					break;
+ 					
+ 				case WSC_ID_MESSAGE_M2:
+ 
+ 					pEapWsc->LastMessageRecv = WSC_ID_MESSAGE_M2;
+ 					/* Process message M2 from the registrar */
+ 					if (OK != EapWsc_ProcessMsgM2(pEapWsc, pInMsg)) return NOK;
+ 					/* Send message M3 to the registrar */
+ 					if (OK != EapWsc_BuildMsgM3(pEapWsc, pOutMsg)) return NOK;					
+ 					pEapWsc->LastMessageSent = WSC_ID_MESSAGE_M3;
+ 					break;
+ 					
+ 				default:
+ 					wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_HandleMsg: WSC_ID_MESSAGE_M1 - Received wrong message type: %d", msgType);
+ 				return NOK;
+ 			}
+ 			break;
+ 			
+ 		case WSC_ID_MESSAGE_M3:
+ 			
+ 			if(OK != EapWsc_GetMsgType(pEapWsc, &msgType, pInMsg)) return NOK;
+ 			pEapWsc->LastMessageRecv = WSC_ID_MESSAGE_M4;
+ 			/* Process message M4 from the registrar */
+ 			if(OK != EapWsc_ProcessMsgM4(pEapWsc, pInMsg)) return NOK;
+ 			/* Send message M5 to the registrar */
+ 			if (OK != EapWsc_BuildMsgM5(pEapWsc, pOutMsg)) return NOK;					
+ 			pEapWsc->LastMessageSent = WSC_ID_MESSAGE_M5;
+ 			break;
+ 
+ 		case WSC_ID_MESSAGE_M5:
+ 			
+ 			if(OK != EapWsc_GetMsgType(pEapWsc, &msgType, pInMsg)) return NOK;
+ 			pEapWsc->LastMessageRecv = WSC_ID_MESSAGE_M6;
+ 			/* Process message M6 from the registrar */
+ 			if(OK != EapWsc_ProcessMsgM6(pEapWsc, pInMsg)) return NOK;
+ 			/* Send message M7 to the registrar */
+ 			if (OK != EapWsc_BuildMsgM7(pEapWsc, pOutMsg)) return NOK;					
+ 			pEapWsc->LastMessageSent = WSC_ID_MESSAGE_M7;
+ 			break;
+ 		
+ 		case WSC_ID_MESSAGE_M7:
+ 
+ 			if(OK != EapWsc_GetMsgType(pEapWsc, &msgType, pInMsg)) return NOK;
+ 			pEapWsc->LastMessageRecv = WSC_ID_MESSAGE_M8;
+ 			/* Process message M8 from the registrar */
+ 			if(OK != EapWsc_ProcessMsgM8(pEapWsc, pInMsg)) return NOK;
+ 
+ 			/* Send message DONE to the registrar */
+ 			if (OK != EapWsc_BuildMsgDone(pEapWsc, pOutMsg)) return NOK;					
+ 			pEapWsc->LastMessageSent = WSC_ID_MESSAGE_DONE;
+ 
+ 			pEapWsc->smState = EAP_WSC_STATE_SUCCESS;
+ 			break;
+ 
+ 		case WSC_ID_MESSAGE_DONE:
+ 
+ 			if(OK != EapWsc_GetMsgType(pEapWsc, &msgType, pInMsg)) return NOK;
+ 			pEapWsc->LastMessageRecv = WSC_ID_MESSAGE_ACK;
+ 			/* Process message ACK from the registrar */
+ 			if(OK != EapWsc_ProcessMsgAck(pEapWsc, pInMsg)) return NOK;
+ 
+ 			break;
+ 
+ 			}
+ 
+ 	return OK;
+ 	}
+ 
+ static void EapWsc_RestartSM(TEapWsc* pEapWsc)
+ {
+ 	if(pEapWsc->DHSecret)
+ 	{
+ 		DH_free(pEapWsc->DHSecret);
+ 		pEapWsc->DHSecret = NULL;
+ 	}
+ 
+ 	if(pEapWsc->pPeerDeviceInfo) {
+ 		free(pEapWsc->pPeerDeviceInfo);
+ 		pEapWsc->pPeerDeviceInfo = NULL;
+ 	}
+ 	EapWsc_FreeEncryptSettings(pEapWsc);
+ 	
+ 	bufferFree(&(pEapWsc->keyWrapKey));
+ 	bufferFree(&(pEapWsc->authKey));
+ 	bufferFree(&(pEapWsc->InMsg));
+ 	bufferFree(&(pEapWsc->OutMsg));
+ 
+ 	// free(pEapWsc);
+ }
+ 
+ static u32 EapWsc_CheckMsg(EEapWsc_SMState state, const u8 *reqData, size_t reqDataLen, TEapWscPacketHeader* hdr, struct eap_method_ret *ret)
+ {
+ 	if(state == EAP_WSC_STATE_START)
+ 	{
+ 		if (!reqData || !reqDataLen || (hdr->opCode != WSC_Start))
+         {
+ 			wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_CheckMsg: Wrong input parameters");
+ 			ret->ignore = TRUE;
+ 			return NOK;
+         }				
+ 	}
+ 	else
+ 	{
+ 		if(!reqData || !reqDataLen)
+         {
+ 			wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_CheckMsg: Wrong input parameters");
+ 			ret->ignore = TRUE;
+ 			return NOK;
+         }
+ 
+ 		wpa_printf(MSG_DEBUG,"EAP-WSC: EapWsc_CheckMsg: Received packet, Length = %lu", (unsigned long) reqDataLen);
+ 
+         if((hdr->opCode < WSC_Start) || (hdr->opCode > WSC_Done))
+         {
+ 			wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_CheckMsg: Wrong OpCode received");
+ 			ret->ignore = TRUE;
+ 			return NOK;
+         }
+ 
+         if(hdr->flags & 0x02) 
+         {
+ 			wpa_printf(MSG_ERROR,"EAP-WSC: EapWsc_CheckMsg: First EAP Packet of a fragmented EAP Msg received, EAP fragmentation not supported.");
+ 			ret->ignore = TRUE;
+ 			return NOK;
+         }        
+ 	}	
+ 
+ 	return OK;
+ }
+ 
+ 
+ 
+ static void * eap_wsc_init(struct eap_sm *sm)
+ {
+ 	TEapWsc* pEapWsc;
+ 
+     wpa_printf(MSG_INFO,"EAP-WSC: Entered eap_wsc_init");
+ 
+     pEapWsc = malloc(sizeof(*pEapWsc));
+     if (pEapWsc == NULL)
+         return NULL;
+     memset(pEapWsc, 0, sizeof(*pEapWsc));
+ 
+ 
+     pEapWsc->smState = EAP_WSC_STATE_START;
+ 	pEapWsc->LastMessageSent = WSC_ID_MESSAGE_UNKNOWN;
+     pEapWsc->sm = sm;
+ 	pEapWsc->pWscSupplicantConfig = wsc_supplicant_GetWscSupplicantConfig();
+     
+ 
+ 	pEapWsc->DH_PubKey_Peer = NULL;
+ 	pEapWsc->DHSecret = NULL;
+ 	pEapWsc->pPeerDeviceInfo = NULL;	
+ 
+     return pEapWsc;
+ }
+ 
+ 
+ static void eap_wsc_deinit(struct eap_sm *sm, void *priv)
+ {
+     wpa_printf(MSG_INFO,"EAP-WSC: Entered eap_wsc_deinit");
+ }
+ 
+ 
+ static u8 * eap_wsc_process(struct eap_sm *sm, void *priv,
+ 			    struct eap_method_ret *ret,
+ 			    const u8 *reqData, size_t reqDataLen,
+ 			    size_t *respDataLen)
+ {
+ 	u32 res;
+ 	TEapWsc* pEapWsc = priv;
+ 	TEapWscPacketHeader* hdr = (TEapWscPacketHeader*)reqData;
+ 	bufferObj InMsg,OutMsg;
+ 	u8* 					resp;
+ 	TEapWscPacketHeader* 	respHeader;
+ 	
+ 	wpa_printf(MSG_INFO,"EAP-WSC: Entered eap_wsc_process");
+ 
+ 	switch(pEapWsc->smState)
+ 	{
+ 		case EAP_WSC_STATE_START:
+ 			
+ 			if (OK != EapWsc_CheckMsg(pEapWsc->smState, reqData, reqDataLen, hdr, ret)) return NULL;				
+ 			res = EapWsc_HandleMsg(pEapWsc, NULL, &OutMsg);
+ 			if(res != OK)
+         	{
+ 				pEapWsc->smState = EAP_WSC_STATE_FAILURE;
+ 				ret->ignore = TRUE;
+ 				return NULL;
+         	}
+ 			/* set the message state to CONTINUE */
+ 			pEapWsc->smState = EAP_WSC_STATE_CONTINUE;
+ 			break;
+ 
+ 		case EAP_WSC_STATE_CONTINUE:
+ 			
+ 			if (OK != EapWsc_CheckMsg(pEapWsc->smState, reqData, reqDataLen, hdr, ret)) return NULL;
+ 			bufferCreateFill(&InMsg, (u8*)(reqData + WSC_EAP_PACKET_HEADER_LEN), reqDataLen - WSC_EAP_PACKET_HEADER_LEN);
+ 			res = EapWsc_HandleMsg(pEapWsc, &InMsg, &OutMsg);
+ 				if(res != OK)
+ 				{
+ 					pEapWsc->smState = EAP_WSC_STATE_FAILURE;
+ 					ret->ignore = TRUE;
+ 					return NULL;
+ 				}
+ 			break;
+ 
+ 		case EAP_WSC_STATE_SUCCESS:
+ 		case EAP_WSC_STATE_FAILURE:
+ 			break;
+ 	}
+ 
+ 	/*
+ 	handle success and failure states
+ 	*/
+ 	switch(pEapWsc->smState)
+ 	{
+ 		case EAP_WSC_STATE_START:
+ 		case EAP_WSC_STATE_CONTINUE:
+ 			break;
+ 			
+ 		case EAP_WSC_STATE_SUCCESS:
+ 
+ 			ret->methodState = METHOD_DONE;
+ 			break;
+ 			
+ 		case EAP_WSC_STATE_FAILURE:
+ 
+ 			wpa_printf(MSG_ERROR,"EAP-WSC: eap_wsc_process: FAILURE");
+ 
+ 			/* reset the SM */
+ 			EapWsc_RestartSM(pEapWsc);
+ 			ret->ignore = TRUE;
+ 			return NULL;			
+ 	}
+ 
+ 	resp = (u8 *) malloc(bufferLength(&OutMsg) + WSC_EAP_PACKET_HEADER_LEN);
+     if (!resp)
+     {
+ 		wpa_printf(MSG_ERROR,"EAP-WSC: eap_wsc_process: Memory allocation for response - failed");
+ 		pEapWsc->smState = EAP_WSC_STATE_FAILURE;
+ 		bufferFree(&OutMsg);
+         ret->ignore = TRUE;
+ 	    return NULL;
+     }
+ 
+ 	respHeader = (TEapWscPacketHeader*) resp;
+ 
+ 	respHeader->code = WSC_EAP_CODE_RESPONSE;
+ 	respHeader->id = hdr->id;
+ 	respHeader->len = htons((u16)(bufferLength(&OutMsg) + WSC_EAP_PACKET_HEADER_LEN));
+ 	respHeader->type = WSC_EAP_TYPE;
+ 	respHeader->vendorId[0] = WSC_VENDORID_0;
+ 	respHeader->vendorId[1] = WSC_VENDORID_1;
+ 	respHeader->vendorId[2] = WSC_VENDORID_2;
+ 	respHeader->vendorType = htonl(WSC_VENDORTYPE);
+ 
+ 	if (pEapWsc->LastMessageSent == WSC_ID_MESSAGE_ACK)
+ 	{
+ 		respHeader->opCode = WSC_ACK;
+ 	}
+ 	else if (pEapWsc->LastMessageSent == WSC_ID_MESSAGE_DONE)
+ 	{
+ 		respHeader->opCode = WSC_Done;
+ 	}
+ 	else
+ 	{
+ 		respHeader->opCode = WSC_MSG;
+ 	}
+ 
+ 	respHeader->flags = 0;
+ 
+     if (bufferGetBuf(&OutMsg) != NULL)
+     {
+         memcpy((resp + WSC_EAP_PACKET_HEADER_LEN), bufferGetBuf(&OutMsg), bufferLength(&OutMsg));
+     }
+ 
+     *respDataLen = bufferLength(&OutMsg) + WSC_EAP_PACKET_HEADER_LEN;
+ 	bufferFree(&OutMsg);
+ 
+     ret->ignore = FALSE;
+     ret->decision = DECISION_COND_SUCC;
+     ret->allowNotifications = FALSE;
+ 
+     return resp;
+ 
+ }
+ 
+ int eap_peer_wsc_register(void)
+ {
+ 	struct eap_method *eap;
+ 	int ret;
+ 
+ 	eap = eap_peer_method_alloc(EAP_PEER_METHOD_INTERFACE_VERSION,
+ 				    EAP_VENDOR_IETF, EAP_TYPE_WSC, "WSC");
+ 	if (eap == NULL)
+ 		return -1;
+ 
+ 	eap->init = eap_wsc_init;
+ 	eap->deinit = eap_wsc_deinit;
+ 	eap->process = eap_wsc_process;
+ 
+ 	ret = eap_peer_method_register(eap);
+ 	if (ret)
+ 		eap_peer_method_free(eap);
+ 	return ret;
+ }
+ 
+ void EapWsc_EapFailureRecv(void *priv)
+ {
+ 	TEapWsc* pEapWsc = priv;
+ 
+ #ifdef CONFIG_EAP_WSC
+   if((pEapWsc->pWscSupplicantConfig->WscMode == WSC_MODE_PBC)||(pEapWsc->pWscSupplicantConfig->WscMode == WSC_MODE_PIN))
+ #endif
+   {
+     
+ 	if (pEapWsc->smState == EAP_WSC_STATE_SUCCESS)
+ 	{
+ 		/* 
+ 		this is the EAP-FAIL at the end of the WPS handshake 
+ 		so now we need to do the real authentication 
+ 		*/
+ 		wsc_supplicant_EapSuccess(pEapWsc->pStaEncryptSettings);
+ 	}
+ 
+     EapWsc_RestartSM(pEapWsc); /* Reset the struct of eap_wsc EAP method state machine */
+   }
+ }
diff -BNcr wpa_supplicant-0.5.7/events.c wpa_view/wpa_suppl/events.c
*** wpa_supplicant-0.5.7/events.c	Sun Oct 29 20:27:49 2006
--- wpa_view/wpa_suppl/events.c	Wed Jun  9 13:30:14 2010
***************
*** 28,33 ****
--- 28,36 ----
  #include "wpa_ctrl.h"
  #include "eap.h"
  #include "ctrl_iface_dbus.h"
+ #ifdef CONFIG_EAP_WSC
+ #include "wsc_supplicant.h"
+ #endif
  
  
  static int wpa_supplicant_select_config(struct wpa_supplicant *wpa_s)
***************
*** 675,681 ****
--- 679,693 ----
  		/* Timeout for receiving the first EAPOL packet */
  		wpa_supplicant_req_auth_timeout(wpa_s, 10, 0);
  	}
+ 
  	wpa_supplicant_cancel_scan(wpa_s);
+ 
+ #ifdef CONFIG_EAP_WSC
+ 	if(wpa_s->current_ssid)
+ 	{
+ 		wsc_supplicant_event_assoc(wpa_s->current_ssid);		
+ 	}
+ #endif
  }
  
  
***************
*** 706,713 ****
  		bssid = wpa_s->pending_bssid;
  	wpa_blacklist_add(wpa_s, bssid);
  	wpa_sm_notify_disassoc(wpa_s->wpa);
! 	wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_DISCONNECTED "- Disconnect event - "
! 		"remove keys");
  	if (wpa_supplicant_dynamic_keys(wpa_s)) {
  		wpa_s->keys_cleared = 0;
  		wpa_clear_keys(wpa_s, wpa_s->bssid);
--- 718,724 ----
  		bssid = wpa_s->pending_bssid;
  	wpa_blacklist_add(wpa_s, bssid);
  	wpa_sm_notify_disassoc(wpa_s->wpa);
! 	//wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_DISCONNECTED "- Disconnect event - remove keys");
  	if (wpa_supplicant_dynamic_keys(wpa_s)) {
  		wpa_s->keys_cleared = 0;
  		wpa_clear_keys(wpa_s, wpa_s->bssid);
***************
*** 825,830 ****
--- 836,846 ----
  		wpa_supplicant_event_stkstart(wpa_s, data);
  		break;
  #endif /* CONFIG_PEERKEY */
+ #ifdef CONFIG_EAP_WSC
+ 	case EVENT_WSC_PBC_OVERLAP:
+ 		wsc_supplicant_event_overlap();
+ 		break;
+ #endif /* CONFIG_EAP_WSC */
  	default:
  		wpa_printf(MSG_INFO, "Unknown event %d", event);
  		break;
diff -BNcr wpa_supplicant-0.5.7/examples/ieee8021x.conf wpa_view/wpa_suppl/examples/ieee8021x.conf
*** wpa_supplicant-0.5.7/examples/ieee8021x.conf	Thu Oct 27 05:15:58 2005
--- wpa_view/wpa_suppl/examples/ieee8021x.conf	Thu Jan  1 02:00:00 1970
***************
*** 1,13 ****
- # IEEE 802.1X with dynamic WEP keys using EAP-PEAP/MSCHAPv2
- 
- ctrl_interface=/var/run/wpa_supplicant
- 
- network={
- 	ssid="example 802.1x network"
- 	key_mgmt=IEEE8021X
- 	eap=PEAP
- 	phase2="auth=MSCHAPV2"
- 	identity="user name"
- 	password="password"
- 	ca_cert="/etc/cert/ca.pem"
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/examples/plaintext.conf wpa_view/wpa_suppl/examples/plaintext.conf
*** wpa_supplicant-0.5.7/examples/plaintext.conf	Thu Oct 27 05:15:58 2005
--- wpa_view/wpa_suppl/examples/plaintext.conf	Thu Jan  1 02:00:00 1970
***************
*** 1,8 ****
- # Plaintext (no encryption) network
- 
- ctrl_interface=/var/run/wpa_supplicant
- 
- network={
- 	ssid="example open network"
- 	key_mgmt=NONE
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/examples/wep.conf wpa_view/wpa_suppl/examples/wep.conf
*** wpa_supplicant-0.5.7/examples/wep.conf	Thu Oct 27 05:15:58 2005
--- wpa_view/wpa_suppl/examples/wep.conf	Thu Jan  1 02:00:00 1970
***************
*** 1,11 ****
- # Static WEP keys
- 
- ctrl_interface=/var/run/wpa_supplicant
- 
- network={
- 	ssid="example wep network"
- 	key_mgmt=NONE
- 	wep_key0="abcde"
- 	wep_key1=0102030405
- 	wep_tx_keyidx=0
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/examples/wpa-psk-tkip.conf wpa_view/wpa_suppl/examples/wpa-psk-tkip.conf
*** wpa_supplicant-0.5.7/examples/wpa-psk-tkip.conf	Thu Oct 27 05:15:58 2005
--- wpa_view/wpa_suppl/examples/wpa-psk-tkip.conf	Thu Jan  1 02:00:00 1970
***************
*** 1,12 ****
- # WPA-PSK/TKIP
- 
- ctrl_interface=/var/run/wpa_supplicant
- 
- network={
- 	ssid="example wpa-psk network"
- 	key_mgmt=WPA-PSK
- 	proto=WPA
- 	pairwise=TKIP
- 	group=TKIP
- 	psk="secret passphrase"
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/examples/wpa2-eap-ccmp.conf wpa_view/wpa_suppl/examples/wpa2-eap-ccmp.conf
*** wpa_supplicant-0.5.7/examples/wpa2-eap-ccmp.conf	Thu Oct 27 05:15:58 2005
--- wpa_view/wpa_suppl/examples/wpa2-eap-ccmp.conf	Thu Jan  1 02:00:00 1970
***************
*** 1,15 ****
- # WPA2-EAP/CCMP using EAP-TLS
- 
- ctrl_interface=/var/run/wpa_supplicant
- 
- network={
- 	ssid="example wpa2-eap network"
- 	key_mgmt=WPA-EAP
- 	proto=WPA2
- 	pairwise=CCMP
- 	group=CCMP
- 	eap=TLS
- 	ca_cert="/etc/cert/ca.pem"
- 	private_key="/etc/cert/user.p12"
- 	private_key_passwd="PKCS#12 passhrase"
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/nmake.mak wpa_view/wpa_suppl/nmake.mak
*** wpa_supplicant-0.5.7/nmake.mak	Sun Aug  6 22:01:46 2006
--- wpa_view/wpa_suppl/nmake.mak	Thu Jan  1 02:00:00 1970
***************
*** 1,188 ****
- # Makefile for Microsoft nmake to build wpa_supplicant
- 
- # This can be run in Visual Studio 2005 Command Prompt
- 
- # Note: Make sure that cl.exe is configured to include Platform SDK
- # include and lib directories (vsvars32.bat)
- 
- all: wpa_supplicant.exe wpa_cli.exe wpa_passphrase.exe wpasvc.exe win_if_list.exe
- 
- # Root directory for WinPcap developer's pack
- # (http://www.winpcap.org/install/bin/WpdPack_3_1.zip)
- WINPCAPDIR=C:\dev\WpdPack
- 
- # Root directory for OpenSSL
- # (http://www.openssl.org/source/openssl-0.9.8a.tar.gz)
- # Build and installed following instructions in INSTALL.W32
- # Note: If EAP-FAST is included in the build, OpenSSL needs to be patched to
- # support it (openssl-tls-extensions.patch)
- # Alternatively, see README-Windows.txt for information about binary
- # installation package for OpenSSL.
- OPENSSLDIR=C:\dev\openssl
- 
- CC = cl
- OBJDIR = objs
- 
- CFLAGS = /DCONFIG_NATIVE_WINDOWS
- CFLAGS = $(CFLAGS) /DCONFIG_NDIS_EVENTS_INTEGRATED
- CFLAGS = $(CFLAGS) /DCONFIG_ANSI_C_EXTRA
- CFLAGS = $(CFLAGS) /DCONFIG_WINPCAP
- CFLAGS = $(CFLAGS) /DIEEE8021X_EAPOL
- CFLAGS = $(CFLAGS) /DEAP_TLS_FUNCS
- CFLAGS = $(CFLAGS) /DPKCS12_FUNCS
- CFLAGS = $(CFLAGS) /DEAP_MD5
- CFLAGS = $(CFLAGS) /DEAP_TLS
- CFLAGS = $(CFLAGS) /DEAP_MSCHAPv2
- CFLAGS = $(CFLAGS) /DEAP_PEAP
- CFLAGS = $(CFLAGS) /DEAP_TTLS
- CFLAGS = $(CFLAGS) /DEAP_GTC
- CFLAGS = $(CFLAGS) /DEAP_OTP
- CFLAGS = $(CFLAGS) /DEAP_SIM
- CFLAGS = $(CFLAGS) /DEAP_LEAP
- CFLAGS = $(CFLAGS) /DEAP_PSK
- CFLAGS = $(CFLAGS) /DEAP_AKA
- #CFLAGS = $(CFLAGS) /DEAP_FAST
- CFLAGS = $(CFLAGS) /DEAP_PAX
- CFLAGS = $(CFLAGS) /DPCSC_FUNCS
- CFLAGS = $(CFLAGS) /DCONFIG_CTRL_IFACE
- CFLAGS = $(CFLAGS) /DCONFIG_CTRL_IFACE_NAMED_PIPE
- CFLAGS = $(CFLAGS) /DCONFIG_DRIVER_NDIS
- CFLAGS = $(CFLAGS) /I..\hostapd /I.
- CFLAGS = $(CFLAGS) /DWIN32
- CFLAGS = $(CFLAGS) /Fo$(OBJDIR)\\ /c
- CFLAGS = $(CFLAGS) /W3
- 
- #CFLAGS = $(CFLAGS) /WX
- 
- # VS 2005 complains about lot of deprecated string functions; let's ignore them
- # at least for now since snprintf and strncpy can be used in a safe way
- CFLAGS = $(CFLAGS) /D_CRT_SECURE_NO_DEPRECATE
- 
- OBJS = \
- 	$(OBJDIR)\os_win32.obj \
- 	$(OBJDIR)\eloop_win.obj \
- 	$(OBJDIR)\sha1.obj \
- 	$(OBJDIR)\md5.obj \
- 	$(OBJDIR)\rc4.obj \
- 	$(OBJDIR)\aes_wrap.obj \
- 	$(OBJDIR)\common.obj \
- 	$(OBJDIR)\wpa_supplicant.obj \
- 	$(OBJDIR)\wpa.obj \
- 	$(OBJDIR)\preauth.obj \
- 	$(OBJDIR)\pmksa_cache.obj \
- 	$(OBJDIR)\eapol_sm.obj \
- 	$(OBJDIR)\eap.obj \
- 	$(OBJDIR)\eap_methods.obj \
- 	$(OBJDIR)\eap_tlv.obj \
- 	$(OBJDIR)\eap_md5.obj \
- 	$(OBJDIR)\eap_tls.obj \
- 	$(OBJDIR)\eap_tls_common.obj \
- 	$(OBJDIR)\eap_mschapv2.obj \
- 	$(OBJDIR)\eap_peap.obj \
- 	$(OBJDIR)\eap_ttls.obj \
- 	$(OBJDIR)\eap_gtc.obj \
- 	$(OBJDIR)\eap_otp.obj \
- 	$(OBJDIR)\eap_leap.obj \
- 	$(OBJDIR)\eap_sim.obj \
- 	$(OBJDIR)\eap_sim_common.obj \
- 	$(OBJDIR)\eap_aka.obj \
- 	$(OBJDIR)\eap_pax.obj \
- 	$(OBJDIR)\eap_pax_common.obj \
- 	$(OBJDIR)\eap_psk.obj \
- 	$(OBJDIR)\eap_psk_common.obj \
- 	$(OBJDIR)\ctrl_iface.obj \
- 	$(OBJDIR)\ctrl_iface_named_pipe.obj \
- 	$(OBJDIR)\driver_ndis.obj \
- 	$(OBJDIR)\driver_ndis_.obj \
- 	$(OBJDIR)\events.obj \
- 	$(OBJDIR)\config.obj \
- 	$(OBJDIR)\l2_packet_winpcap.obj \
- 	$(OBJDIR)\tls_openssl.obj \
- 	$(OBJDIR)\ms_funcs.obj \
- 	$(OBJDIR)\crypto.obj \
- 	$(OBJDIR)\pcsc_funcs.obj \
- 	$(OBJDIR)\ndis_events.obj
- 
- # OBJS = $(OBJS) $(OBJDIR)\eap_fast.obj
- 
- OBJS_t = $(OBJS) \
- 	$(OBJDIR)\eapol_test.obj \
- 	$(OBJDIR)\radius.obj \
- 	$(OBJDIR)\radius_client.obj \
- 	$(OBJDIR)\config_file.obj $(OBJDIR)\base64.obj
- 
- OBJS_t2 = $(OBJS) \
- 	$(OBJDIR)\preauth_test.obj \
- 	$(OBJDIR)\config_file.obj $(OBJDIR)\base64.obj
- 
- OBJS2 = $(OBJDIR)\drivers.obj \
- 	$(OBJDIR)\config_file.obj $(OBJDIR)\base64.obj \
- 	$(OBJS2) $(OBJDIR)\main.obj
- 
- OBJS3 = $(OBJDIR)\drivers.obj \
- 	$(OBJDIR)\config_winreg.obj \
- 	$(OBJS3) $(OBJDIR)\main_winsvc.obj
- 
- OBJS_c = \
- 	$(OBJDIR)\os_win32.obj \
- 	$(OBJDIR)\wpa_cli.obj \
- 	$(OBJDIR)\wpa_ctrl.obj \
- 	$(OBJDIR)\common.obj
- 
- OBJS_p = \
- 	$(OBJDIR)\os_win32.obj \
- 	$(OBJDIR)\common.obj \
- 	$(OBJDIR)\sha1.obj \
- 	$(OBJDIR)\md5.obj \
- 	$(OBJDIR)\crypto.obj \
- 	$(OBJDIR)\wpa_passphrase.obj
- 
- LIBS = wbemuuid.lib libcmt.lib kernel32.lib uuid.lib ole32.lib oleaut32.lib \
- 	ws2_32.lib Advapi32.lib Crypt32.lib Winscard.lib \
- 	Packet.lib wpcap.lib \
- 	libeay32.lib ssleay32.lib
- # If using Win32 OpenSSL binary installation from Shining Light Productions,
- # replace the last line with this for dynamic libraries
- #	libeay32MT.lib ssleay32MT.lib
- # and this for static libraries
- #	libeay32MT.lib ssleay32MT.lib Gdi32.lib User32.lib
- 
- CFLAGS = $(CFLAGS) /I"$(WINPCAPDIR)/Include" /I"$(OPENSSLDIR)\include"
- LFLAGS = /libpath:"$(WINPCAPDIR)\Lib" /libpath:"$(OPENSSLDIR)\lib"
- 
- wpa_supplicant.exe: $(OBJDIR) $(OBJS) $(OBJS2)
- 	link.exe /out:wpa_supplicant.exe $(LFLAGS) $(OBJS) $(OBJS2) $(LIBS)
- 
- wpasvc.exe: $(OBJDIR) $(OBJS) $(OBJS3)
- 	link.exe /out:wpasvc.exe $(LFLAGS) $(OBJS) $(OBJS3) $(LIBS)
- 
- wpa_cli.exe: $(OBJDIR) $(OBJS_c)
- 	link.exe /out:wpa_cli.exe $(LFLAGS) $(OBJS_c) $(LIBS)
- 
- wpa_passphrase.exe: $(OBJDIR) $(OBJS_p)
- 	link.exe /out:wpa_passphrase.exe $(LFLAGS) $(OBJS_p) $(LIBS)
- 
- eapol_test.exe: $(OBJDIR) $(OBJS_t)
- 	link.exe /out:eapol_test.exe $(LFLAGS) $(OBJS_t) $(LIBS)
- 
- preauth_test.exe: $(OBJDIR) $(OBJS_t2)
- 	link.exe /out:preauth_test.exe $(LFLAGS) $(OBJS_t2) $(LIBS)
- 
- win_if_list.exe: $(OBJDIR) $(OBJDIR)\win_if_list.obj
- 	link.exe /out:win_if_list.exe $(LFLAGS) $(OBJDIR)\win_if_list.obj $(LIBS)
- 
- 
- {..\hostapd}.c{$(OBJDIR)}.obj::
- 	$(CC) $(CFLAGS) $<
- 
- {.\}.c{$(OBJDIR)}.obj::
- 	$(CC) $(CFLAGS) $<
- 
- {.\}.cpp{$(OBJDIR)}.obj::
- 	$(CC) $(CFLAGS) $<
- 
- $(OBJDIR):
- 	if not exist "$(OBJDIR)" mkdir "$(OBJDIR)"
- 
- clean:
- 	erase $(OBJDIR)\*.obj wpa_supplicant.exe
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/openssl-0.9.8d-tls-extensions.patch wpa_view/wpa_suppl/openssl-0.9.8d-tls-extensions.patch
*** wpa_supplicant-0.5.7/openssl-0.9.8d-tls-extensions.patch	Mon Dec 11 05:07:49 2006
--- wpa_view/wpa_suppl/openssl-0.9.8d-tls-extensions.patch	Thu Jan  1 02:00:00 1970
***************
*** 1,429 ****
- This patch is adding support for TLS hello extensions and externally
- generated pre-shared key material to OpenSSL 0.9.8d. This is
- based on the patch from Alexey Kobozev <akobozev@cisco.com>
- (sent to openssl-dev mailing list on Tue, 07 Jun 2005 15:40:58 +0300).
- 
- 
- 
- diff -uprN openssl-0.9.8d.orig/include/openssl/ssl.h openssl-0.9.8d/include/openssl/ssl.h
- --- openssl-0.9.8d.orig/include/openssl/ssl.h	2006-06-14 06:52:49.000000000 -0700
- +++ openssl-0.9.8d/include/openssl/ssl.h	2006-12-10 08:20:02.000000000 -0800
- @@ -345,6 +345,7 @@ extern "C" {
-   * 'struct ssl_st *' function parameters used to prototype callbacks
-   * in SSL_CTX. */
-  typedef struct ssl_st *ssl_crock_st;
- +typedef struct tls_extension_st TLS_EXTENSION;
-  
-  /* used to hold info on the particular ciphers used */
-  typedef struct ssl_cipher_st
- @@ -366,6 +367,8 @@ DECLARE_STACK_OF(SSL_CIPHER)
-  typedef struct ssl_st SSL;
-  typedef struct ssl_ctx_st SSL_CTX;
-  
- +typedef int (*tls_session_secret_cb_fn)(SSL *s, void *secret, int *secret_len, STACK_OF(SSL_CIPHER) *peer_ciphers, SSL_CIPHER **cipher, void *arg);
- +
-  /* Used to hold functions for SSLv2 or SSLv3/TLSv1 functions */
-  typedef struct ssl_method_st
-  	{
- @@ -973,6 +976,15 @@ struct ssl_st
-  	int first_packet;
-  	int client_version;	/* what was passed, used for
-  				 * SSLv3/TLS rollback check */
- +
- +	/* TLS externsions */
- +	TLS_EXTENSION *tls_extension;
- +	int (*tls_extension_cb)(SSL *s, TLS_EXTENSION *tls_ext, void *arg);
- +	void *tls_extension_cb_arg;
- +
- +	/* TLS pre-shared secret session resumption */
- +	tls_session_secret_cb_fn tls_session_secret_cb;
- +	void *tls_session_secret_cb_arg;
-  	};
-  
-  #ifdef __cplusplus
- @@ -1538,6 +1550,13 @@ void *SSL_COMP_get_compression_methods(v
-  int SSL_COMP_add_compression_method(int id,void *cm);
-  #endif
-  
- +/* TLS extensions functions */
- +int SSL_set_hello_extension(SSL *s, int ext_type, void *ext_data, int ext_len);
- +int SSL_set_hello_extension_cb(SSL *s, int (*cb)(SSL *, TLS_EXTENSION *, void *), void *arg);
- +
- +/* Pre-shared secret session resumption functions */
- +int SSL_set_session_secret_cb(SSL *s, tls_session_secret_cb_fn tls_session_secret_cb, void *arg);
- +
-  /* BEGIN ERROR CODES */
-  /* The following lines are auto generated by the script mkerr.pl. Any changes
-   * made after this point may be overwritten when the script is next run.
- @@ -1719,6 +1738,7 @@ void ERR_load_SSL_strings(void);
-  #define SSL_F_TLS1_ENC					 210
-  #define SSL_F_TLS1_SETUP_KEY_BLOCK			 211
-  #define SSL_F_WRITE_PENDING				 212
- +#define SSL_F_SSL_SET_HELLO_EXTENSION	 213
-  
-  /* Reason codes. */
-  #define SSL_R_APP_DATA_IN_HANDSHAKE			 100
- diff -uprN openssl-0.9.8d.orig/include/openssl/tls1.h openssl-0.9.8d/include/openssl/tls1.h
- --- openssl-0.9.8d.orig/include/openssl/tls1.h	2006-06-14 10:52:01.000000000 -0700
- +++ openssl-0.9.8d/include/openssl/tls1.h	2006-12-10 08:20:02.000000000 -0800
- @@ -296,6 +296,14 @@ extern "C" {
-  #define TLS_MD_MASTER_SECRET_CONST    "\x6d\x61\x73\x74\x65\x72\x20\x73\x65\x63\x72\x65\x74"  /*master secret*/
-  #endif
-  
- +/* TLS extension struct */
- +struct tls_extension_st
- +{
- +	unsigned short type;
- +	unsigned short length;
- +	void *data;
- +};
- +
-  #ifdef  __cplusplus
-  }
-  #endif
- diff -uprN openssl-0.9.8d.orig/ssl/Makefile openssl-0.9.8d/ssl/Makefile
- --- openssl-0.9.8d.orig/ssl/Makefile	2006-02-03 17:49:35.000000000 -0800
- +++ openssl-0.9.8d/ssl/Makefile	2006-12-10 08:20:02.000000000 -0800
- @@ -24,7 +24,7 @@ LIBSRC=	\
-  	s2_meth.c   s2_srvr.c s2_clnt.c  s2_lib.c  s2_enc.c s2_pkt.c \
-  	s3_meth.c   s3_srvr.c s3_clnt.c  s3_lib.c  s3_enc.c s3_pkt.c s3_both.c \
-  	s23_meth.c s23_srvr.c s23_clnt.c s23_lib.c          s23_pkt.c \
- -	t1_meth.c   t1_srvr.c t1_clnt.c  t1_lib.c  t1_enc.c \
- +	t1_meth.c   t1_srvr.c t1_clnt.c  t1_lib.c  t1_enc.c                    t1_ext.c \
-  	d1_meth.c   d1_srvr.c d1_clnt.c  d1_lib.c  d1_pkt.c \
-  	d1_both.c d1_enc.c \
-  	ssl_lib.c ssl_err2.c ssl_cert.c ssl_sess.c \
- @@ -35,7 +35,7 @@ LIBOBJ= \
-  	s2_meth.o  s2_srvr.o  s2_clnt.o  s2_lib.o  s2_enc.o s2_pkt.o \
-  	s3_meth.o  s3_srvr.o  s3_clnt.o  s3_lib.o  s3_enc.o s3_pkt.o s3_both.o \
-  	s23_meth.o s23_srvr.o s23_clnt.o s23_lib.o          s23_pkt.o \
- -	t1_meth.o   t1_srvr.o t1_clnt.o  t1_lib.o  t1_enc.o \
- +	t1_meth.o   t1_srvr.o t1_clnt.o  t1_lib.o  t1_enc.o                    t1_ext.o \
-  	d1_meth.o   d1_srvr.o d1_clnt.o  d1_lib.o  d1_pkt.o \
-  	d1_both.o d1_enc.o \
-  	ssl_lib.o ssl_err2.o ssl_cert.o ssl_sess.o \
- @@ -968,3 +968,4 @@ t1_srvr.o: ../include/openssl/ssl23.h ..
-  t1_srvr.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
-  t1_srvr.o: ../include/openssl/tls1.h ../include/openssl/x509.h
-  t1_srvr.o: ../include/openssl/x509_vfy.h ssl_locl.h t1_srvr.c
- +t1_ext.o: t1_ext.c ssl_locl.h
- diff -uprN openssl-0.9.8d.orig/ssl/s3_clnt.c openssl-0.9.8d/ssl/s3_clnt.c
- --- openssl-0.9.8d.orig/ssl/s3_clnt.c	2005-12-12 23:41:46.000000000 -0800
- +++ openssl-0.9.8d/ssl/s3_clnt.c	2006-12-10 08:20:02.000000000 -0800
- @@ -601,6 +601,20 @@ int ssl3_client_hello(SSL *s)
-  #endif
-  		*(p++)=0; /* Add the NULL method */
-  		
- +		/* send client hello extensions if any */
- +		if (s->version >= TLS1_VERSION && s->tls_extension)
- +		{
- +			// set the total extensions length
- +			s2n(s->tls_extension->length + 4, p);
- +
- +			// put the extensions with type and length
- +			s2n(s->tls_extension->type, p);
- +			s2n(s->tls_extension->length, p);
- +			
- +			memcpy(p, s->tls_extension->data, s->tls_extension->length);
- +			p+=s->tls_extension->length;
- +		}
- +
-  		l=(p-d);
-  		d=buf;
-  		*(d++)=SSL3_MT_CLIENT_HELLO;
- @@ -623,7 +637,7 @@ int ssl3_get_server_hello(SSL *s)
-  	STACK_OF(SSL_CIPHER) *sk;
-  	SSL_CIPHER *c;
-  	unsigned char *p,*d;
- -	int i,al,ok;
- +	int i,al,ok,pre_shared;
-  	unsigned int j;
-  	long n;
-  #ifndef OPENSSL_NO_COMP
- @@ -690,7 +704,24 @@ int ssl3_get_server_hello(SSL *s)
-  		goto f_err;
-  		}
-  
- -	if (j != 0 && j == s->session->session_id_length
- +	/* check if we want to resume the session based on external pre-shared secret */
- +	pre_shared = 0;
- +	if (s->version >= TLS1_VERSION && s->tls_session_secret_cb)
- +	{
- +		SSL_CIPHER *pref_cipher=NULL;
- +		s->session->master_key_length=sizeof(s->session->master_key);
- +		if (s->tls_session_secret_cb(s, s->session->master_key, &s->session->master_key_length,
- +			NULL, &pref_cipher, s->tls_session_secret_cb_arg))
- +		{
- +			s->hit=1;
- +			s->session->cipher=pref_cipher ? pref_cipher : ssl_get_cipher_by_char(s,p+j);
- +			s->session->session_id_length = j;
- +			memcpy(s->session->session_id, p, j);
- +			pre_shared = 1;
- +		}
- +	}
- +
- +	if ((pre_shared || j != 0) && j == s->session->session_id_length
-  	    && memcmp(p,s->session->session_id,j) == 0)
-  	    {
-  	    if(s->sid_ctx_length != s->session->sid_ctx_length
- diff -uprN openssl-0.9.8d.orig/ssl/s3_srvr.c openssl-0.9.8d/ssl/s3_srvr.c
- --- openssl-0.9.8d.orig/ssl/s3_srvr.c	2006-09-28 04:29:03.000000000 -0700
- +++ openssl-0.9.8d/ssl/s3_srvr.c	2006-12-10 08:20:02.000000000 -0800
- @@ -943,6 +943,75 @@ int ssl3_get_client_hello(SSL *s)
-  		}
-  #endif
-  
- +	/* Check for TLS client hello extension here */
- +	if (p < (d+n) && s->version >= TLS1_VERSION)
- +	{
- +		if (s->tls_extension_cb)
- +		{
- +			TLS_EXTENSION tls_ext;
- +			unsigned short ext_total_len;
- +			
- +			n2s(p, ext_total_len);
- +			n2s(p, tls_ext.type);
- +			n2s(p, tls_ext.length);
- +
- +			// sanity check in TLS extension len
- +			if (tls_ext.length > (d+n) - p)
- +			{
- +				// just cut the lenth to packet border
- +				tls_ext.length = (d+n) - p;
- +			}
- +
- +			tls_ext.data = p;
- +
- +			// returns an alert code or 0
- +			al = s->tls_extension_cb(s, &tls_ext, s->tls_extension_cb_arg);
- +			if (al != 0)
- +			{
- +				SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_PEER_ERROR);
- +				goto f_err;
- +			}
- +		}
- +	}
- +
- +	/* Check if we want to use external pre-shared secret for this handshake */
- +	/* for not reused session only */
- +	if (!s->hit && s->version >= TLS1_VERSION && s->tls_session_secret_cb)
- +	{
- +		SSL_CIPHER *pref_cipher=NULL;
- +
- +		s->session->master_key_length=sizeof(s->session->master_key);
- +		if(s->tls_session_secret_cb(s, s->session->master_key, &s->session->master_key_length, 
- +			ciphers, &pref_cipher, s->tls_session_secret_cb_arg))
- +		{
- +			s->hit=1;
- +			s->session->ciphers=ciphers;
- +			s->session->verify_result=X509_V_OK;
- +			
- +			ciphers=NULL;
- +			
- +			/* check if some cipher was preferred by call back */
- +			pref_cipher=pref_cipher ? pref_cipher : ssl3_choose_cipher(s, s->session->ciphers, SSL_get_ciphers(s));
- +			if (pref_cipher == NULL)
- +				{
- +				al=SSL_AD_HANDSHAKE_FAILURE;
- +				SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_SHARED_CIPHER);
- +				goto f_err;
- +				}
- +
- +			s->session->cipher=pref_cipher;
- +
- +			if (s->cipher_list)
- +				sk_SSL_CIPHER_free(s->cipher_list);
- +
- +			if (s->cipher_list_by_id)
- +				sk_SSL_CIPHER_free(s->cipher_list_by_id);
- +
- +			s->cipher_list = sk_SSL_CIPHER_dup(s->session->ciphers);
- +			s->cipher_list_by_id = sk_SSL_CIPHER_dup(s->session->ciphers);
- +		}
- +	}
- +
-  	/* Given s->session->ciphers and SSL_get_ciphers, we must
-  	 * pick a cipher */
-  
- diff -uprN openssl-0.9.8d.orig/ssl/ssl.h openssl-0.9.8d/ssl/ssl.h
- --- openssl-0.9.8d.orig/ssl/ssl.h	2006-06-14 06:52:49.000000000 -0700
- +++ openssl-0.9.8d/ssl/ssl.h	2006-12-10 08:20:02.000000000 -0800
- @@ -345,6 +345,7 @@ extern "C" {
-   * 'struct ssl_st *' function parameters used to prototype callbacks
-   * in SSL_CTX. */
-  typedef struct ssl_st *ssl_crock_st;
- +typedef struct tls_extension_st TLS_EXTENSION;
-  
-  /* used to hold info on the particular ciphers used */
-  typedef struct ssl_cipher_st
- @@ -366,6 +367,8 @@ DECLARE_STACK_OF(SSL_CIPHER)
-  typedef struct ssl_st SSL;
-  typedef struct ssl_ctx_st SSL_CTX;
-  
- +typedef int (*tls_session_secret_cb_fn)(SSL *s, void *secret, int *secret_len, STACK_OF(SSL_CIPHER) *peer_ciphers, SSL_CIPHER **cipher, void *arg);
- +
-  /* Used to hold functions for SSLv2 or SSLv3/TLSv1 functions */
-  typedef struct ssl_method_st
-  	{
- @@ -973,6 +976,15 @@ struct ssl_st
-  	int first_packet;
-  	int client_version;	/* what was passed, used for
-  				 * SSLv3/TLS rollback check */
- +
- +	/* TLS externsions */
- +	TLS_EXTENSION *tls_extension;
- +	int (*tls_extension_cb)(SSL *s, TLS_EXTENSION *tls_ext, void *arg);
- +	void *tls_extension_cb_arg;
- +
- +	/* TLS pre-shared secret session resumption */
- +	tls_session_secret_cb_fn tls_session_secret_cb;
- +	void *tls_session_secret_cb_arg;
-  	};
-  
-  #ifdef __cplusplus
- @@ -1538,6 +1550,13 @@ void *SSL_COMP_get_compression_methods(v
-  int SSL_COMP_add_compression_method(int id,void *cm);
-  #endif
-  
- +/* TLS extensions functions */
- +int SSL_set_hello_extension(SSL *s, int ext_type, void *ext_data, int ext_len);
- +int SSL_set_hello_extension_cb(SSL *s, int (*cb)(SSL *, TLS_EXTENSION *, void *), void *arg);
- +
- +/* Pre-shared secret session resumption functions */
- +int SSL_set_session_secret_cb(SSL *s, tls_session_secret_cb_fn tls_session_secret_cb, void *arg);
- +
-  /* BEGIN ERROR CODES */
-  /* The following lines are auto generated by the script mkerr.pl. Any changes
-   * made after this point may be overwritten when the script is next run.
- @@ -1719,6 +1738,7 @@ void ERR_load_SSL_strings(void);
-  #define SSL_F_TLS1_ENC					 210
-  #define SSL_F_TLS1_SETUP_KEY_BLOCK			 211
-  #define SSL_F_WRITE_PENDING				 212
- +#define SSL_F_SSL_SET_HELLO_EXTENSION	 213
-  
-  /* Reason codes. */
-  #define SSL_R_APP_DATA_IN_HANDSHAKE			 100
- diff -uprN openssl-0.9.8d.orig/ssl/ssl_err.c openssl-0.9.8d/ssl/ssl_err.c
- --- openssl-0.9.8d.orig/ssl/ssl_err.c	2006-01-08 13:52:46.000000000 -0800
- +++ openssl-0.9.8d/ssl/ssl_err.c	2006-12-10 08:20:02.000000000 -0800
- @@ -242,6 +242,7 @@ static ERR_STRING_DATA SSL_str_functs[]=
-  {ERR_FUNC(SSL_F_TLS1_ENC),	"TLS1_ENC"},
-  {ERR_FUNC(SSL_F_TLS1_SETUP_KEY_BLOCK),	"TLS1_SETUP_KEY_BLOCK"},
-  {ERR_FUNC(SSL_F_WRITE_PENDING),	"WRITE_PENDING"},
- +{ERR_FUNC(SSL_F_SSL_SET_HELLO_EXTENSION), "SSL_set_hello_extension"},
-  {0,NULL}
-  	};
-  
- diff -uprN openssl-0.9.8d.orig/ssl/ssl_sess.c openssl-0.9.8d/ssl/ssl_sess.c
- --- openssl-0.9.8d.orig/ssl/ssl_sess.c	2005-12-30 15:51:57.000000000 -0800
- +++ openssl-0.9.8d/ssl/ssl_sess.c	2006-12-10 08:20:02.000000000 -0800
- @@ -656,6 +656,15 @@ long SSL_CTX_get_timeout(const SSL_CTX *
-  	return(s->session_timeout);
-  	}
-  
- +int SSL_set_session_secret_cb(SSL *s, int (*tls_session_secret_cb)(SSL *s, void *secret, int *secret_len, 
- +	STACK_OF(SSL_CIPHER) *peer_ciphers, SSL_CIPHER **cipher, void *arg), void *arg)
- +{
- +	if (s == NULL) return(0);
- +	s->tls_session_secret_cb = tls_session_secret_cb;
- +	s->tls_session_secret_cb_arg = arg;
- +	return(1);
- +}
- +
-  typedef struct timeout_param_st
-  	{
-  	SSL_CTX *ctx;
- diff -uprN openssl-0.9.8d.orig/ssl/t1_ext.c openssl-0.9.8d/ssl/t1_ext.c
- --- openssl-0.9.8d.orig/ssl/t1_ext.c	1969-12-31 16:00:00.000000000 -0800
- +++ openssl-0.9.8d/ssl/t1_ext.c	2006-12-10 08:20:02.000000000 -0800
- @@ -0,0 +1,48 @@
- +
- +#include <stdio.h>
- +#include "ssl_locl.h"
- +
- +
- +int SSL_set_hello_extension(SSL *s, int ext_type, void *ext_data, int ext_len)
- +{
- +	if(s->version >= TLS1_VERSION)
- +	{
- +		if(s->tls_extension)
- +		{
- +			OPENSSL_free(s->tls_extension);
- +			s->tls_extension = NULL;
- +		}
- +
- +		if(ext_data)
- +		{
- +			s->tls_extension = OPENSSL_malloc(sizeof(TLS_EXTENSION) + ext_len);
- +			if(!s->tls_extension)
- +			{
- +				SSLerr(SSL_F_SSL_SET_HELLO_EXTENSION, ERR_R_MALLOC_FAILURE);
- +				return 0;
- +			}
- +
- +			s->tls_extension->type = ext_type;
- +			s->tls_extension->length = ext_len;
- +			s->tls_extension->data = s->tls_extension + 1;
- +			memcpy(s->tls_extension->data, ext_data, ext_len);
- +		}
- +
- +		return 1;
- +	}
- +
- +	return 0;
- +}
- +
- +int SSL_set_hello_extension_cb(SSL *s, int (*cb)(SSL *, TLS_EXTENSION *, void *), void *arg)
- +{
- +	if(s->version >= TLS1_VERSION)
- +	{
- +		s->tls_extension_cb = cb;
- +		s->tls_extension_cb_arg = arg;
- +
- +		return 1;
- +	}
- +
- +	return 0;
- +}
- diff -uprN openssl-0.9.8d.orig/ssl/t1_lib.c openssl-0.9.8d/ssl/t1_lib.c
- --- openssl-0.9.8d.orig/ssl/t1_lib.c	2005-08-05 16:52:07.000000000 -0700
- +++ openssl-0.9.8d/ssl/t1_lib.c	2006-12-10 08:20:02.000000000 -0800
- @@ -97,6 +97,10 @@ int tls1_new(SSL *s)
-  
-  void tls1_free(SSL *s)
-  	{
- +	if(s->tls_extension)
- +	{
- +		OPENSSL_free(s->tls_extension);
- +	}
-  	ssl3_free(s);
-  	}
-  
- diff -uprN openssl-0.9.8d.orig/ssl/tls1.h openssl-0.9.8d/ssl/tls1.h
- --- openssl-0.9.8d.orig/ssl/tls1.h	2006-06-14 10:52:01.000000000 -0700
- +++ openssl-0.9.8d/ssl/tls1.h	2006-12-10 08:20:02.000000000 -0800
- @@ -296,6 +296,14 @@ extern "C" {
-  #define TLS_MD_MASTER_SECRET_CONST    "\x6d\x61\x73\x74\x65\x72\x20\x73\x65\x63\x72\x65\x74"  /*master secret*/
-  #endif
-  
- +/* TLS extension struct */
- +struct tls_extension_st
- +{
- +	unsigned short type;
- +	unsigned short length;
- +	void *data;
- +};
- +
-  #ifdef  __cplusplus
-  }
-  #endif
- diff -uprN openssl-0.9.8d.orig/util/ssleay.num openssl-0.9.8d/util/ssleay.num
- --- openssl-0.9.8d.orig/util/ssleay.num	2005-05-08 17:22:02.000000000 -0700
- +++ openssl-0.9.8d/util/ssleay.num	2006-12-10 08:20:02.000000000 -0800
- @@ -226,3 +226,6 @@ DTLSv1_server_method                    
-  SSL_COMP_get_compression_methods        276	EXIST:!VMS:FUNCTION:COMP
-  SSL_COMP_get_compress_methods           276	EXIST:VMS:FUNCTION:COMP
-  SSL_SESSION_get_id                      277	EXIST::FUNCTION:
- +SSL_set_hello_extension			278	EXIST::FUNCTION:
- +SSL_set_hello_extension_cb		279	EXIST::FUNCTION:
- +SSL_set_session_secret_cb		280	EXIST::FUNCTION:
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/openssl-tls-extensions.patch wpa_view/wpa_suppl/openssl-tls-extensions.patch
*** wpa_supplicant-0.5.7/openssl-tls-extensions.patch	Wed Jul 20 06:30:09 2005
--- wpa_view/wpa_suppl/openssl-tls-extensions.patch	Thu Jan  1 02:00:00 1970
***************
*** 1,429 ****
- This patch is adding support for TLS hello extensions and externally
- generated pre-shared key material to OpenSSL 0.9.8. This is
- based on the patch from Alexey Kobozev <akobozev@cisco.com>
- (sent to openssl-dev mailing list on Tue, 07 Jun 2005 15:40:58 +0300).
- 
- 
- 
- diff -uprN openssl-0.9.8.orig/include/openssl/ssl.h openssl-0.9.8/include/openssl/ssl.h
- --- openssl-0.9.8.orig/include/openssl/ssl.h	2005-06-10 12:51:16.000000000 -0700
- +++ openssl-0.9.8/include/openssl/ssl.h	2005-07-19 20:02:15.000000000 -0700
- @@ -340,6 +340,7 @@ extern "C" {
-   * 'struct ssl_st *' function parameters used to prototype callbacks
-   * in SSL_CTX. */
-  typedef struct ssl_st *ssl_crock_st;
- +typedef struct tls_extension_st TLS_EXTENSION;
-  
-  /* used to hold info on the particular ciphers used */
-  typedef struct ssl_cipher_st
- @@ -361,6 +362,8 @@ DECLARE_STACK_OF(SSL_CIPHER)
-  typedef struct ssl_st SSL;
-  typedef struct ssl_ctx_st SSL_CTX;
-  
- +typedef int (*tls_session_secret_cb_fn)(SSL *s, void *secret, int *secret_len, STACK_OF(SSL_CIPHER) *peer_ciphers, SSL_CIPHER **cipher, void *arg);
- +
-  /* Used to hold functions for SSLv2 or SSLv3/TLSv1 functions */
-  typedef struct ssl_method_st
-  	{
- @@ -968,6 +971,15 @@ struct ssl_st
-  	int first_packet;
-  	int client_version;	/* what was passed, used for
-  				 * SSLv3/TLS rollback check */
- +
- +	/* TLS externsions */
- +	TLS_EXTENSION *tls_extension;
- +	int (*tls_extension_cb)(SSL *s, TLS_EXTENSION *tls_ext, void *arg);
- +	void *tls_extension_cb_arg;
- +
- +	/* TLS pre-shared secret session resumption */
- +	tls_session_secret_cb_fn tls_session_secret_cb;
- +	void *tls_session_secret_cb_arg;
-  	};
-  
-  #ifdef __cplusplus
- @@ -1533,6 +1545,13 @@ void *SSL_COMP_get_compression_methods(v
-  int SSL_COMP_add_compression_method(int id,void *cm);
-  #endif
-  
- +/* TLS extensions functions */
- +int SSL_set_hello_extension(SSL *s, int ext_type, void *ext_data, int ext_len);
- +int SSL_set_hello_extension_cb(SSL *s, int (*cb)(SSL *, TLS_EXTENSION *, void *), void *arg);
- +
- +/* Pre-shared secret session resumption functions */
- +int SSL_set_session_secret_cb(SSL *s, tls_session_secret_cb_fn tls_session_secret_cb, void *arg);
- +
-  /* BEGIN ERROR CODES */
-  /* The following lines are auto generated by the script mkerr.pl. Any changes
-   * made after this point may be overwritten when the script is next run.
- @@ -1714,6 +1733,7 @@ void ERR_load_SSL_strings(void);
-  #define SSL_F_TLS1_ENC					 210
-  #define SSL_F_TLS1_SETUP_KEY_BLOCK			 211
-  #define SSL_F_WRITE_PENDING				 212
- +#define SSL_F_SSL_SET_HELLO_EXTENSION	 213
-  
-  /* Reason codes. */
-  #define SSL_R_APP_DATA_IN_HANDSHAKE			 100
- diff -uprN openssl-0.9.8.orig/include/openssl/tls1.h openssl-0.9.8/include/openssl/tls1.h
- --- openssl-0.9.8.orig/include/openssl/tls1.h	2003-07-22 05:34:21.000000000 -0700
- +++ openssl-0.9.8/include/openssl/tls1.h	2005-07-19 20:02:15.000000000 -0700
- @@ -282,6 +282,14 @@ extern "C" {
-  #define TLS_MD_MASTER_SECRET_CONST    "\x6d\x61\x73\x74\x65\x72\x20\x73\x65\x63\x72\x65\x74"  /*master secret*/
-  #endif
-  
- +/* TLS extension struct */
- +struct tls_extension_st
- +{
- +	unsigned short type;
- +	unsigned short length;
- +	void *data;
- +};
- +
-  #ifdef  __cplusplus
-  }
-  #endif
- diff -uprN openssl-0.9.8.orig/ssl/Makefile openssl-0.9.8/ssl/Makefile
- --- openssl-0.9.8.orig/ssl/Makefile	2005-05-30 16:20:30.000000000 -0700
- +++ openssl-0.9.8/ssl/Makefile	2005-07-19 20:02:15.000000000 -0700
- @@ -24,7 +24,7 @@ LIBSRC=	\
-  	s2_meth.c   s2_srvr.c s2_clnt.c  s2_lib.c  s2_enc.c s2_pkt.c \
-  	s3_meth.c   s3_srvr.c s3_clnt.c  s3_lib.c  s3_enc.c s3_pkt.c s3_both.c \
-  	s23_meth.c s23_srvr.c s23_clnt.c s23_lib.c          s23_pkt.c \
- -	t1_meth.c   t1_srvr.c t1_clnt.c  t1_lib.c  t1_enc.c \
- +	t1_meth.c   t1_srvr.c t1_clnt.c  t1_lib.c  t1_enc.c                    t1_ext.c \
-  	d1_meth.c   d1_srvr.c d1_clnt.c  d1_lib.c  d1_pkt.c \
-  	d1_both.c d1_enc.c \
-  	ssl_lib.c ssl_err2.c ssl_cert.c ssl_sess.c \
- @@ -35,7 +35,7 @@ LIBOBJ= \
-  	s2_meth.o  s2_srvr.o  s2_clnt.o  s2_lib.o  s2_enc.o s2_pkt.o \
-  	s3_meth.o  s3_srvr.o  s3_clnt.o  s3_lib.o  s3_enc.o s3_pkt.o s3_both.o \
-  	s23_meth.o s23_srvr.o s23_clnt.o s23_lib.o          s23_pkt.o \
- -	t1_meth.o   t1_srvr.o t1_clnt.o  t1_lib.o  t1_enc.o \
- +	t1_meth.o   t1_srvr.o t1_clnt.o  t1_lib.o  t1_enc.o                    t1_ext.o \
-  	d1_meth.o   d1_srvr.o d1_clnt.o  d1_lib.o  d1_pkt.o \
-  	d1_both.o d1_enc.o \
-  	ssl_lib.o ssl_err2.o ssl_cert.o ssl_sess.o \
- @@ -968,3 +968,4 @@ t1_srvr.o: ../include/openssl/ssl23.h ..
-  t1_srvr.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
-  t1_srvr.o: ../include/openssl/tls1.h ../include/openssl/x509.h
-  t1_srvr.o: ../include/openssl/x509_vfy.h ssl_locl.h t1_srvr.c
- +t1_ext.o: t1_ext.c ssl_locl.h
- diff -uprN openssl-0.9.8.orig/ssl/s3_clnt.c openssl-0.9.8/ssl/s3_clnt.c
- --- openssl-0.9.8.orig/ssl/s3_clnt.c	2005-05-16 03:11:03.000000000 -0700
- +++ openssl-0.9.8/ssl/s3_clnt.c	2005-07-19 20:02:15.000000000 -0700
- @@ -606,6 +606,20 @@ int ssl3_client_hello(SSL *s)
-  			}
-  		*(p++)=0; /* Add the NULL method */
-  		
- +		/* send client hello extensions if any */
- +		if (s->version >= TLS1_VERSION && s->tls_extension)
- +		{
- +			// set the total extensions length
- +			s2n(s->tls_extension->length + 4, p);
- +
- +			// put the extensions with type and length
- +			s2n(s->tls_extension->type, p);
- +			s2n(s->tls_extension->length, p);
- +			
- +			memcpy(p, s->tls_extension->data, s->tls_extension->length);
- +			p+=s->tls_extension->length;
- +		}
- +
-  		l=(p-d);
-  		d=buf;
-  		*(d++)=SSL3_MT_CLIENT_HELLO;
- @@ -628,7 +642,7 @@ int ssl3_get_server_hello(SSL *s)
-  	STACK_OF(SSL_CIPHER) *sk;
-  	SSL_CIPHER *c;
-  	unsigned char *p,*d;
- -	int i,al,ok;
- +	int i,al,ok,pre_shared;
-  	unsigned int j;
-  	long n;
-  	SSL_COMP *comp;
- @@ -693,7 +707,24 @@ int ssl3_get_server_hello(SSL *s)
-  		goto f_err;
-  		}
-  
- -	if (j != 0 && j == s->session->session_id_length
- +	/* check if we want to resume the session based on external pre-shared secret */
- +	pre_shared = 0;
- +	if (s->version >= TLS1_VERSION && s->tls_session_secret_cb)
- +	{
- +		SSL_CIPHER *pref_cipher=NULL;
- +		s->session->master_key_length=sizeof(s->session->master_key);
- +		if (s->tls_session_secret_cb(s, s->session->master_key, &s->session->master_key_length,
- +			NULL, &pref_cipher, s->tls_session_secret_cb_arg))
- +		{
- +			s->hit=1;
- +			s->session->cipher=pref_cipher ? pref_cipher : ssl_get_cipher_by_char(s,p+j);
- +			s->session->session_id_length = j;
- +			memcpy(s->session->session_id, p, j);
- +			pre_shared = 1;
- +		}
- +	}
- +
- +	if ((pre_shared || j != 0) && j == s->session->session_id_length
-  	    && memcmp(p,s->session->session_id,j) == 0)
-  	    {
-  	    if(s->sid_ctx_length != s->session->sid_ctx_length
- diff -uprN openssl-0.9.8.orig/ssl/s3_srvr.c openssl-0.9.8/ssl/s3_srvr.c
- --- openssl-0.9.8.orig/ssl/s3_srvr.c	2005-05-22 17:32:55.000000000 -0700
- +++ openssl-0.9.8/ssl/s3_srvr.c	2005-07-19 20:02:15.000000000 -0700
- @@ -955,6 +955,75 @@ int ssl3_get_client_hello(SSL *s)
-  		}
-  #endif
-  
- +	/* Check for TLS client hello extension here */
- +	if (p < (d+n) && s->version >= TLS1_VERSION)
- +	{
- +		if (s->tls_extension_cb)
- +		{
- +			TLS_EXTENSION tls_ext;
- +			unsigned short ext_total_len;
- +			
- +			n2s(p, ext_total_len);
- +			n2s(p, tls_ext.type);
- +			n2s(p, tls_ext.length);
- +
- +			// sanity check in TLS extension len
- +			if (tls_ext.length > (d+n) - p)
- +			{
- +				// just cut the lenth to packet border
- +				tls_ext.length = (d+n) - p;
- +			}
- +
- +			tls_ext.data = p;
- +
- +			// returns an alert code or 0
- +			al = s->tls_extension_cb(s, &tls_ext, s->tls_extension_cb_arg);
- +			if (al != 0)
- +			{
- +				SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_PEER_ERROR);
- +				goto f_err;
- +			}
- +		}
- +	}
- +
- +	/* Check if we want to use external pre-shared secret for this handshake */
- +	/* for not reused session only */
- +	if (!s->hit && s->version >= TLS1_VERSION && s->tls_session_secret_cb)
- +	{
- +		SSL_CIPHER *pref_cipher=NULL;
- +
- +		s->session->master_key_length=sizeof(s->session->master_key);
- +		if(s->tls_session_secret_cb(s, s->session->master_key, &s->session->master_key_length, 
- +			ciphers, &pref_cipher, s->tls_session_secret_cb_arg))
- +		{
- +			s->hit=1;
- +			s->session->ciphers=ciphers;
- +			s->session->verify_result=X509_V_OK;
- +			
- +			ciphers=NULL;
- +			
- +			/* check if some cipher was preferred by call back */
- +			pref_cipher=pref_cipher ? pref_cipher : ssl3_choose_cipher(s, s->session->ciphers, SSL_get_ciphers(s));
- +			if (pref_cipher == NULL)
- +				{
- +				al=SSL_AD_HANDSHAKE_FAILURE;
- +				SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_SHARED_CIPHER);
- +				goto f_err;
- +				}
- +
- +			s->session->cipher=pref_cipher;
- +
- +			if (s->cipher_list)
- +				sk_SSL_CIPHER_free(s->cipher_list);
- +
- +			if (s->cipher_list_by_id)
- +				sk_SSL_CIPHER_free(s->cipher_list_by_id);
- +
- +			s->cipher_list = sk_SSL_CIPHER_dup(s->session->ciphers);
- +			s->cipher_list_by_id = sk_SSL_CIPHER_dup(s->session->ciphers);
- +		}
- +	}
- +
-  	/* Given s->session->ciphers and SSL_get_ciphers, we must
-  	 * pick a cipher */
-  
- diff -uprN openssl-0.9.8.orig/ssl/ssl_err.c openssl-0.9.8/ssl/ssl_err.c
- --- openssl-0.9.8.orig/ssl/ssl_err.c	2005-06-10 12:51:16.000000000 -0700
- +++ openssl-0.9.8/ssl/ssl_err.c	2005-07-19 20:02:15.000000000 -0700
- @@ -242,6 +242,7 @@ static ERR_STRING_DATA SSL_str_functs[]=
-  {ERR_FUNC(SSL_F_TLS1_ENC),	"TLS1_ENC"},
-  {ERR_FUNC(SSL_F_TLS1_SETUP_KEY_BLOCK),	"TLS1_SETUP_KEY_BLOCK"},
-  {ERR_FUNC(SSL_F_WRITE_PENDING),	"WRITE_PENDING"},
- +{ERR_FUNC(SSL_F_SSL_SET_HELLO_EXTENSION), "SSL_set_hello_extension"},
-  {0,NULL}
-  	};
-  
- diff -uprN openssl-0.9.8.orig/ssl/ssl.h openssl-0.9.8/ssl/ssl.h
- --- openssl-0.9.8.orig/ssl/ssl.h	2005-06-10 12:51:16.000000000 -0700
- +++ openssl-0.9.8/ssl/ssl.h	2005-07-19 20:02:15.000000000 -0700
- @@ -340,6 +340,7 @@ extern "C" {
-   * 'struct ssl_st *' function parameters used to prototype callbacks
-   * in SSL_CTX. */
-  typedef struct ssl_st *ssl_crock_st;
- +typedef struct tls_extension_st TLS_EXTENSION;
-  
-  /* used to hold info on the particular ciphers used */
-  typedef struct ssl_cipher_st
- @@ -361,6 +362,8 @@ DECLARE_STACK_OF(SSL_CIPHER)
-  typedef struct ssl_st SSL;
-  typedef struct ssl_ctx_st SSL_CTX;
-  
- +typedef int (*tls_session_secret_cb_fn)(SSL *s, void *secret, int *secret_len, STACK_OF(SSL_CIPHER) *peer_ciphers, SSL_CIPHER **cipher, void *arg);
- +
-  /* Used to hold functions for SSLv2 or SSLv3/TLSv1 functions */
-  typedef struct ssl_method_st
-  	{
- @@ -968,6 +971,15 @@ struct ssl_st
-  	int first_packet;
-  	int client_version;	/* what was passed, used for
-  				 * SSLv3/TLS rollback check */
- +
- +	/* TLS externsions */
- +	TLS_EXTENSION *tls_extension;
- +	int (*tls_extension_cb)(SSL *s, TLS_EXTENSION *tls_ext, void *arg);
- +	void *tls_extension_cb_arg;
- +
- +	/* TLS pre-shared secret session resumption */
- +	tls_session_secret_cb_fn tls_session_secret_cb;
- +	void *tls_session_secret_cb_arg;
-  	};
-  
-  #ifdef __cplusplus
- @@ -1533,6 +1545,13 @@ void *SSL_COMP_get_compression_methods(v
-  int SSL_COMP_add_compression_method(int id,void *cm);
-  #endif
-  
- +/* TLS extensions functions */
- +int SSL_set_hello_extension(SSL *s, int ext_type, void *ext_data, int ext_len);
- +int SSL_set_hello_extension_cb(SSL *s, int (*cb)(SSL *, TLS_EXTENSION *, void *), void *arg);
- +
- +/* Pre-shared secret session resumption functions */
- +int SSL_set_session_secret_cb(SSL *s, tls_session_secret_cb_fn tls_session_secret_cb, void *arg);
- +
-  /* BEGIN ERROR CODES */
-  /* The following lines are auto generated by the script mkerr.pl. Any changes
-   * made after this point may be overwritten when the script is next run.
- @@ -1714,6 +1733,7 @@ void ERR_load_SSL_strings(void);
-  #define SSL_F_TLS1_ENC					 210
-  #define SSL_F_TLS1_SETUP_KEY_BLOCK			 211
-  #define SSL_F_WRITE_PENDING				 212
- +#define SSL_F_SSL_SET_HELLO_EXTENSION	 213
-  
-  /* Reason codes. */
-  #define SSL_R_APP_DATA_IN_HANDSHAKE			 100
- diff -uprN openssl-0.9.8.orig/ssl/ssl_sess.c openssl-0.9.8/ssl/ssl_sess.c
- --- openssl-0.9.8.orig/ssl/ssl_sess.c	2005-04-29 13:10:06.000000000 -0700
- +++ openssl-0.9.8/ssl/ssl_sess.c	2005-07-19 20:02:15.000000000 -0700
- @@ -656,6 +656,15 @@ long SSL_CTX_get_timeout(const SSL_CTX *
-  	return(s->session_timeout);
-  	}
-  
- +int SSL_set_session_secret_cb(SSL *s, int (*tls_session_secret_cb)(SSL *s, void *secret, int *secret_len, 
- +	STACK_OF(SSL_CIPHER) *peer_ciphers, SSL_CIPHER **cipher, void *arg), void *arg)
- +{
- +	if (s == NULL) return(0);
- +	s->tls_session_secret_cb = tls_session_secret_cb;
- +	s->tls_session_secret_cb_arg = arg;
- +	return(1);
- +}
- +
-  typedef struct timeout_param_st
-  	{
-  	SSL_CTX *ctx;
- diff -uprN openssl-0.9.8.orig/ssl/t1_ext.c openssl-0.9.8/ssl/t1_ext.c
- --- openssl-0.9.8.orig/ssl/t1_ext.c	1969-12-31 16:00:00.000000000 -0800
- +++ openssl-0.9.8/ssl/t1_ext.c	2005-07-19 20:03:29.000000000 -0700
- @@ -0,0 +1,48 @@
- +
- +#include <stdio.h>
- +#include "ssl_locl.h"
- +
- +
- +int SSL_set_hello_extension(SSL *s, int ext_type, void *ext_data, int ext_len)
- +{
- +	if(s->version >= TLS1_VERSION)
- +	{
- +		if(s->tls_extension)
- +		{
- +			OPENSSL_free(s->tls_extension);
- +			s->tls_extension = NULL;
- +		}
- +
- +		if(ext_data)
- +		{
- +			s->tls_extension = OPENSSL_malloc(sizeof(TLS_EXTENSION) + ext_len);
- +			if(!s->tls_extension)
- +			{
- +				SSLerr(SSL_F_SSL_SET_HELLO_EXTENSION, ERR_R_MALLOC_FAILURE);
- +				return 0;
- +			}
- +
- +			s->tls_extension->type = ext_type;
- +			s->tls_extension->length = ext_len;
- +			s->tls_extension->data = s->tls_extension + 1;
- +			memcpy(s->tls_extension->data, ext_data, ext_len);
- +		}
- +
- +		return 1;
- +	}
- +
- +	return 0;
- +}
- +
- +int SSL_set_hello_extension_cb(SSL *s, int (*cb)(SSL *, TLS_EXTENSION *, void *), void *arg)
- +{
- +	if(s->version >= TLS1_VERSION)
- +	{
- +		s->tls_extension_cb = cb;
- +		s->tls_extension_cb_arg = arg;
- +
- +		return 1;
- +	}
- +
- +	return 0;
- +}
- diff -uprN openssl-0.9.8.orig/ssl/t1_lib.c openssl-0.9.8/ssl/t1_lib.c
- --- openssl-0.9.8.orig/ssl/t1_lib.c	2005-04-26 09:02:40.000000000 -0700
- +++ openssl-0.9.8/ssl/t1_lib.c	2005-07-19 20:02:15.000000000 -0700
- @@ -131,6 +131,10 @@ int tls1_new(SSL *s)
-  
-  void tls1_free(SSL *s)
-  	{
- +	if(s->tls_extension)
- +	{
- +		OPENSSL_free(s->tls_extension);
- +	}
-  	ssl3_free(s);
-  	}
-  
- diff -uprN openssl-0.9.8.orig/ssl/tls1.h openssl-0.9.8/ssl/tls1.h
- --- openssl-0.9.8.orig/ssl/tls1.h	2003-07-22 05:34:21.000000000 -0700
- +++ openssl-0.9.8/ssl/tls1.h	2005-07-19 20:02:15.000000000 -0700
- @@ -282,6 +282,14 @@ extern "C" {
-  #define TLS_MD_MASTER_SECRET_CONST    "\x6d\x61\x73\x74\x65\x72\x20\x73\x65\x63\x72\x65\x74"  /*master secret*/
-  #endif
-  
- +/* TLS extension struct */
- +struct tls_extension_st
- +{
- +	unsigned short type;
- +	unsigned short length;
- +	void *data;
- +};
- +
-  #ifdef  __cplusplus
-  }
-  #endif
- diff -uprN openssl-0.9.8.orig/util/ssleay.num openssl-0.9.8/util/ssleay.num
- --- openssl-0.9.8.orig/util/ssleay.num	2005-05-08 17:22:02.000000000 -0700
- +++ openssl-0.9.8/util/ssleay.num	2005-07-19 20:02:15.000000000 -0700
- @@ -226,3 +226,6 @@ DTLSv1_server_method                    
-  SSL_COMP_get_compression_methods        276	EXIST:!VMS:FUNCTION:COMP
-  SSL_COMP_get_compress_methods           276	EXIST:VMS:FUNCTION:COMP
-  SSL_SESSION_get_id                      277	EXIST::FUNCTION:
- +SSL_set_hello_extension			278	EXIST::FUNCTION:
- +SSL_set_hello_extension_cb		279	EXIST::FUNCTION:
- +SSL_set_session_secret_cb		280	EXIST::FUNCTION:
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/tests/test_aes.c wpa_view/wpa_suppl/tests/test_aes.c
*** wpa_supplicant-0.5.7/tests/test_aes.c	Tue May 23 05:58:50 2006
--- wpa_view/wpa_suppl/tests/test_aes.c	Thu Jan  1 02:00:00 1970
***************
*** 1,289 ****
- /*
-  * Test program for AES
-  * Copyright (c) 2003-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #include "includes.h"
- 
- #include "common.h"
- #include "crypto.h"
- #include "aes_wrap.h"
- 
- #define BLOCK_SIZE 16
- 
- static void test_aes_perf(void)
- {
- #if 0 /* this did not seem to work with new compiler?! */
- #ifdef __i386__
- #define rdtscll(val) \
-      __asm__ __volatile__("rdtsc" : "=A" (val))
- 	const int num_iters = 10;
- 	int i;
- 	unsigned int start, end;
- 	u8 key[16], pt[16], ct[16];
- 	void *ctx;
- 
- 	printf("keySetupEnc:");
- 	for (i = 0; i < num_iters; i++) {
- 		rdtscll(start);
- 		ctx = aes_encrypt_init(key, 16);
- 		rdtscll(end);
- 		aes_encrypt_deinit(ctx);
- 		printf(" %d", end - start);
- 	}
- 	printf("\n");
- 
- 	printf("Encrypt:");
- 	ctx = aes_encrypt_init(key, 16);
- 	for (i = 0; i < num_iters; i++) {
- 		rdtscll(start);
- 		aes_encrypt(ctx, pt, ct);
- 		rdtscll(end);
- 		printf(" %d", end - start);
- 	}
- 	aes_encrypt_deinit(ctx);
- 	printf("\n");
- #endif /* __i386__ */
- #endif
- }
- 
- 
- static int test_eax(void)
- {
- 	u8 msg[] = { 0xF7, 0xFB };
- 	u8 key[] = { 0x91, 0x94, 0x5D, 0x3F, 0x4D, 0xCB, 0xEE, 0x0B,
- 		     0xF4, 0x5E, 0xF5, 0x22, 0x55, 0xF0, 0x95, 0xA4 };
- 	u8 nonce[] = { 0xBE, 0xCA, 0xF0, 0x43, 0xB0, 0xA2, 0x3D, 0x84,
- 		       0x31, 0x94, 0xBA, 0x97, 0x2C, 0x66, 0xDE, 0xBD };
- 	u8 hdr[] = { 0xFA, 0x3B, 0xFD, 0x48, 0x06, 0xEB, 0x53, 0xFA };
- 	u8 cipher[] = { 0x19, 0xDD, 0x5C, 0x4C, 0x93, 0x31, 0x04, 0x9D,
- 			0x0B, 0xDA, 0xB0, 0x27, 0x74, 0x08, 0xF6, 0x79,
- 			0x67, 0xE5 };
- 	u8 data[sizeof(msg)], tag[BLOCK_SIZE];
- 
- 	memcpy(data, msg, sizeof(msg));
- 	if (aes_128_eax_encrypt(key, nonce, sizeof(nonce), hdr, sizeof(hdr),
- 				data, sizeof(data), tag)) {
- 		printf("AES-128 EAX mode encryption failed\n");
- 		return 1;
- 	}
- 	if (memcmp(data, cipher, sizeof(data)) != 0) {
- 		printf("AES-128 EAX mode encryption returned invalid cipher "
- 		       "text\n");
- 		return 1;
- 	}
- 	if (memcmp(tag, cipher + sizeof(data), BLOCK_SIZE) != 0) {
- 		printf("AES-128 EAX mode encryption returned invalid tag\n");
- 		return 1;
- 	}
- 
- 	if (aes_128_eax_decrypt(key, nonce, sizeof(nonce), hdr, sizeof(hdr),
- 				data, sizeof(data), tag)) {
- 		printf("AES-128 EAX mode decryption failed\n");
- 		return 1;
- 	}
- 	if (memcmp(data, msg, sizeof(data)) != 0) {
- 		printf("AES-128 EAX mode decryption returned invalid plain "
- 		       "text\n");
- 		return 1;
- 	}
- 
- 	return 0;
- }
- 
- 
- static int test_cbc(void)
- {
- 	struct cbc_test_vector {
- 		u8 key[16];
- 		u8 iv[16];
- 		u8 plain[32];
- 		u8 cipher[32];
- 		size_t len;
- 	} vectors[] = {
- 		{
- 			{ 0x06, 0xa9, 0x21, 0x40, 0x36, 0xb8, 0xa1, 0x5b,
- 			  0x51, 0x2e, 0x03, 0xd5, 0x34, 0x12, 0x00, 0x06 },
- 			{ 0x3d, 0xaf, 0xba, 0x42, 0x9d, 0x9e, 0xb4, 0x30,
- 			  0xb4, 0x22, 0xda, 0x80, 0x2c, 0x9f, 0xac, 0x41 },
- 			"Single block msg",
- 			{ 0xe3, 0x53, 0x77, 0x9c, 0x10, 0x79, 0xae, 0xb8,
- 			  0x27, 0x08, 0x94, 0x2d, 0xbe, 0x77, 0x18, 0x1a },
- 			16
- 		},
- 		{
- 			{ 0xc2, 0x86, 0x69, 0x6d, 0x88, 0x7c, 0x9a, 0xa0,
- 			  0x61, 0x1b, 0xbb, 0x3e, 0x20, 0x25, 0xa4, 0x5a },
- 			{ 0x56, 0x2e, 0x17, 0x99, 0x6d, 0x09, 0x3d, 0x28,
- 			  0xdd, 0xb3, 0xba, 0x69, 0x5a, 0x2e, 0x6f, 0x58 },
- 			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
- 			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
- 			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
- 			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f },
- 			{ 0xd2, 0x96, 0xcd, 0x94, 0xc2, 0xcc, 0xcf, 0x8a,
- 			  0x3a, 0x86, 0x30, 0x28, 0xb5, 0xe1, 0xdc, 0x0a,
- 			  0x75, 0x86, 0x60, 0x2d, 0x25, 0x3c, 0xff, 0xf9,
- 			  0x1b, 0x82, 0x66, 0xbe, 0xa6, 0xd6, 0x1a, 0xb1 },
- 			32
- 		}
- 	};
- 	int ret = 0;
- 	u8 *buf;
- 	unsigned int i;
- 
- 	for (i = 0; i < sizeof(vectors) / sizeof(vectors[0]); i++) {
- 		struct cbc_test_vector *tv = &vectors[i];
- 		buf = malloc(tv->len);
- 		if (buf == NULL) {
- 			ret++;
- 			break;
- 		}
- 		memcpy(buf, tv->plain, tv->len);
- 		aes_128_cbc_encrypt(tv->key, tv->iv, buf, tv->len);
- 		if (memcmp(buf, tv->cipher, tv->len) != 0) {
- 			printf("AES-CBC encrypt %d failed\n", i);
- 			ret++;
- 		}
- 		memcpy(buf, tv->cipher, tv->len);
- 		aes_128_cbc_decrypt(tv->key, tv->iv, buf, tv->len);
- 		if (memcmp(buf, tv->plain, tv->len) != 0) {
- 			printf("AES-CBC decrypt %d failed\n", i);
- 			ret++;
- 		}
- 		free(buf);
- 	}
- 
- 	return ret;
- }
- 
- 
- /* OMAC1 AES-128 test vectors from
-  * http://csrc.nist.gov/CryptoToolkit/modes/proposedmodes/omac/omac-ad.pdf
-  */
- 
- struct omac1_test_vector {
- 	u8 k[16];
- 	u8 msg[64];
- 	int msg_len;
- 	u8 tag[16];
- };
- 
- static struct omac1_test_vector test_vectors[] =
- {
- 	{
- 		{ 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
- 		  0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c },
- 		{ },
- 		0,
- 		{ 0xbb, 0x1d, 0x69, 0x29, 0xe9, 0x59, 0x37, 0x28,
- 		  0x7f, 0xa3, 0x7d, 0x12, 0x9b, 0x75, 0x67, 0x46 }
- 	},
- 	{
- 		{ 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
- 		  0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c },
- 		{ 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
- 		  0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a},
- 		16,
- 		{ 0x07, 0x0a, 0x16, 0xb4, 0x6b, 0x4d, 0x41, 0x44,
- 		  0xf7, 0x9b, 0xdd, 0x9d, 0xd0, 0x4a, 0x28, 0x7c }
- 	},
- 	{
- 		{ 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
- 		  0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c },
- 		{ 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
- 		  0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
- 		  0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
- 		  0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
- 		  0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11 },
- 		40,
- 		{ 0xdf, 0xa6, 0x67, 0x47, 0xde, 0x9a, 0xe6, 0x30,
- 		  0x30, 0xca, 0x32, 0x61, 0x14, 0x97, 0xc8, 0x27 }
- 	},
- 	{
- 		{ 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
- 		  0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c },
- 		{ 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
- 		  0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
- 		  0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
- 		  0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
- 		  0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
- 		  0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
- 		  0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
- 		  0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 },
- 		64,
- 		{ 0x51, 0xf0, 0xbe, 0xbf, 0x7e, 0x3b, 0x9d, 0x92,
- 		  0xfc, 0x49, 0x74, 0x17, 0x79, 0x36, 0x3c, 0xfe }
- 	},
- };
- 
- 
- int main(int argc, char *argv[])
- {
- 	u8 kek[] = {
- 		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
- 		0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
- 	};
- 	u8 plain[] = {
- 		0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
- 		0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
- 	};
- 	u8 crypt[] = {
- 		0x1F, 0xA6, 0x8B, 0x0A, 0x81, 0x12, 0xB4, 0x47,
- 		0xAE, 0xF3, 0x4B, 0xD8, 0xFB, 0x5A, 0x7B, 0x82,
- 		0x9D, 0x3E, 0x86, 0x23, 0x71, 0xD2, 0xCF, 0xE5
- 	};
- 	u8 result[24];
- 	int ret = 0;
- 	unsigned int i;
- 	struct omac1_test_vector *tv;
- 
- 	if (aes_wrap(kek, 2, plain, result)) {
- 		printf("AES-WRAP-128-128 reported failure\n");
- 		ret++;
- 	}
- 	if (memcmp(result, crypt, 24) != 0) {
- 		printf("AES-WRAP-128-128 failed\n");
- 		ret++;
- 	}
- 	if (aes_unwrap(kek, 2, crypt, result)) {
- 		printf("AES-UNWRAP-128-128 reported failure\n");
- 		ret++;
- 	}
- 	if (memcmp(result, plain, 16) != 0) {
- 		int i;
- 		printf("AES-UNWRAP-128-128 failed\n");
- 		ret++;
- 		for (i = 0; i < 16; i++)
- 			printf(" %02x", result[i]);
- 		printf("\n");
- 	}
- 
- 	test_aes_perf();
- 
- 	for (i = 0; i < sizeof(test_vectors) / sizeof(test_vectors[0]); i++) {
- 		tv = &test_vectors[i];
- 		omac1_aes_128(tv->k, tv->msg, tv->msg_len, result);
- 		if (memcmp(result, tv->tag, 16) != 0) {
- 			printf("OMAC1-AES-128 test vector %d failed\n", i);
- 			ret++;
- 		}
- 	}
- 
- 	ret += test_eax();
- 
- 	ret += test_cbc();
- 
- 	if (ret)
- 		printf("FAILED!\n");
- 
- 	return ret;
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/tests/test_eap_sim_common.c wpa_view/wpa_suppl/tests/test_eap_sim_common.c
*** wpa_supplicant-0.5.7/tests/test_eap_sim_common.c	Tue May 23 05:58:50 2006
--- wpa_view/wpa_suppl/tests/test_eap_sim_common.c	Thu Jan  1 02:00:00 1970
***************
*** 1,53 ****
- /*
-  * Test program for EAP-SIM PRF
-  * Copyright (c) 2004-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #include "eap_sim_common.c"
- 
- 
- static int test_eap_sim_prf(void)
- {
- 	/* http://csrc.nist.gov/encryption/dss/Examples-1024bit.pdf */
- 	u8 xkey[] = {
- 		0xbd, 0x02, 0x9b, 0xbe, 0x7f, 0x51, 0x96, 0x0b,
- 		0xcf, 0x9e, 0xdb, 0x2b, 0x61, 0xf0, 0x6f, 0x0f,
- 		0xeb, 0x5a, 0x38, 0xb6
- 	};
- 	u8 w[] = {
- 		0x20, 0x70, 0xb3, 0x22, 0x3d, 0xba, 0x37, 0x2f,
- 		0xde, 0x1c, 0x0f, 0xfc, 0x7b, 0x2e, 0x3b, 0x49,
- 		0x8b, 0x26, 0x06, 0x14, 0x3c, 0x6c, 0x18, 0xba,
- 		0xcb, 0x0f, 0x6c, 0x55, 0xba, 0xbb, 0x13, 0x78,
- 		0x8e, 0x20, 0xd7, 0x37, 0xa3, 0x27, 0x51, 0x16
- 	};
- 	u8 buf[40];
- 
- 	printf("Testing EAP-SIM PRF (FIPS 186-2 + change notice 1)\n");
- 	eap_sim_prf(xkey, buf, sizeof(buf));
- 	if (memcmp(w, buf, sizeof(w) != 0)) {
- 		printf("eap_sim_prf failed\n");
- 		return 1;
- 	}
- 
- 	return 0;
- }
- 
- 
- int main(int argc, char *argv[])
- {
- 	int errors = 0;
- 
- 	errors += test_eap_sim_prf();
- 
- 	return errors;
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/tests/test_md4.c wpa_view/wpa_suppl/tests/test_md4.c
*** wpa_supplicant-0.5.7/tests/test_md4.c	Tue May 23 06:58:53 2006
--- wpa_view/wpa_suppl/tests/test_md4.c	Thu Jan  1 02:00:00 1970
***************
*** 1,99 ****
- /*
-  * Test program for MD4 (test vectors from RFC 1320)
-  * Copyright (c) 2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #include "includes.h"
- 
- #include "common.h"
- #include "crypto.h"
- 
- int main(int argc, char *argv[])
- {
- 	struct {
- 		char *data;
- 		u8 *hash;
- 	} tests[] = {
- 		{
- 			"",
- 			"\x31\xd6\xcf\xe0\xd1\x6a\xe9\x31"
- 			"\xb7\x3c\x59\xd7\xe0\xc0\x89\xc0"
- 		},
- 		{
- 			"a",
- 			"\xbd\xe5\x2c\xb3\x1d\xe3\x3e\x46"
- 			"\x24\x5e\x05\xfb\xdb\xd6\xfb\x24"
- 		},
- 		{
- 			"abc",
- 			"\xa4\x48\x01\x7a\xaf\x21\xd8\x52"
- 			"\x5f\xc1\x0a\xe8\x7a\xa6\x72\x9d"
- 		},
- 		{
- 			"message digest",
- 			"\xd9\x13\x0a\x81\x64\x54\x9f\xe8"
- 			"\x18\x87\x48\x06\xe1\xc7\x01\x4b"
- 		},
- 		{
- 			"abcdefghijklmnopqrstuvwxyz",
- 			"\xd7\x9e\x1c\x30\x8a\xa5\xbb\xcd"
- 			"\xee\xa8\xed\x63\xdf\x41\x2d\xa9"
- 		},
- 		{
- 			"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
- 			"0123456789",
- 			"\x04\x3f\x85\x82\xf2\x41\xdb\x35"
- 			"\x1c\xe6\x27\xe1\x53\xe7\xf0\xe4"
- 		},
- 		{
- 			"12345678901234567890123456789012345678901234567890"
- 			"123456789012345678901234567890",
- 			"\xe3\x3b\x4d\xdc\x9c\x38\xf2\x19"
- 			"\x9c\x3e\x7b\x16\x4f\xcc\x05\x36"
- 		}
- 	};
- 	unsigned int i;
- 	u8 hash[16];
- 	const u8 *addr[2];
- 	size_t len[2];
- 	int errors = 0;
- 
- 	for (i = 0; i < sizeof(tests) / sizeof(tests[0]); i++) {
- 		printf("MD4 test case %d:", i);
- 
- 		addr[0] = tests[i].data;
- 		len[0] = strlen(tests[i].data);
- 		md4_vector(1, addr, len, hash);
- 		if (memcmp(hash, tests[i].hash, 16) != 0) {
- 			printf(" FAIL");
- 			errors++;
- 		} else
- 			printf(" OK");
- 
- 		if (len[0]) {
- 			addr[0] = tests[i].data;
- 			len[0] = strlen(tests[i].data);
- 			addr[1] = tests[i].data + 1;
- 			len[1] = strlen(tests[i].data) - 1;
- 			md4_vector(1, addr, len, hash);
- 			if (memcmp(hash, tests[i].hash, 16) != 0) {
- 				printf(" FAIL");
- 				errors++;
- 			} else
- 				printf(" OK");
- 		}
- 
- 		printf("\n");
- 	}
- 
- 	return errors;
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/tests/test_md5.c wpa_view/wpa_suppl/tests/test_md5.c
*** wpa_supplicant-0.5.7/tests/test_md5.c	Tue May 23 07:05:59 2006
--- wpa_view/wpa_suppl/tests/test_md5.c	Thu Jan  1 02:00:00 1970
***************
*** 1,99 ****
- /*
-  * Test program for MD5 (test vectors from RFC 1321)
-  * Copyright (c) 2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #include "includes.h"
- 
- #include "common.h"
- #include "crypto.h"
- 
- int main(int argc, char *argv[])
- {
- 	struct {
- 		char *data;
- 		u8 *hash;
- 	} tests[] = {
- 		{
- 			"",
- 			"\xd4\x1d\x8c\xd9\x8f\x00\xb2\x04"
- 			"\xe9\x80\x09\x98\xec\xf8\x42\x7e"
- 		},
- 		{
- 			"a",
- 			"\x0c\xc1\x75\xb9\xc0\xf1\xb6\xa8"
- 			"\x31\xc3\x99\xe2\x69\x77\x26\x61"
- 		},
- 		{
- 			"abc",
- 			"\x90\x01\x50\x98\x3c\xd2\x4f\xb0"
- 			"\xd6\x96\x3f\x7d\x28\xe1\x7f\x72"
- 		},
- 		{
- 			"message digest",
- 			"\xf9\x6b\x69\x7d\x7c\xb7\x93\x8d"
- 			"\x52\x5a\x2f\x31\xaa\xf1\x61\xd0"
- 		},
- 		{
- 			"abcdefghijklmnopqrstuvwxyz",
- 			"\xc3\xfc\xd3\xd7\x61\x92\xe4\x00"
- 			"\x7d\xfb\x49\x6c\xca\x67\xe1\x3b"
- 		},
- 		{
- 			"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
- 			"0123456789",
- 			"\xd1\x74\xab\x98\xd2\x77\xd9\xf5"
- 			"\xa5\x61\x1c\x2c\x9f\x41\x9d\x9f"
- 		},
- 		{
- 			"12345678901234567890123456789012345678901234567890"
- 			"123456789012345678901234567890",
- 			"\x57\xed\xf4\xa2\x2b\xe3\xc9\x55"
- 			"\xac\x49\xda\x2e\x21\x07\xb6\x7a"
- 		}
- 	};
- 	unsigned int i;
- 	u8 hash[16];
- 	const u8 *addr[2];
- 	size_t len[2];
- 	int errors = 0;
- 
- 	for (i = 0; i < sizeof(tests) / sizeof(tests[0]); i++) {
- 		printf("MD5 test case %d:", i);
- 
- 		addr[0] = tests[i].data;
- 		len[0] = strlen(tests[i].data);
- 		md5_vector(1, addr, len, hash);
- 		if (memcmp(hash, tests[i].hash, 16) != 0) {
- 			printf(" FAIL");
- 			errors++;
- 		} else
- 			printf(" OK");
- 
- 		if (len[0]) {
- 			addr[0] = tests[i].data;
- 			len[0] = strlen(tests[i].data);
- 			addr[1] = tests[i].data + 1;
- 			len[1] = strlen(tests[i].data) - 1;
- 			md5_vector(1, addr, len, hash);
- 			if (memcmp(hash, tests[i].hash, 16) != 0) {
- 				printf(" FAIL");
- 				errors++;
- 			} else
- 				printf(" OK");
- 		}
- 
- 		printf("\n");
- 	}
- 
- 	return errors;
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/tests/test_ms_funcs.c wpa_view/wpa_suppl/tests/test_ms_funcs.c
*** wpa_supplicant-0.5.7/tests/test_ms_funcs.c	Tue May 23 05:58:50 2006
--- wpa_view/wpa_suppl/tests/test_ms_funcs.c	Thu Jan  1 02:00:00 1970
***************
*** 1,119 ****
- /*
-  * Test program for ms_funcs
-  * Copyright (c) 2003-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #include "ms_funcs.c"
- 
- 
- int main(int argc, char *argv[])
- {
- 	/* Test vector from RFC2759 example */
- 	u8 *username = "User";
- 	u8 *password = "clientPass";
- 	u8 auth_challenge[] = {
- 		0x5B, 0x5D, 0x7C, 0x7D, 0x7B, 0x3F, 0x2F, 0x3E,
- 		0x3C, 0x2C, 0x60, 0x21, 0x32, 0x26, 0x26, 0x28
- 	};
- 	u8 peer_challenge[] = {
- 		0x21, 0x40, 0x23, 0x24, 0x25, 0x5E, 0x26, 0x2A,
- 		0x28, 0x29, 0x5F, 0x2B, 0x3A, 0x33, 0x7C, 0x7E
- 	};
- 	u8 challenge[] = { 0xD0, 0x2E, 0x43, 0x86, 0xBC, 0xE9, 0x12, 0x26 };
- 	u8 password_hash[] = {
- 		0x44, 0xEB, 0xBA, 0x8D, 0x53, 0x12, 0xB8, 0xD6,
- 		0x11, 0x47, 0x44, 0x11, 0xF5, 0x69, 0x89, 0xAE
- 	};
- 	u8 nt_response[] = {
- 		0x82, 0x30, 0x9E, 0xCD, 0x8D, 0x70, 0x8B, 0x5E,
- 		0xA0, 0x8F, 0xAA, 0x39, 0x81, 0xCD, 0x83, 0x54,
- 		0x42, 0x33, 0x11, 0x4A, 0x3D, 0x85, 0xD6, 0xDF
- 	};
- 	u8 password_hash_hash[] = {
- 		0x41, 0xC0, 0x0C, 0x58, 0x4B, 0xD2, 0xD9, 0x1C,
- 		0x40, 0x17, 0xA2, 0xA1, 0x2F, 0xA5, 0x9F, 0x3F
- 	};
- 	u8 authenticator_response[] = {
- 		0x40, 0x7A, 0x55, 0x89, 0x11, 0x5F, 0xD0, 0xD6,
- 		0x20, 0x9F, 0x51, 0x0F, 0xE9, 0xC0, 0x45, 0x66,
- 		0x93, 0x2C, 0xDA, 0x56
- 	};
- 	u8 master_key[] = {
- 		0xFD, 0xEC, 0xE3, 0x71, 0x7A, 0x8C, 0x83, 0x8C,
- 		0xB3, 0x88, 0xE5, 0x27, 0xAE, 0x3C, 0xDD, 0x31
- 	};
- 	u8 send_start_key[] = {
- 		0x8B, 0x7C, 0xDC, 0x14, 0x9B, 0x99, 0x3A, 0x1B,
- 		0xA1, 0x18, 0xCB, 0x15, 0x3F, 0x56, 0xDC, 0xCB
- 	};
- 	u8 buf[32];
- 
- 	int errors = 0;
- 
- 	printf("Testing ms_funcs.c\n");
- 
- 	challenge_hash(peer_challenge, auth_challenge,
- 		       username, strlen(username),
- 		       buf);
- 	if (memcmp(challenge, buf, sizeof(challenge)) != 0) {
- 		printf("challenge_hash failed\n");
- 		errors++;
- 	}
- 
- 	nt_password_hash(password, strlen(password), buf);
- 	if (memcmp(password_hash, buf, sizeof(password_hash)) != 0) {
- 		printf("nt_password_hash failed\n");
- 		errors++;
- 	}
- 
- 	generate_nt_response(auth_challenge, peer_challenge,
- 			     username, strlen(username),
- 			     password, strlen(password),
- 			     buf);
- 	if (memcmp(nt_response, buf, sizeof(nt_response)) != 0) {
- 		printf("generate_nt_response failed\n");
- 		errors++;
- 	}
- 
- 	hash_nt_password_hash(password_hash, buf);
- 	if (memcmp(password_hash_hash, buf, sizeof(password_hash_hash)) != 0) {
- 		printf("hash_nt_password_hash failed\n");
- 		errors++;
- 	}
- 
- 	generate_authenticator_response(password, strlen(password),
- 					peer_challenge, auth_challenge,
- 					username, strlen(username),
- 					nt_response, buf);
- 	if (memcmp(authenticator_response, buf, sizeof(authenticator_response))
- 	    != 0) {
- 		printf("generate_authenticator_response failed\n");
- 		errors++;
- 	}
- 
- 	get_master_key(password_hash_hash, nt_response, buf);
- 	if (memcmp(master_key, buf, sizeof(master_key)) != 0) {
- 		printf("get_master_key failed\n");
- 		errors++;
- 	}
- 
- 	get_asymetric_start_key(master_key, buf, sizeof(send_start_key), 1, 1);
- 	if (memcmp(send_start_key, buf, sizeof(send_start_key)) != 0) {
- 		printf("get_asymetric_start_key failed\n");
- 		errors++;
- 	}
- 
- 	if (errors)
- 		printf("FAILED! %d errors\n", errors);
- 
- 	return errors;
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/tests/test_sha1.c wpa_view/wpa_suppl/tests/test_sha1.c
*** wpa_supplicant-0.5.7/tests/test_sha1.c	Wed May 24 06:33:26 2006
--- wpa_view/wpa_suppl/tests/test_sha1.c	Thu Jan  1 02:00:00 1970
***************
*** 1,328 ****
- /*
-  * Test program for SHA1 and MD5
-  * Copyright (c) 2003-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #include "includes.h"
- 
- #include "common.h"
- #include "sha1.h"
- #include "md5.h"
- #include "crypto.h"
- 
- 
- static int test_eap_fast(void)
- {
- 	/* draft-cam-winget-eap-fast-01.txt */
- 	const u8 pac_key[] = {
- 		0x0B, 0x97, 0x39, 0x0F, 0x37, 0x51, 0x78, 0x09,
- 		0x81, 0x1E, 0xFD, 0x9C, 0x6E, 0x65, 0x94, 0x2B,
- 		0x63, 0x2C, 0xE9, 0x53, 0x89, 0x38, 0x08, 0xBA,
- 		0x36, 0x0B, 0x03, 0x7C, 0xD1, 0x85, 0xE4, 0x14
- 	};
- 	const u8 seed[] = {
- 		0x3F, 0xFB, 0x11, 0xC4, 0x6C, 0xBF, 0xA5, 0x7A,
- 		0x54, 0x40, 0xDA, 0xE8, 0x22, 0xD3, 0x11, 0xD3,
- 		0xF7, 0x6D, 0xE4, 0x1D, 0xD9, 0x33, 0xE5, 0x93,
- 		0x70, 0x97, 0xEB, 0xA9, 0xB3, 0x66, 0xF4, 0x2A,
- 		0x00, 0x00, 0x00, 0x02, 0x6A, 0x66, 0x43, 0x2A,
- 		0x8D, 0x14, 0x43, 0x2C, 0xEC, 0x58, 0x2D, 0x2F,
- 		0xC7, 0x9C, 0x33, 0x64, 0xBA, 0x04, 0xAD, 0x3A,
- 		0x52, 0x54, 0xD6, 0xA5, 0x79, 0xAD, 0x1E, 0x00
- 	};
- 	const u8 master_secret[] = {
- 		0x4A, 0x1A, 0x51, 0x2C, 0x01, 0x60, 0xBC, 0x02,
- 		0x3C, 0xCF, 0xBC, 0x83, 0x3F, 0x03, 0xBC, 0x64,
- 		0x88, 0xC1, 0x31, 0x2F, 0x0B, 0xA9, 0xA2, 0x77,
- 		0x16, 0xA8, 0xD8, 0xE8, 0xBD, 0xC9, 0xD2, 0x29,
- 		0x38, 0x4B, 0x7A, 0x85, 0xBE, 0x16, 0x4D, 0x27,
- 		0x33, 0xD5, 0x24, 0x79, 0x87, 0xB1, 0xC5, 0xA2  
- 	};
- 	const u8 key_block[] = {
- 		0x59, 0x59, 0xBE, 0x8E, 0x41, 0x3A, 0x77, 0x74,
- 		0x8B, 0xB2, 0xE5, 0xD3, 0x60, 0xAC, 0x4D, 0x35,
- 		0xDF, 0xFB, 0xC8, 0x1E, 0x9C, 0x24, 0x9C, 0x8B,
- 		0x0E, 0xC3, 0x1D, 0x72, 0xC8, 0x84, 0x9D, 0x57,
- 		0x48, 0x51, 0x2E, 0x45, 0x97, 0x6C, 0x88, 0x70,
- 		0xBE, 0x5F, 0x01, 0xD3, 0x64, 0xE7, 0x4C, 0xBB,
- 		0x11, 0x24, 0xE3, 0x49, 0xE2, 0x3B, 0xCD, 0xEF,
- 		0x7A, 0xB3, 0x05, 0x39, 0x5D, 0x64, 0x8A, 0x44,
- 		0x11, 0xB6, 0x69, 0x88, 0x34, 0x2E, 0x8E, 0x29,
- 		0xD6, 0x4B, 0x7D, 0x72, 0x17, 0x59, 0x28, 0x05,
- 		0xAF, 0xF9, 0xB7, 0xFF, 0x66, 0x6D, 0xA1, 0x96,
- 		0x8F, 0x0B, 0x5E, 0x06, 0x46, 0x7A, 0x44, 0x84,
- 		0x64, 0xC1, 0xC8, 0x0C, 0x96, 0x44, 0x09, 0x98,
- 		0xFF, 0x92, 0xA8, 0xB4, 0xC6, 0x42, 0x28, 0x71
- 	};
- 	const u8 sks[] = {
- 		0xD6, 0x4B, 0x7D, 0x72, 0x17, 0x59, 0x28, 0x05,
- 		0xAF, 0xF9, 0xB7, 0xFF, 0x66, 0x6D, 0xA1, 0x96,
- 		0x8F, 0x0B, 0x5E, 0x06, 0x46, 0x7A, 0x44, 0x84,
- 		0x64, 0xC1, 0xC8, 0x0C, 0x96, 0x44, 0x09, 0x98,
- 		0xFF, 0x92, 0xA8, 0xB4, 0xC6, 0x42, 0x28, 0x71
- 	};
- 	const u8 isk[] = {
- 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
- 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
- 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
- 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
- 	};
- 	const u8 imck[] = {
- 		0x16, 0x15, 0x3C, 0x3F, 0x21, 0x55, 0xEF, 0xD9,
- 		0x7F, 0x34, 0xAE, 0xC8, 0x1A, 0x4E, 0x66, 0x80,
- 		0x4C, 0xC3, 0x76, 0xF2, 0x8A, 0xA9, 0x6F, 0x96,
- 		0xC2, 0x54, 0x5F, 0x8C, 0xAB, 0x65, 0x02, 0xE1,
- 		0x18, 0x40, 0x7B, 0x56, 0xBE, 0xEA, 0xA7, 0xC5,
- 		0x76, 0x5D, 0x8F, 0x0B, 0xC5, 0x07, 0xC6, 0xB9,
- 		0x04, 0xD0, 0x69, 0x56, 0x72, 0x8B, 0x6B, 0xB8,
- 		0x15, 0xEC, 0x57, 0x7B
- 	};
- 	const u8 msk[] = {
- 		0x4D, 0x83, 0xA9, 0xBE, 0x6F, 0x8A, 0x74, 0xED,
- 		0x6A, 0x02, 0x66, 0x0A, 0x63, 0x4D, 0x2C, 0x33,
- 		0xC2, 0xDA, 0x60, 0x15, 0xC6, 0x37, 0x04, 0x51,
- 		0x90, 0x38, 0x63, 0xDA, 0x54, 0x3E, 0x14, 0xB9,
- 		0x27, 0x99, 0x18, 0x1E, 0x07, 0xBF, 0x0F, 0x5A,
- 		0x5E, 0x3C, 0x32, 0x93, 0x80, 0x8C, 0x6C, 0x49,
- 		0x67, 0xED, 0x24, 0xFE, 0x45, 0x40, 0xA0, 0x59,
- 		0x5E, 0x37, 0xC2, 0xE9, 0xD0, 0x5D, 0x0A, 0xE3
- 	};
- 	u8 tlv[] = {
- 		0x80, 0x0C, 0x00, 0x38, 0x00, 0x01, 0x01, 0x00,
- 		0xD8, 0x6A, 0x8C, 0x68, 0x3C, 0x32, 0x31, 0xA8,
- 		0x56, 0x63, 0xB6, 0x40, 0x21, 0xFE, 0x21, 0x14,
- 		0x4E, 0xE7, 0x54, 0x20, 0x79, 0x2D, 0x42, 0x62,
- 		0xC9, 0xBF, 0x53, 0x7F, 0x54, 0xFD, 0xAC, 0x58,
- 		0x43, 0x24, 0x6E, 0x30, 0x92, 0x17, 0x6D, 0xCF,
- 		0xE6, 0xE0, 0x69, 0xEB, 0x33, 0x61, 0x6A, 0xCC,
- 		0x05, 0xC5, 0x5B, 0xB7
- 	};
- 	const u8 compound_mac[] = {
- 		0x43, 0x24, 0x6E, 0x30, 0x92, 0x17, 0x6D, 0xCF,
- 		0xE6, 0xE0, 0x69, 0xEB, 0x33, 0x61, 0x6A, 0xCC,
- 		0x05, 0xC5, 0x5B, 0xB7
- 	};
- 	u8 buf[512];
- 	const u8 *simck, *cmk;
- 	int errors = 0;
- 
- 	printf("EAP-FAST test cases\n");
- 
- 	printf("- T-PRF (SHA1) test case / master_secret\n");
- 	sha1_t_prf(pac_key, sizeof(pac_key), "PAC to master secret label hash",
- 		   seed, sizeof(seed), buf, sizeof(master_secret));
- 	if (memcmp(master_secret, buf, sizeof(master_secret)) != 0) {
- 		printf("T-PRF test - FAILED!\n");
- 		errors++;
- 	}
- 
- 	printf("- PRF (TLS, SHA1/MD5) test case / key_block\n");
- 	tls_prf(master_secret, sizeof(master_secret), "key expansion",
- 		seed, sizeof(seed), buf, sizeof(key_block));
- 	if (memcmp(key_block, buf, sizeof(key_block)) != 0) {
- 		printf("PRF test - FAILED!\n");
- 		errors++;
- 	}
- 
- 	printf("- T-PRF (SHA1) test case / IMCK\n");
- 	sha1_t_prf(sks, sizeof(sks), "Inner Methods Compound Keys",
- 		   isk, sizeof(isk), buf, sizeof(imck));
- 	if (memcmp(imck, buf, sizeof(imck)) != 0) {
- 		printf("T-PRF test - FAILED!\n");
- 		errors++;
- 	}
- 
- 	simck = imck;
- 	cmk = imck + 40;
- 
- 	printf("- T-PRF (SHA1) test case / MSK\n");
- 	sha1_t_prf(simck, 40, "Session Key Generating Function",
- 		   (u8 *) "", 0, buf, sizeof(msk));
- 	if (memcmp(msk, buf, sizeof(msk)) != 0) {
- 		printf("T-PRF test - FAILED!\n");
- 		errors++;
- 	}
- 
- 	printf("- Compound MAC test case\n");
- 	memset(tlv + sizeof(tlv) - 20, 0, 20);
- 	hmac_sha1(cmk, 20, tlv, sizeof(tlv), tlv + sizeof(tlv) - 20);
- 	if (memcmp(tlv + sizeof(tlv) - 20, compound_mac, sizeof(compound_mac))
- 	    != 0) {
- 		printf("Compound MAC test - FAILED!\n");
- 		errors++;
- 	}
- 
- 	return errors;
- }
- 
- 
- static u8 key0[] =
- {
- 	0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
- 	0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
- 	0x0b, 0x0b, 0x0b, 0x0b
- };
- static u8 data0[] = "Hi There";
- static u8 prf0[] =
- {
- 	0xbc, 0xd4, 0xc6, 0x50, 0xb3, 0x0b, 0x96, 0x84,
- 	0x95, 0x18, 0x29, 0xe0, 0xd7, 0x5f, 0x9d, 0x54,
- 	0xb8, 0x62, 0x17, 0x5e, 0xd9, 0xf0, 0x06, 0x06,
- 	0xe1, 0x7d, 0x8d, 0xa3, 0x54, 0x02, 0xff, 0xee,
- 	0x75, 0xdf, 0x78, 0xc3, 0xd3, 0x1e, 0x0f, 0x88,
- 	0x9f, 0x01, 0x21, 0x20, 0xc0, 0x86, 0x2b, 0xeb,
- 	0x67, 0x75, 0x3e, 0x74, 0x39, 0xae, 0x24, 0x2e,
- 	0xdb, 0x83, 0x73, 0x69, 0x83, 0x56, 0xcf, 0x5a
- };
- 
- static u8 key1[] = "Jefe";
- static u8 data1[] = "what do ya want for nothing?";
- static u8 prf1[] =
- {
- 	0x51, 0xf4, 0xde, 0x5b, 0x33, 0xf2, 0x49, 0xad,
- 	0xf8, 0x1a, 0xeb, 0x71, 0x3a, 0x3c, 0x20, 0xf4,
- 	0xfe, 0x63, 0x14, 0x46, 0xfa, 0xbd, 0xfa, 0x58,
- 	0x24, 0x47, 0x59, 0xae, 0x58, 0xef, 0x90, 0x09,
- 	0xa9, 0x9a, 0xbf, 0x4e, 0xac, 0x2c, 0xa5, 0xfa,
- 	0x87, 0xe6, 0x92, 0xc4, 0x40, 0xeb, 0x40, 0x02,
- 	0x3e, 0x7b, 0xab, 0xb2, 0x06, 0xd6, 0x1d, 0xe7,
- 	0xb9, 0x2f, 0x41, 0x52, 0x90, 0x92, 0xb8, 0xfc
- };
- 
- 
- static u8 key2[] =
- {
- 	0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 	0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 	0xaa, 0xaa, 0xaa, 0xaa
- };
- static u8 data2[] =
- {
- 	0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
- 	0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
- 	0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
- 	0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
- 	0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
- 	0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
- 	0xdd, 0xdd
- };
- static u8 prf2[] =
- {
- 	0xe1, 0xac, 0x54, 0x6e, 0xc4, 0xcb, 0x63, 0x6f,
- 	0x99, 0x76, 0x48, 0x7b, 0xe5, 0xc8, 0x6b, 0xe1,
- 	0x7a, 0x02, 0x52, 0xca, 0x5d, 0x8d, 0x8d, 0xf1,
- 	0x2c, 0xfb, 0x04, 0x73, 0x52, 0x52, 0x49, 0xce,
- 	0x9d, 0xd8, 0xd1, 0x77, 0xea, 0xd7, 0x10, 0xbc,
- 	0x9b, 0x59, 0x05, 0x47, 0x23, 0x91, 0x07, 0xae,
- 	0xf7, 0xb4, 0xab, 0xd4, 0x3d, 0x87, 0xf0, 0xa6,
- 	0x8f, 0x1c, 0xbd, 0x9e, 0x2b, 0x6f, 0x76, 0x07
- };
- 
- 
- struct passphrase_test {
- 	char *passphrase;
- 	char *ssid;
- 	char psk[32];
- };
- 
- static struct passphrase_test passphrase_tests[] =
- {
- 	{
- 		"password",
- 		"IEEE",
- 		{
- 			0xf4, 0x2c, 0x6f, 0xc5, 0x2d, 0xf0, 0xeb, 0xef,
- 			0x9e, 0xbb, 0x4b, 0x90, 0xb3, 0x8a, 0x5f, 0x90,
- 			0x2e, 0x83, 0xfe, 0x1b, 0x13, 0x5a, 0x70, 0xe2,
- 			0x3a, 0xed, 0x76, 0x2e, 0x97, 0x10, 0xa1, 0x2e
- 		}
- 	},
- 	{
- 		"ThisIsAPassword",
- 		"ThisIsASSID",
- 		{
- 			0x0d, 0xc0, 0xd6, 0xeb, 0x90, 0x55, 0x5e, 0xd6,
- 			0x41, 0x97, 0x56, 0xb9, 0xa1, 0x5e, 0xc3, 0xe3,
- 			0x20, 0x9b, 0x63, 0xdf, 0x70, 0x7d, 0xd5, 0x08,
- 			0xd1, 0x45, 0x81, 0xf8, 0x98, 0x27, 0x21, 0xaf
- 		}
- 	},
- 	{
- 		"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
- 		"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ",
- 		{
- 			0xbe, 0xcb, 0x93, 0x86, 0x6b, 0xb8, 0xc3, 0x83,
- 			0x2c, 0xb7, 0x77, 0xc2, 0xf5, 0x59, 0x80, 0x7c,
- 			0x8c, 0x59, 0xaf, 0xcb, 0x6e, 0xae, 0x73, 0x48,
- 			0x85, 0x00, 0x13, 0x00, 0xa9, 0x81, 0xcc, 0x62
- 		}
- 	},
- };
- 
- #define NUM_PASSPHRASE_TESTS \
- (sizeof(passphrase_tests) / sizeof(passphrase_tests[0]))
- 
- 
- int main(int argc, char *argv[])
- {
- 	u8 res[512];
- 	int ret = 0;
- 	unsigned int i;
- 
- 	printf("PRF-SHA1 test cases:\n");
- 
- 	sha1_prf(key0, sizeof(key0), "prefix", data0, sizeof(data0) - 1,
- 		 res, sizeof(prf0));
- 	if (memcmp(res, prf0, sizeof(prf0)) == 0)
- 		printf("Test case 0 - OK\n");
- 	else {
- 		printf("Test case 0 - FAILED!\n");
- 		ret++;
- 	}
- 
- 	sha1_prf(key1, sizeof(key1) - 1, "prefix", data1, sizeof(data1) - 1,
- 		 res, sizeof(prf1));
- 	if (memcmp(res, prf1, sizeof(prf1)) == 0)
- 		printf("Test case 1 - OK\n");
- 	else {
- 		printf("Test case 1 - FAILED!\n");
- 		ret++;
- 	}
- 
- 	sha1_prf(key2, sizeof(key2), "prefix", data2, sizeof(data2),
- 		 res, sizeof(prf2));
- 	if (memcmp(res, prf2, sizeof(prf2)) == 0)
- 		printf("Test case 2 - OK\n");
- 	else {
- 		printf("Test case 2 - FAILED!\n");
- 		ret++;
- 	}
- 
- 	ret += test_eap_fast();
- 
- 	printf("PBKDF2-SHA1 Passphrase test cases:\n");
- 	for (i = 0; i < NUM_PASSPHRASE_TESTS; i++) {
- 		u8 psk[32];
- 		struct passphrase_test *test = &passphrase_tests[i];
- 		pbkdf2_sha1(test->passphrase,
- 			    test->ssid, strlen(test->ssid),
- 			    4096, psk, 32);
- 		if (memcmp(psk, test->psk, 32) == 0)
- 			printf("Test case %d - OK\n", i);
- 		else {
- 			printf("Test case %d - FAILED!\n", i);
- 			ret++;
- 		}
- 	}
- 
- 	return ret;
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/tests/test_sha256.c wpa_view/wpa_suppl/tests/test_sha256.c
*** wpa_supplicant-0.5.7/tests/test_sha256.c	Wed May 24 06:32:55 2006
--- wpa_view/wpa_suppl/tests/test_sha256.c	Thu Jan  1 02:00:00 1970
***************
*** 1,330 ****
- /*
-  * Test program for SHA256
-  * Copyright (c) 2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #include "includes.h"
- 
- #include "common.h"
- #include "sha256.h"
- #include "crypto.h"
- 
- struct {
- 	char *data;
- 	u8 hash[32];
- } tests[] = {
- 	{
- 		"abc",
- 		{
- 			0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea,
- 			0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23,
- 			0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c,
- 			0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad
- 		}
- 	},
- 	{
- 		"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
- 		{
- 			0x24, 0x8d, 0x6a, 0x61, 0xd2, 0x06, 0x38, 0xb8,
- 			0xe5, 0xc0, 0x26, 0x93, 0x0c, 0x3e, 0x60, 0x39,
- 			0xa3, 0x3c, 0xe4, 0x59, 0x64, 0xff, 0x21, 0x67,
- 			0xf6, 0xec, 0xed, 0xd4, 0x19, 0xdb, 0x06, 0xc1
- 		}
- 	}
- };
- 
- struct hmac_test {
- 	u8 key[80];
- 	size_t key_len;
- 	u8 data[128];
- 	size_t data_len;
- 	u8 hash[32];
- } hmac_tests[] = {
- 	/* draft-ietf-ipsec-ciph-sha-256-01.txt */
- 	{
- 		{
- 			0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
- 			0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
- 			0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
- 			0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20
- 		},
- 		32,
- 		"abc", 3,
- 		{
- 			0xa2, 0x1b, 0x1f, 0x5d, 0x4c, 0xf4, 0xf7, 0x3a,
- 			0x4d, 0xd9, 0x39, 0x75, 0x0f, 0x7a, 0x06, 0x6a,
- 			0x7f, 0x98, 0xcc, 0x13, 0x1c, 0xb1, 0x6a, 0x66,
- 			0x92, 0x75, 0x90, 0x21, 0xcf, 0xab, 0x81, 0x81
- 		}
- 	},
- 	{
- 		{
- 			0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
- 			0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
- 			0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
- 			0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20
- 		},
- 		32,
- 		"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
- 		56,
- 		{
- 			0x10, 0x4f, 0xdc, 0x12, 0x57, 0x32, 0x8f, 0x08,
- 			0x18, 0x4b, 0xa7, 0x31, 0x31, 0xc5, 0x3c, 0xae,
- 			0xe6, 0x98, 0xe3, 0x61, 0x19, 0x42, 0x11, 0x49,
- 			0xea, 0x8c, 0x71, 0x24, 0x56, 0x69, 0x7d, 0x30
- 		}
- 	},
- 	{
- 		{
- 			0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
- 			0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
- 			0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
- 			0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20
- 		},
- 		32,
- 		"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
- 		"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
- 		112,
- 		{
- 			0x47, 0x03, 0x05, 0xfc, 0x7e, 0x40, 0xfe, 0x34,
- 			0xd3, 0xee, 0xb3, 0xe7, 0x73, 0xd9, 0x5a, 0xab,
- 			0x73, 0xac, 0xf0, 0xfd, 0x06, 0x04, 0x47, 0xa5,
- 			0xeb, 0x45, 0x95, 0xbf, 0x33, 0xa9, 0xd1, 0xa3
- 		}
- 	},
- 	{
- 		{
- 			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
- 			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
- 			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
- 			0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b
- 		},
- 		32,
- 		"Hi There",
- 		8,
- 		{
- 			0x19, 0x8a, 0x60, 0x7e, 0xb4, 0x4b, 0xfb, 0xc6,
- 			0x99, 0x03, 0xa0, 0xf1, 0xcf, 0x2b, 0xbd, 0xc5,
- 			0xba, 0x0a, 0xa3, 0xf3, 0xd9, 0xae, 0x3c, 0x1c,
- 			0x7a, 0x3b, 0x16, 0x96, 0xa0, 0xb6, 0x8c, 0xf7
- 		}
- 	},
- 	{
- 		"Jefe",
- 		4,
- 		"what do ya want for nothing?",
- 		28,
- 		{
- 			0x5b, 0xdc, 0xc1, 0x46, 0xbf, 0x60, 0x75, 0x4e,
- 			0x6a, 0x04, 0x24, 0x26, 0x08, 0x95, 0x75, 0xc7,
- 			0x5a, 0x00, 0x3f, 0x08, 0x9d, 0x27, 0x39, 0x83,
- 			0x9d, 0xec, 0x58, 0xb9, 0x64, 0xec, 0x38, 0x43
- 		}
- 	},
- 	{
- 		{
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa
- 		},
- 		32,
- 		{
- 			0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
- 			0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
- 			0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
- 			0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
- 			0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
- 			0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
- 			0xdd, 0xdd
- 		},
- 		50,
- 		{
- 			0xcd, 0xcb, 0x12, 0x20, 0xd1, 0xec, 0xcc, 0xea,
- 			0x91, 0xe5, 0x3a, 0xba, 0x30, 0x92, 0xf9, 0x62,
- 			0xe5, 0x49, 0xfe, 0x6c, 0xe9, 0xed, 0x7f, 0xdc,
- 			0x43, 0x19, 0x1f, 0xbd, 0xe4, 0x5c, 0x30, 0xb0
- 		}
- 	},
- 	{
- 		{
- 			0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
- 			0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
- 			0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
- 			0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
- 			0x21, 0x22, 0x23, 0x24, 0x25
- 		},
- 		37,
- 		{
- 			0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
- 			0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
- 			0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
- 			0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
- 			0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
- 			0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
- 			0xcd, 0xcd
- 		},
- 		50,
- 		{
- 			0xd4, 0x63, 0x3c, 0x17, 0xf6, 0xfb, 0x8d, 0x74,
- 			0x4c, 0x66, 0xde, 0xe0, 0xf8, 0xf0, 0x74, 0x55,
- 			0x6e, 0xc4, 0xaf, 0x55, 0xef, 0x07, 0x99, 0x85,
- 			0x41, 0x46, 0x8e, 0xb4, 0x9b, 0xd2, 0xe9, 0x17
- 		}
- 	},
- 	{
- 		{
- 			0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
- 			0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
- 			0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
- 			0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c
- 		},
- 		32,
- 		"Test With Truncation",
- 		20,
- 		{
- 			0x75, 0x46, 0xaf, 0x01, 0x84, 0x1f, 0xc0, 0x9b,
- 			0x1a, 0xb9, 0xc3, 0x74, 0x9a, 0x5f, 0x1c, 0x17,
- 			0xd4, 0xf5, 0x89, 0x66, 0x8a, 0x58, 0x7b, 0x27,
- 			0x00, 0xa9, 0xc9, 0x7c, 0x11, 0x93, 0xcf, 0x42
- 		}
- 	},
- 	{
- 		{
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa
- 		},
- 		80,
- 		"Test Using Larger Than Block-Size Key - Hash Key First",
- 		54,
- 		{
- 			0x69, 0x53, 0x02, 0x5e, 0xd9, 0x6f, 0x0c, 0x09,
- 			0xf8, 0x0a, 0x96, 0xf7, 0x8e, 0x65, 0x38, 0xdb,
- 			0xe2, 0xe7, 0xb8, 0x20, 0xe3, 0xdd, 0x97, 0x0e,
- 			0x7d, 0xdd, 0x39, 0x09, 0x1b, 0x32, 0x35, 0x2f
- 		}
- 	},
- 	{
- 		{
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
- 			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa
- 		},
- 		80,
- 		"Test Using Larger Than Block-Size Key and Larger Than One "
- 		"Block-Size Data",
- 		73,
- 		{
- 			0x63, 0x55, 0xac, 0x22, 0xe8, 0x90, 0xd0, 0xa3,
- 			0xc8, 0x48, 0x1a, 0x5c, 0xa4, 0x82, 0x5b, 0xc8,
- 			0x84, 0xd3, 0xe7, 0xa1, 0xff, 0x98, 0xa2, 0xfc,
- 			0x2a, 0xc7, 0xd8, 0xe0, 0x64, 0xc3, 0xb2, 0xe6
- 		}
- 	}
- };
- 
- 
- int main(int argc, char *argv[])
- {
- 
- 	unsigned int i;
- 	u8 hash[32];
- 	const u8 *addr[2];
- 	size_t len[2];
- 	int errors = 0;
- 
- 	for (i = 0; i < sizeof(tests) / sizeof(tests[0]); i++) {
- 		printf("SHA256 test case %d:", i + 1);
- 
- 		addr[0] = (u8 *) tests[i].data;
- 		len[0] = strlen(tests[i].data);
- 		sha256_vector(1, addr, len, hash);
- 		if (memcmp(hash, tests[i].hash, 32) != 0) {
- 			printf(" FAIL");
- 			errors++;
- 		} else
- 			printf(" OK");
- 
- 		if (len[0]) {
- 			addr[0] = (u8 *) tests[i].data;
- 			len[0] = 1;
- 			addr[1] = (u8 *) tests[i].data + 1;
- 			len[1] = strlen(tests[i].data) - 1;
- 			sha256_vector(2, addr, len, hash);
- 			if (memcmp(hash, tests[i].hash, 32) != 0) {
- 				printf(" FAIL");
- 				errors++;
- 			} else
- 				printf(" OK");
- 		}
- 
- 		printf("\n");
- 	}
- 
- 	for (i = 0; i < sizeof(hmac_tests) / sizeof(hmac_tests[0]); i++) {
- 		struct hmac_test *t = &hmac_tests[i];
- 		printf("HMAC-SHA256 test case %d:", i + 1);
- 
- 		hmac_sha256(t->key, t->key_len, t->data, t->data_len, hash);
- 		if (memcmp(hash, t->hash, 32) != 0) {
- 			printf(" FAIL");
- 			errors++;
- 		} else
- 			printf(" OK");
- 
- 		addr[0] = t->data;
- 		len[0] = t->data_len;
- 		hmac_sha256_vector(t->key, t->key_len, 1, addr, len, hash);
- 		if (memcmp(hash, t->hash, 32) != 0) {
- 			printf(" FAIL");
- 			errors++;
- 		} else
- 			printf(" OK");
- 
- 		if (len[0]) {
- 			addr[0] = t->data;
- 			len[0] = 1;
- 			addr[1] = t->data + 1;
- 			len[1] = t->data_len - 1;
- 			hmac_sha256_vector(t->key, t->key_len, 2, addr, len,
- 					   hash);
- 			if (memcmp(hash, t->hash, 32) != 0) {
- 				printf(" FAIL");
- 				errors++;
- 			} else
- 				printf(" OK");
- 		}
- 
- 		printf("\n");
- 	}
- 
- 	printf("Test IEEE 802.11r KDF\n");
- 	sha256_prf("abc", 3, "KDF test", "data", 4, hash, sizeof(hash));
- 	/* TODO: add proper test case for this */
- 
- 	return errors;
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/tests/test_x509v3.c wpa_view/wpa_suppl/tests/test_x509v3.c
*** wpa_supplicant-0.5.7/tests/test_x509v3.c	Fri Sep  8 05:51:09 2006
--- wpa_view/wpa_suppl/tests/test_x509v3.c	Thu Jan  1 02:00:00 1970
***************
*** 1,69 ****
- /*
-  * Testing tool for X.509v3 routines
-  * Copyright (c) 2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #include "includes.h"
- 
- #include "common.h"
- #include "asn1.h"
- #include "x509v3.h"
- 
- extern int wpa_debug_level;
- 
- 
- int main(int argc, char *argv[])
- {
- 	char *buf;
- 	size_t len;
- 	struct x509_certificate *certs = NULL, *last = NULL, *cert;
- 	int i, reason;
- 
- 	wpa_debug_level = 0;
- 
- 	if (argc < 3 || strcmp(argv[1], "-v") != 0) {
- 		printf("usage: test_x509v3 -v <cert1.der> <cert2.der> ..\n");
- 		return -1;
- 	}
- 
- 	for (i = 2; i < argc; i++) {
- 		printf("Reading: %s\n", argv[i]);
- 		buf = os_readfile(argv[i], &len);
- 		if (buf == NULL) {
- 			printf("Failed to read '%s'\n", argv[i]);
- 			return -1;
- 		}
- 
- 		cert = x509_certificate_parse(buf, len);
- 		if (cert == NULL) {
- 			printf("Failed to parse X.509 certificate\n");
- 			return -1;
- 		}
- 
- 		free(buf);
- 
- 		if (certs == NULL)
- 			certs = cert;
- 		else
- 			last->next = cert;
- 		last = cert;
- 	}
- 
- 	printf("\n\nValidating certificate chain\n");
- 	if (x509_certificate_chain_validate(last, certs, &reason) < 0) {
- 		printf("\nCertificate chain validation failed: %d\n", reason);
- 		return -1;
- 	}
- 	printf("\nCertificate chain is valid\n");
- 
- 	return 0;
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/todo.txt wpa_view/wpa_suppl/todo.txt
*** wpa_supplicant-0.5.7/todo.txt	Fri Nov 24 03:38:40 2006
--- wpa_view/wpa_suppl/todo.txt	Thu Jan  1 02:00:00 1970
***************
*** 1,127 ****
- To do:
- - hostap: try other roaming modes
-   NOTE: current mode (manual roaming) does not really roam at all..
-   Firmware did not notice the current AP disappearing..
- - add support for WPA with ap_scan=0 (update selected cipher etc. based on
-   AssocInfo; make sure these match with configuration)
- - optional security separation (build time option): run EAPOL state machines
-   as non-root (need to add something like socketpair between privileged root
-   process and non-root handler; send EAPOL packets between processes
-   and send keying data from non-root -> privileged)
-   EAPOL-Key processing (WPA & WEP keys) could be in privileged part
-   at least in the beginning; some parts might end up being moved to
-   non-root part eventually
- - consider closing smart card / PCSC connection when EAP-SIM/EAP-AKA
-   authentication has been completed (cache scard data based on serial#(?)
-   and try to optimize next connection if the same card is present for next
-   auth)
- - EAP-AKA: AT_CHECKCODE
- - EAP-SIM/AKA: AT_RESULT_IND
- - on disconnect event, could try to associate with another AP if one is
-   present in scan results; would need to update scan results periodically..
- - if driver/hw is not WPA2 capable, must remove WPA_PROTO_RSN flag from
-   ssid->proto fields to avoid detecting downgrade attacks when the driver
-   is not reporting RSN IE, but msg 3/4 has one
- - Cisco AP and non-zero keyidx for unicast -> map to broadcast
-   (actually, this already works with driver_ndis; so maybe just change
-   driver_*.c to do the mapping for drivers that cannot handle non-zero keyidx
-   for unicast); worked also with Host AP driver and madwifi
- - IEEE 802.1X and key update with driver_ndis?? wpa_supplicant did not seem
-   to see unencrypted EAPOL-Key frames at all..
- - -Dwired: if ssid is set in network block, authentication gets "stuck" since
-   driver_wired.c only reports empty SSID and association is not assumed to be
-   ok
- - EAP-PAX with PAX_SEC
- - EAP (RFC 3748)
-   * OTP Extended Responses (Sect. 5.5)
- - test what happens if authenticator sends EAP-Success before real EAP
-   authentication ("canned" Success); this should be ignored based on
-   RFC 3748 Sect. 4.2
- - test compilation with gcc -W options (more warnings?)
-   (Done once; number of unused function arguments still present)
- - add proper support for using dot11RSNAConfigSATimeout
- - ctrl_iface: get/set/remove blob
- - use doc/docbook/*.sgml and docbook2{txt,html,pdf} to replace README and
-   web pages including the same information.. i.e., have this information only
-   in one page; how to build a PDF file with all the SGML included?
- - test wait-for-interface and daemonize combinations with number of driver
-   interfaces
-   * 'test' worked with WPA-PSK
- - EAP-POTP/RSA SecurID profile (draft-nystrom-eap-potp-03.txt)
- - document wpa_gui build and consider adding it to 'make install'
- - test madwifi with pairwise=TKIP group=WEP104
- - possibility to link in WPA Authenticator state machine to wpa_supplicant
-   (new STAKey handshake, WPA2 IBSS)
- - consider merging hostapd and wpa_supplicant PMKSA cache implementations
- - add support for configuring password for MSCHAPv2 as NtPasswordHash in
-   the same way as was added to hostapd (hash:<hex value>)
- - test_driver: configure directory and create AP-<mac> and STA-<mac> files
-   there to allow scanning multiple APs (e.g., for testing pre-auth and PMKSA
-   caching testing) and to exchange STA-STA EAPOL frames
- - consider adding generic buffer functionality that could be used in number
-   of places
-   * allocate buffer (with default max size), allow reserving head room to
-     make it possible to add a header without having to reallocate buffer
-   * reallocate buffer (add head and/or tail room)
-   * ref count and free when count=0 ?
-   * add data (to tail): re-alloc more tailroom if needed and copy new data
-   * error flag so that caller can do multiple add()s and only in the end
-     check whether something has failed; this should make error handling
-     simpler
- - consider redesigning pending EAP requests (identity/password/otp from
-   ctrl_iface) by moving the retrying of the previous request into EAP
-   state machine so that EAPOL state machine is not needed for this
- - rfc4284.txt (network selection for eap)
- - www pages about configuring wpa_supplicant:
-   * global options (ap_scan, ctrl_interfaces) based on OS/driver
-   * network block
-   * key_mgmt selection
-   * WPA parameters
-   * EAP options (one page for each method)
-   * "configuration wizard" (step 1: select OS, step 2: select driver, ...) to
-     generate example configuration
- - error path in rsn_preauth_init: should probably deinit l2_packet handlers
-   if something fails; does something else need deinit?
- - consider moving SIM card functionality (IMSI fetching) away from eap.c;
-   this should likely happen before EAP is initialized for authentication;
-   now IMSI is read only after receiving EAP-Identity/Request, but since it is
-   really needed for all cases, reading IMSI and generating Identity string
-   could very well be done before EAP has been started
- - test all allowed EAP Phase 2 methods (i.e., anything else than PEAP, TTLS,
-   FAST): SIM AKA PAX PSK LEAP; if these work, include in eap_testing.txt; if
-   not, either fix or make eap_allowed_phase2_type reject
- - try to work around race in receiving association event and first EAPOL
-   message
- - helper function to do memcmp(addr, "\x00\x00\x00\x00\x00\x00", ETH_ALEN)
- - add wpa_secure_memzero() macro and secure implementation (volatile u8*) to
-   clear memory; this would be used to clear temporary buffers containing
-   private data (e.g., keys); the macro can be defined to NOP in order to save
-   space (i.e., no code should depend on the macro doing something)
- - make sure that TLS session cache is not shared between EAP types or if it
-   is, that the cache entries are bound to only one EAP type; e.g., cache entry
-   created with EAP-TLS must not be allowed to do fast re-auth with EAP-TTLS
- - consider moving eap_tls_build_ack() call into eap_tls_process_helper()
-   (it seems to be called always if helper returns 1)
-   * could need to modify eap_{ttls,peap,fast}_decrypt to do same
- - add support for fetching full user cert chain from Windows certificate
-   stores even when there are intermediate CA certs that are not in the
-   configured ca_cert store (e.g., ROOT) (they could be, e.g., in CA store)
- 
- 
- 0.6.x branch:
- - clean up common.[ch]
- - change TLS/crypto library interface to use a structure of function
-   pointers and helper inline functions (like driver_ops) instead of
-   requiring every TLS wrapper to implement all functions
- - move from CVS to git (0.3.x, 0.4.x, 0.5.x releases will continue
-   to be updated only on CVS)
- - move files into subdirectories and combine wpa_supplicant and hostapd
-   into a repository that matches in directory structure with the release
-   tarballs
-   (subdirs: eap_common, eap_peer, eap_server, driver, driver_ap, ...)
- - make it clearer that EAP server/peer can be used as a separate library
-   for other programs
- - add support for encrypted configuration fields (e.g., password, psk,
-   passphrase, pin)
- - wpa_gui: add support for setting and showing priority, id_str, auth_alg
-   (open/shared for static WEP)
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/vs2005/eapol_test/eapol_test.vcproj wpa_view/wpa_suppl/vs2005/eapol_test/eapol_test.vcproj
*** wpa_supplicant-0.5.7/vs2005/eapol_test/eapol_test.vcproj	Sat Nov  4 07:18:31 2006
--- wpa_view/wpa_suppl/vs2005/eapol_test/eapol_test.vcproj	Thu Jan  1 02:00:00 1970
***************
*** 1,365 ****
- <?xml version="1.0" encoding="Windows-1252"?>
- <VisualStudioProject
- 	ProjectType="Visual C++"
- 	Version="8.00"
- 	Name="eapol_test"
- 	ProjectGUID="{0E3F2C6D-1372-48D6-BCAB-E584917C4DE3}"
- 	RootNamespace="eapol_test"
- 	Keyword="Win32Proj"
- 	>
- 	<Platforms>
- 		<Platform
- 			Name="Win32"
- 		/>
- 	</Platforms>
- 	<ToolFiles>
- 	</ToolFiles>
- 	<Configurations>
- 		<Configuration
- 			Name="Debug|Win32"
- 			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
- 			IntermediateDirectory="$(ConfigurationName)"
- 			ConfigurationType="1"
- 			CharacterSet="1"
- 			>
- 			<Tool
- 				Name="VCPreBuildEventTool"
- 			/>
- 			<Tool
- 				Name="VCCustomBuildTool"
- 			/>
- 			<Tool
- 				Name="VCXMLDataGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCWebServiceProxyGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCMIDLTool"
- 			/>
- 			<Tool
- 				Name="VCCLCompilerTool"
- 				Optimization="0"
- 				AdditionalIncludeDirectories="C:\dev\WpdPack\include;C:\dev\openssl\include"
- 				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS"
- 				MinimalRebuild="true"
- 				BasicRuntimeChecks="3"
- 				RuntimeLibrary="3"
- 				UsePrecompiledHeader="0"
- 				WarningLevel="3"
- 				Detect64BitPortabilityProblems="true"
- 				DebugInformationFormat="4"
- 				DisableSpecificWarnings="4244;4267;4311"
- 			/>
- 			<Tool
- 				Name="VCManagedResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCPreLinkEventTool"
- 			/>
- 			<Tool
- 				Name="VCLinkerTool"
- 				AdditionalDependencies="ws2_32.lib Crypt32.lib Winscard.lib Packet.lib wpcap.lib libeay32MT.lib ssleay32Mt.lib"
- 				LinkIncremental="2"
- 				AdditionalLibraryDirectories="C:\dev\WpdPack\lib;C:\dev\openssl\lib"
- 				GenerateDebugInformation="true"
- 				SubSystem="1"
- 				TargetMachine="1"
- 			/>
- 			<Tool
- 				Name="VCALinkTool"
- 			/>
- 			<Tool
- 				Name="VCManifestTool"
- 			/>
- 			<Tool
- 				Name="VCXDCMakeTool"
- 			/>
- 			<Tool
- 				Name="VCBscMakeTool"
- 			/>
- 			<Tool
- 				Name="VCFxCopTool"
- 			/>
- 			<Tool
- 				Name="VCAppVerifierTool"
- 			/>
- 			<Tool
- 				Name="VCWebDeploymentTool"
- 			/>
- 			<Tool
- 				Name="VCPostBuildEventTool"
- 			/>
- 		</Configuration>
- 		<Configuration
- 			Name="Release|Win32"
- 			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
- 			IntermediateDirectory="$(ConfigurationName)"
- 			ConfigurationType="1"
- 			CharacterSet="1"
- 			WholeProgramOptimization="1"
- 			>
- 			<Tool
- 				Name="VCPreBuildEventTool"
- 			/>
- 			<Tool
- 				Name="VCCustomBuildTool"
- 			/>
- 			<Tool
- 				Name="VCXMLDataGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCWebServiceProxyGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCMIDLTool"
- 			/>
- 			<Tool
- 				Name="VCCLCompilerTool"
- 				AdditionalIncludeDirectories="C:\dev\WpdPack\include;C:\dev\openssl\include"
- 				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS"
- 				RuntimeLibrary="2"
- 				UsePrecompiledHeader="0"
- 				WarningLevel="3"
- 				Detect64BitPortabilityProblems="true"
- 				DebugInformationFormat="3"
- 				DisableSpecificWarnings="4244;4267;4311"
- 			/>
- 			<Tool
- 				Name="VCManagedResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCPreLinkEventTool"
- 			/>
- 			<Tool
- 				Name="VCLinkerTool"
- 				AdditionalDependencies="ws2_32.lib Crypt32.lib Winscard.lib Packet.lib wpcap.lib libeay32MT.lib ssleay32Mt.lib"
- 				LinkIncremental="1"
- 				AdditionalLibraryDirectories="C:\dev\WpdPack\lib;C:\dev\openssl\lib"
- 				GenerateDebugInformation="true"
- 				SubSystem="1"
- 				OptimizeReferences="2"
- 				EnableCOMDATFolding="2"
- 				TargetMachine="1"
- 			/>
- 			<Tool
- 				Name="VCALinkTool"
- 			/>
- 			<Tool
- 				Name="VCManifestTool"
- 			/>
- 			<Tool
- 				Name="VCXDCMakeTool"
- 			/>
- 			<Tool
- 				Name="VCBscMakeTool"
- 			/>
- 			<Tool
- 				Name="VCFxCopTool"
- 			/>
- 			<Tool
- 				Name="VCAppVerifierTool"
- 			/>
- 			<Tool
- 				Name="VCWebDeploymentTool"
- 			/>
- 			<Tool
- 				Name="VCPostBuildEventTool"
- 			/>
- 		</Configuration>
- 	</Configurations>
- 	<References>
- 	</References>
- 	<Files>
- 		<Filter
- 			Name="Source Files"
- 			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
- 			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
- 			>
- 			<File
- 				RelativePath="..\..\aes_wrap.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\base64.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\common.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\config.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\config_file.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\crypto.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\ctrl_iface.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\ctrl_iface_named_pipe.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_aka.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_gtc.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_leap.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_md5.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_methods.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_mschapv2.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_otp.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_peap.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_sim.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_sim_common.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_tls.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_tls_common.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_tlv.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_ttls.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eapol_sm.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eapol_test.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eloop_win.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\events.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\l2_packet_winpcap.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\md5.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\ms_funcs.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\os_win32.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\pcsc_funcs.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\pmksa_cache.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\preauth.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\radius.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\radius_client.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\rc4.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\sha1.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\tls_openssl.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\wpa.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\wpa_supplicant.c"
- 				>
- 			</File>
- 		</Filter>
- 		<Filter
- 			Name="Header Files"
- 			Filter="h;hpp;hxx;hm;inl;inc;xsd"
- 			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
- 			>
- 		</Filter>
- 		<Filter
- 			Name="Resource Files"
- 			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
- 			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
- 			>
- 		</Filter>
- 	</Files>
- 	<Globals>
- 	</Globals>
- </VisualStudioProject>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/vs2005/win_if_list/win_if_list.vcproj wpa_view/wpa_suppl/vs2005/win_if_list/win_if_list.vcproj
*** wpa_supplicant-0.5.7/vs2005/win_if_list/win_if_list.vcproj	Mon Aug 28 07:18:08 2006
--- wpa_view/wpa_suppl/vs2005/win_if_list/win_if_list.vcproj	Thu Jan  1 02:00:00 1970
***************
*** 1,203 ****
- <?xml version="1.0" encoding="Windows-1252"?>
- <VisualStudioProject
- 	ProjectType="Visual C++"
- 	Version="8.00"
- 	Name="win_if_list"
- 	ProjectGUID="{9E87CD9C-60CE-4533-85CF-85CA3A9BF26A}"
- 	RootNamespace="win_if_list"
- 	Keyword="Win32Proj"
- 	>
- 	<Platforms>
- 		<Platform
- 			Name="Win32"
- 		/>
- 	</Platforms>
- 	<ToolFiles>
- 	</ToolFiles>
- 	<Configurations>
- 		<Configuration
- 			Name="Debug|Win32"
- 			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
- 			IntermediateDirectory="$(ConfigurationName)"
- 			ConfigurationType="1"
- 			CharacterSet="0"
- 			>
- 			<Tool
- 				Name="VCPreBuildEventTool"
- 			/>
- 			<Tool
- 				Name="VCCustomBuildTool"
- 			/>
- 			<Tool
- 				Name="VCXMLDataGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCWebServiceProxyGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCMIDLTool"
- 			/>
- 			<Tool
- 				Name="VCCLCompilerTool"
- 				Optimization="0"
- 				AdditionalIncludeDirectories="C:\dev\WpdPack\include"
- 				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS"
- 				MinimalRebuild="true"
- 				BasicRuntimeChecks="3"
- 				RuntimeLibrary="3"
- 				UsePrecompiledHeader="0"
- 				WarningLevel="3"
- 				Detect64BitPortabilityProblems="true"
- 				DebugInformationFormat="4"
- 			/>
- 			<Tool
- 				Name="VCManagedResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCPreLinkEventTool"
- 			/>
- 			<Tool
- 				Name="VCLinkerTool"
- 				AdditionalDependencies="wpcap.lib"
- 				LinkIncremental="2"
- 				AdditionalLibraryDirectories="C:\dev\WpdPack\lib"
- 				GenerateDebugInformation="true"
- 				SubSystem="1"
- 				TargetMachine="1"
- 			/>
- 			<Tool
- 				Name="VCALinkTool"
- 			/>
- 			<Tool
- 				Name="VCManifestTool"
- 			/>
- 			<Tool
- 				Name="VCXDCMakeTool"
- 			/>
- 			<Tool
- 				Name="VCBscMakeTool"
- 			/>
- 			<Tool
- 				Name="VCFxCopTool"
- 			/>
- 			<Tool
- 				Name="VCAppVerifierTool"
- 			/>
- 			<Tool
- 				Name="VCWebDeploymentTool"
- 			/>
- 			<Tool
- 				Name="VCPostBuildEventTool"
- 			/>
- 		</Configuration>
- 		<Configuration
- 			Name="Release|Win32"
- 			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
- 			IntermediateDirectory="$(ConfigurationName)"
- 			ConfigurationType="1"
- 			CharacterSet="0"
- 			WholeProgramOptimization="1"
- 			>
- 			<Tool
- 				Name="VCPreBuildEventTool"
- 			/>
- 			<Tool
- 				Name="VCCustomBuildTool"
- 			/>
- 			<Tool
- 				Name="VCXMLDataGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCWebServiceProxyGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCMIDLTool"
- 			/>
- 			<Tool
- 				Name="VCCLCompilerTool"
- 				AdditionalIncludeDirectories="C:\dev\WpdPack\include"
- 				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS"
- 				RuntimeLibrary="2"
- 				UsePrecompiledHeader="0"
- 				WarningLevel="3"
- 				Detect64BitPortabilityProblems="true"
- 				DebugInformationFormat="3"
- 			/>
- 			<Tool
- 				Name="VCManagedResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCPreLinkEventTool"
- 			/>
- 			<Tool
- 				Name="VCLinkerTool"
- 				AdditionalDependencies="wpcap.lib"
- 				LinkIncremental="1"
- 				AdditionalLibraryDirectories="C:\dev\WpdPack\lib"
- 				GenerateDebugInformation="true"
- 				SubSystem="1"
- 				OptimizeReferences="2"
- 				EnableCOMDATFolding="2"
- 				TargetMachine="1"
- 			/>
- 			<Tool
- 				Name="VCALinkTool"
- 			/>
- 			<Tool
- 				Name="VCManifestTool"
- 			/>
- 			<Tool
- 				Name="VCXDCMakeTool"
- 			/>
- 			<Tool
- 				Name="VCBscMakeTool"
- 			/>
- 			<Tool
- 				Name="VCFxCopTool"
- 			/>
- 			<Tool
- 				Name="VCAppVerifierTool"
- 			/>
- 			<Tool
- 				Name="VCWebDeploymentTool"
- 			/>
- 			<Tool
- 				Name="VCPostBuildEventTool"
- 			/>
- 		</Configuration>
- 	</Configurations>
- 	<References>
- 	</References>
- 	<Files>
- 		<Filter
- 			Name="Source Files"
- 			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
- 			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
- 			>
- 			<File
- 				RelativePath="..\..\win_if_list.c"
- 				>
- 			</File>
- 		</Filter>
- 		<Filter
- 			Name="Header Files"
- 			Filter="h;hpp;hxx;hm;inl;inc;xsd"
- 			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
- 			>
- 		</Filter>
- 		<Filter
- 			Name="Resource Files"
- 			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
- 			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
- 			>
- 		</Filter>
- 	</Files>
- 	<Globals>
- 	</Globals>
- </VisualStudioProject>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/vs2005/wpa_cli/wpa_cli.vcproj wpa_view/wpa_suppl/vs2005/wpa_cli/wpa_cli.vcproj
*** wpa_supplicant-0.5.7/vs2005/wpa_cli/wpa_cli.vcproj	Mon Aug 28 07:18:08 2006
--- wpa_view/wpa_suppl/vs2005/wpa_cli/wpa_cli.vcproj	Thu Jan  1 02:00:00 1970
***************
*** 1,213 ****
- <?xml version="1.0" encoding="Windows-1252"?>
- <VisualStudioProject
- 	ProjectType="Visual C++"
- 	Version="8.00"
- 	Name="wpa_cli"
- 	ProjectGUID="{E3A7B181-22CC-4DA3-8410-6AD69879A9EC}"
- 	RootNamespace="wpa_cli"
- 	Keyword="Win32Proj"
- 	>
- 	<Platforms>
- 		<Platform
- 			Name="Win32"
- 		/>
- 	</Platforms>
- 	<ToolFiles>
- 	</ToolFiles>
- 	<Configurations>
- 		<Configuration
- 			Name="Debug|Win32"
- 			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
- 			IntermediateDirectory="$(ConfigurationName)"
- 			ConfigurationType="1"
- 			CharacterSet="0"
- 			>
- 			<Tool
- 				Name="VCPreBuildEventTool"
- 			/>
- 			<Tool
- 				Name="VCCustomBuildTool"
- 			/>
- 			<Tool
- 				Name="VCXMLDataGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCWebServiceProxyGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCMIDLTool"
- 			/>
- 			<Tool
- 				Name="VCCLCompilerTool"
- 				Optimization="0"
- 				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS"
- 				MinimalRebuild="true"
- 				BasicRuntimeChecks="3"
- 				RuntimeLibrary="3"
- 				UsePrecompiledHeader="0"
- 				WarningLevel="3"
- 				Detect64BitPortabilityProblems="true"
- 				DebugInformationFormat="4"
- 				DisableSpecificWarnings="4244;4267"
- 			/>
- 			<Tool
- 				Name="VCManagedResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCPreLinkEventTool"
- 			/>
- 			<Tool
- 				Name="VCLinkerTool"
- 				AdditionalDependencies="ws2_32.lib"
- 				LinkIncremental="2"
- 				GenerateDebugInformation="true"
- 				SubSystem="1"
- 				TargetMachine="1"
- 			/>
- 			<Tool
- 				Name="VCALinkTool"
- 			/>
- 			<Tool
- 				Name="VCManifestTool"
- 			/>
- 			<Tool
- 				Name="VCXDCMakeTool"
- 			/>
- 			<Tool
- 				Name="VCBscMakeTool"
- 			/>
- 			<Tool
- 				Name="VCFxCopTool"
- 			/>
- 			<Tool
- 				Name="VCAppVerifierTool"
- 			/>
- 			<Tool
- 				Name="VCWebDeploymentTool"
- 			/>
- 			<Tool
- 				Name="VCPostBuildEventTool"
- 			/>
- 		</Configuration>
- 		<Configuration
- 			Name="Release|Win32"
- 			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
- 			IntermediateDirectory="$(ConfigurationName)"
- 			ConfigurationType="1"
- 			CharacterSet="0"
- 			WholeProgramOptimization="1"
- 			>
- 			<Tool
- 				Name="VCPreBuildEventTool"
- 			/>
- 			<Tool
- 				Name="VCCustomBuildTool"
- 			/>
- 			<Tool
- 				Name="VCXMLDataGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCWebServiceProxyGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCMIDLTool"
- 			/>
- 			<Tool
- 				Name="VCCLCompilerTool"
- 				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS"
- 				RuntimeLibrary="2"
- 				UsePrecompiledHeader="0"
- 				WarningLevel="3"
- 				Detect64BitPortabilityProblems="true"
- 				DebugInformationFormat="3"
- 				DisableSpecificWarnings="4244;4267"
- 			/>
- 			<Tool
- 				Name="VCManagedResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCPreLinkEventTool"
- 			/>
- 			<Tool
- 				Name="VCLinkerTool"
- 				AdditionalDependencies="ws2_32.lib"
- 				LinkIncremental="1"
- 				GenerateDebugInformation="true"
- 				SubSystem="1"
- 				OptimizeReferences="2"
- 				EnableCOMDATFolding="2"
- 				TargetMachine="1"
- 			/>
- 			<Tool
- 				Name="VCALinkTool"
- 			/>
- 			<Tool
- 				Name="VCManifestTool"
- 			/>
- 			<Tool
- 				Name="VCXDCMakeTool"
- 			/>
- 			<Tool
- 				Name="VCBscMakeTool"
- 			/>
- 			<Tool
- 				Name="VCFxCopTool"
- 			/>
- 			<Tool
- 				Name="VCAppVerifierTool"
- 			/>
- 			<Tool
- 				Name="VCWebDeploymentTool"
- 			/>
- 			<Tool
- 				Name="VCPostBuildEventTool"
- 			/>
- 		</Configuration>
- 	</Configurations>
- 	<References>
- 	</References>
- 	<Files>
- 		<Filter
- 			Name="Source Files"
- 			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
- 			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
- 			>
- 			<File
- 				RelativePath="..\..\common.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\os_win32.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\wpa_cli.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\wpa_ctrl.c"
- 				>
- 			</File>
- 		</Filter>
- 		<Filter
- 			Name="Header Files"
- 			Filter="h;hpp;hxx;hm;inl;inc;xsd"
- 			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
- 			>
- 		</Filter>
- 		<Filter
- 			Name="Resource Files"
- 			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
- 			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
- 			>
- 		</Filter>
- 	</Files>
- 	<Globals>
- 	</Globals>
- </VisualStudioProject>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/vs2005/wpa_passphrase/wpa_passphrase.vcproj wpa_view/wpa_suppl/vs2005/wpa_passphrase/wpa_passphrase.vcproj
*** wpa_supplicant-0.5.7/vs2005/wpa_passphrase/wpa_passphrase.vcproj	Mon Aug 28 07:18:08 2006
--- wpa_view/wpa_suppl/vs2005/wpa_passphrase/wpa_passphrase.vcproj	Thu Jan  1 02:00:00 1970
***************
*** 1,220 ****
- <?xml version="1.0" encoding="Windows-1252"?>
- <VisualStudioProject
- 	ProjectType="Visual C++"
- 	Version="8.00"
- 	Name="wpa_passphrase"
- 	ProjectGUID="{ADBE4EA8-F0C5-40C2-AE89-C56D0F2EC1DF}"
- 	RootNamespace="wpa_passphrase"
- 	Keyword="Win32Proj"
- 	>
- 	<Platforms>
- 		<Platform
- 			Name="Win32"
- 		/>
- 	</Platforms>
- 	<ToolFiles>
- 	</ToolFiles>
- 	<Configurations>
- 		<Configuration
- 			Name="Debug|Win32"
- 			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
- 			IntermediateDirectory="$(ConfigurationName)"
- 			ConfigurationType="1"
- 			CharacterSet="0"
- 			>
- 			<Tool
- 				Name="VCPreBuildEventTool"
- 			/>
- 			<Tool
- 				Name="VCCustomBuildTool"
- 			/>
- 			<Tool
- 				Name="VCXMLDataGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCWebServiceProxyGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCMIDLTool"
- 			/>
- 			<Tool
- 				Name="VCCLCompilerTool"
- 				Optimization="0"
- 				AdditionalIncludeDirectories="C:\dev\openssl\include"
- 				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS;INTERNAL_SHA1;INTERNAL_MD5"
- 				MinimalRebuild="true"
- 				BasicRuntimeChecks="3"
- 				RuntimeLibrary="3"
- 				UsePrecompiledHeader="0"
- 				WarningLevel="3"
- 				Detect64BitPortabilityProblems="true"
- 				DebugInformationFormat="4"
- 				DisableSpecificWarnings="4244;4267"
- 			/>
- 			<Tool
- 				Name="VCManagedResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCPreLinkEventTool"
- 			/>
- 			<Tool
- 				Name="VCLinkerTool"
- 				AdditionalDependencies="ws2_32.lib"
- 				LinkIncremental="2"
- 				AdditionalLibraryDirectories=""
- 				GenerateDebugInformation="true"
- 				SubSystem="1"
- 				TargetMachine="1"
- 			/>
- 			<Tool
- 				Name="VCALinkTool"
- 			/>
- 			<Tool
- 				Name="VCManifestTool"
- 			/>
- 			<Tool
- 				Name="VCXDCMakeTool"
- 			/>
- 			<Tool
- 				Name="VCBscMakeTool"
- 			/>
- 			<Tool
- 				Name="VCFxCopTool"
- 			/>
- 			<Tool
- 				Name="VCAppVerifierTool"
- 			/>
- 			<Tool
- 				Name="VCWebDeploymentTool"
- 			/>
- 			<Tool
- 				Name="VCPostBuildEventTool"
- 			/>
- 		</Configuration>
- 		<Configuration
- 			Name="Release|Win32"
- 			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
- 			IntermediateDirectory="$(ConfigurationName)"
- 			ConfigurationType="1"
- 			CharacterSet="0"
- 			WholeProgramOptimization="1"
- 			>
- 			<Tool
- 				Name="VCPreBuildEventTool"
- 			/>
- 			<Tool
- 				Name="VCCustomBuildTool"
- 			/>
- 			<Tool
- 				Name="VCXMLDataGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCWebServiceProxyGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCMIDLTool"
- 			/>
- 			<Tool
- 				Name="VCCLCompilerTool"
- 				AdditionalIncludeDirectories="C:\dev\openssl\include"
- 				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS;INTERNAL_SHA1;INTERNAL_MD5"
- 				RuntimeLibrary="2"
- 				UsePrecompiledHeader="0"
- 				WarningLevel="3"
- 				Detect64BitPortabilityProblems="true"
- 				DebugInformationFormat="3"
- 				DisableSpecificWarnings="4244;4267"
- 			/>
- 			<Tool
- 				Name="VCManagedResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCPreLinkEventTool"
- 			/>
- 			<Tool
- 				Name="VCLinkerTool"
- 				AdditionalDependencies="ws2_32.lib"
- 				LinkIncremental="1"
- 				GenerateDebugInformation="true"
- 				SubSystem="1"
- 				OptimizeReferences="2"
- 				EnableCOMDATFolding="2"
- 				TargetMachine="1"
- 			/>
- 			<Tool
- 				Name="VCALinkTool"
- 			/>
- 			<Tool
- 				Name="VCManifestTool"
- 			/>
- 			<Tool
- 				Name="VCXDCMakeTool"
- 			/>
- 			<Tool
- 				Name="VCBscMakeTool"
- 			/>
- 			<Tool
- 				Name="VCFxCopTool"
- 			/>
- 			<Tool
- 				Name="VCAppVerifierTool"
- 			/>
- 			<Tool
- 				Name="VCWebDeploymentTool"
- 			/>
- 			<Tool
- 				Name="VCPostBuildEventTool"
- 			/>
- 		</Configuration>
- 	</Configurations>
- 	<References>
- 	</References>
- 	<Files>
- 		<Filter
- 			Name="Source Files"
- 			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
- 			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
- 			>
- 			<File
- 				RelativePath="..\..\common.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\md5.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\os_win32.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\sha1.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\wpa_passphrase.c"
- 				>
- 			</File>
- 		</Filter>
- 		<Filter
- 			Name="Header Files"
- 			Filter="h;hpp;hxx;hm;inl;inc;xsd"
- 			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
- 			>
- 		</Filter>
- 		<Filter
- 			Name="Resource Files"
- 			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
- 			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
- 			>
- 		</Filter>
- 	</Files>
- 	<Globals>
- 	</Globals>
- </VisualStudioProject>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/vs2005/wpa_supplicant/wpa_supplicant.vcproj wpa_view/wpa_suppl/vs2005/wpa_supplicant/wpa_supplicant.vcproj
*** wpa_supplicant-0.5.7/vs2005/wpa_supplicant/wpa_supplicant.vcproj	Mon Aug 28 07:18:08 2006
--- wpa_view/wpa_suppl/vs2005/wpa_supplicant/wpa_supplicant.vcproj	Thu Jan  1 02:00:00 1970
***************
*** 1,365 ****
- <?xml version="1.0" encoding="Windows-1252"?>
- <VisualStudioProject
- 	ProjectType="Visual C++"
- 	Version="8.00"
- 	Name="wpa_supplicant"
- 	ProjectGUID="{8BCFDA77-AEDC-4168-8897-5B73105BBB87}"
- 	RootNamespace="wpa_supplicant"
- 	Keyword="Win32Proj"
- 	>
- 	<Platforms>
- 		<Platform
- 			Name="Win32"
- 		/>
- 	</Platforms>
- 	<ToolFiles>
- 	</ToolFiles>
- 	<Configurations>
- 		<Configuration
- 			Name="Debug|Win32"
- 			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
- 			IntermediateDirectory="$(ConfigurationName)"
- 			ConfigurationType="1"
- 			CharacterSet="0"
- 			>
- 			<Tool
- 				Name="VCPreBuildEventTool"
- 			/>
- 			<Tool
- 				Name="VCCustomBuildTool"
- 			/>
- 			<Tool
- 				Name="VCXMLDataGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCWebServiceProxyGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCMIDLTool"
- 			/>
- 			<Tool
- 				Name="VCCLCompilerTool"
- 				Optimization="0"
- 				AdditionalIncludeDirectories="C:\dev\WpdPack\include;C:\dev\openssl\include"
- 				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS"
- 				MinimalRebuild="true"
- 				BasicRuntimeChecks="3"
- 				RuntimeLibrary="3"
- 				UsePrecompiledHeader="0"
- 				WarningLevel="3"
- 				Detect64BitPortabilityProblems="true"
- 				DebugInformationFormat="4"
- 				DisableSpecificWarnings="4244;4267;4311"
- 			/>
- 			<Tool
- 				Name="VCManagedResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCPreLinkEventTool"
- 			/>
- 			<Tool
- 				Name="VCLinkerTool"
- 				AdditionalDependencies="wbemuuid.lib ws2_32.lib Crypt32.lib Winscard.lib Packet.lib wpcap.lib libeay32MT.lib ssleay32Mt.lib"
- 				LinkIncremental="2"
- 				AdditionalLibraryDirectories="C:\dev\WpdPack\lib;C:\dev\openssl\lib"
- 				GenerateDebugInformation="true"
- 				SubSystem="1"
- 				TargetMachine="1"
- 			/>
- 			<Tool
- 				Name="VCALinkTool"
- 			/>
- 			<Tool
- 				Name="VCManifestTool"
- 			/>
- 			<Tool
- 				Name="VCXDCMakeTool"
- 			/>
- 			<Tool
- 				Name="VCBscMakeTool"
- 			/>
- 			<Tool
- 				Name="VCFxCopTool"
- 			/>
- 			<Tool
- 				Name="VCAppVerifierTool"
- 			/>
- 			<Tool
- 				Name="VCWebDeploymentTool"
- 			/>
- 			<Tool
- 				Name="VCPostBuildEventTool"
- 			/>
- 		</Configuration>
- 		<Configuration
- 			Name="Release|Win32"
- 			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
- 			IntermediateDirectory="$(ConfigurationName)"
- 			ConfigurationType="1"
- 			CharacterSet="0"
- 			WholeProgramOptimization="1"
- 			>
- 			<Tool
- 				Name="VCPreBuildEventTool"
- 			/>
- 			<Tool
- 				Name="VCCustomBuildTool"
- 			/>
- 			<Tool
- 				Name="VCXMLDataGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCWebServiceProxyGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCMIDLTool"
- 			/>
- 			<Tool
- 				Name="VCCLCompilerTool"
- 				AdditionalIncludeDirectories="C:\dev\WpdPack\include;C:\dev\openssl\include"
- 				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS"
- 				RuntimeLibrary="2"
- 				UsePrecompiledHeader="0"
- 				WarningLevel="3"
- 				Detect64BitPortabilityProblems="true"
- 				DebugInformationFormat="3"
- 				DisableSpecificWarnings="4244;4267;4311"
- 			/>
- 			<Tool
- 				Name="VCManagedResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCPreLinkEventTool"
- 			/>
- 			<Tool
- 				Name="VCLinkerTool"
- 				AdditionalDependencies="wbemuuid.lib ws2_32.lib Crypt32.lib Winscard.lib Packet.lib wpcap.lib libeay32MT.lib ssleay32Mt.lib"
- 				LinkIncremental="1"
- 				AdditionalLibraryDirectories="C:\dev\WpdPack\lib;C:\dev\openssl\lib"
- 				GenerateDebugInformation="true"
- 				SubSystem="1"
- 				OptimizeReferences="2"
- 				EnableCOMDATFolding="2"
- 				TargetMachine="1"
- 			/>
- 			<Tool
- 				Name="VCALinkTool"
- 			/>
- 			<Tool
- 				Name="VCManifestTool"
- 			/>
- 			<Tool
- 				Name="VCXDCMakeTool"
- 			/>
- 			<Tool
- 				Name="VCBscMakeTool"
- 			/>
- 			<Tool
- 				Name="VCFxCopTool"
- 			/>
- 			<Tool
- 				Name="VCAppVerifierTool"
- 			/>
- 			<Tool
- 				Name="VCWebDeploymentTool"
- 			/>
- 			<Tool
- 				Name="VCPostBuildEventTool"
- 			/>
- 		</Configuration>
- 	</Configurations>
- 	<References>
- 	</References>
- 	<Files>
- 		<Filter
- 			Name="Source Files"
- 			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
- 			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
- 			>
- 			<File
- 				RelativePath="..\..\aes_wrap.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\base64.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\common.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\config.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\config_file.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\crypto.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\ctrl_iface.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\ctrl_iface_named_pipe.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\driver_ndis.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\driver_ndis_.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\drivers.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_gtc.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_leap.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_md5.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_methods.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_mschapv2.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_otp.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_peap.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_tls.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_tls_common.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_tlv.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_ttls.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eapol_sm.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eloop_win.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\events.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\l2_packet_winpcap.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\main.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\md4.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\md5.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\ms_funcs.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\ndis_events.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\os_win32.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\pcsc_funcs.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\pmksa_cache.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\preauth.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\rc4.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\sha1.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\tls_openssl.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\wpa.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\wpa_supplicant.c"
- 				>
- 			</File>
- 		</Filter>
- 		<Filter
- 			Name="Header Files"
- 			Filter="h;hpp;hxx;hm;inl;inc;xsd"
- 			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
- 			>
- 		</Filter>
- 		<Filter
- 			Name="Resource Files"
- 			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
- 			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
- 			>
- 		</Filter>
- 	</Files>
- 	<Globals>
- 	</Globals>
- </VisualStudioProject>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/vs2005/wpa_supplicant.sln wpa_view/wpa_suppl/vs2005/wpa_supplicant.sln
*** wpa_supplicant-0.5.7/vs2005/wpa_supplicant.sln	Sat Nov  4 07:18:31 2006
--- wpa_view/wpa_suppl/vs2005/wpa_supplicant.sln	Thu Jan  1 02:00:00 1970
***************
*** 1,52 ****
- 
- Microsoft Visual Studio Solution File, Format Version 9.00
- # Visual Studio 2005
- Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "wpa_supplicant", "wpa_supplicant\wpa_supplicant.vcproj", "{8BCFDA77-AEDC-4168-8897-5B73105BBB87}"
- EndProject
- Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "wpa_cli", "wpa_cli\wpa_cli.vcproj", "{E3A7B181-22CC-4DA3-8410-6AD69879A9EC}"
- EndProject
- Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "wpasvc", "wpasvc\wpasvc.vcproj", "{E2A4A85F-CA77-406D-8ABF-63EF94545ACC}"
- EndProject
- Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "wpa_passphrase", "wpa_passphrase\wpa_passphrase.vcproj", "{ADBE4EA8-F0C5-40C2-AE89-C56D0F2EC1DF}"
- EndProject
- Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "win_if_list", "win_if_list\win_if_list.vcproj", "{9E87CD9C-60CE-4533-85CF-85CA3A9BF26A}"
- EndProject
- Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "eapol_test", "eapol_test\eapol_test.vcproj", "{0E3F2C6D-1372-48D6-BCAB-E584917C4DE3}"
- EndProject
- Global
- 	GlobalSection(DPCodeReviewSolutionGUID) = preSolution
- 		DPCodeReviewSolutionGUID = {00000000-0000-0000-0000-000000000000}
- 	EndGlobalSection
- 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
- 		Debug|Win32 = Debug|Win32
- 		Release|Win32 = Release|Win32
- 	EndGlobalSection
- 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
- 		{8BCFDA77-AEDC-4168-8897-5B73105BBB87}.Debug|Win32.ActiveCfg = Debug|Win32
- 		{8BCFDA77-AEDC-4168-8897-5B73105BBB87}.Debug|Win32.Build.0 = Debug|Win32
- 		{8BCFDA77-AEDC-4168-8897-5B73105BBB87}.Release|Win32.ActiveCfg = Release|Win32
- 		{8BCFDA77-AEDC-4168-8897-5B73105BBB87}.Release|Win32.Build.0 = Release|Win32
- 		{E3A7B181-22CC-4DA3-8410-6AD69879A9EC}.Debug|Win32.ActiveCfg = Debug|Win32
- 		{E3A7B181-22CC-4DA3-8410-6AD69879A9EC}.Debug|Win32.Build.0 = Debug|Win32
- 		{E3A7B181-22CC-4DA3-8410-6AD69879A9EC}.Release|Win32.ActiveCfg = Release|Win32
- 		{E3A7B181-22CC-4DA3-8410-6AD69879A9EC}.Release|Win32.Build.0 = Release|Win32
- 		{E2A4A85F-CA77-406D-8ABF-63EF94545ACC}.Debug|Win32.ActiveCfg = Debug|Win32
- 		{E2A4A85F-CA77-406D-8ABF-63EF94545ACC}.Debug|Win32.Build.0 = Debug|Win32
- 		{E2A4A85F-CA77-406D-8ABF-63EF94545ACC}.Release|Win32.ActiveCfg = Release|Win32
- 		{E2A4A85F-CA77-406D-8ABF-63EF94545ACC}.Release|Win32.Build.0 = Release|Win32
- 		{ADBE4EA8-F0C5-40C2-AE89-C56D0F2EC1DF}.Debug|Win32.ActiveCfg = Debug|Win32
- 		{ADBE4EA8-F0C5-40C2-AE89-C56D0F2EC1DF}.Debug|Win32.Build.0 = Debug|Win32
- 		{ADBE4EA8-F0C5-40C2-AE89-C56D0F2EC1DF}.Release|Win32.ActiveCfg = Release|Win32
- 		{ADBE4EA8-F0C5-40C2-AE89-C56D0F2EC1DF}.Release|Win32.Build.0 = Release|Win32
- 		{9E87CD9C-60CE-4533-85CF-85CA3A9BF26A}.Debug|Win32.ActiveCfg = Debug|Win32
- 		{9E87CD9C-60CE-4533-85CF-85CA3A9BF26A}.Debug|Win32.Build.0 = Debug|Win32
- 		{9E87CD9C-60CE-4533-85CF-85CA3A9BF26A}.Release|Win32.ActiveCfg = Release|Win32
- 		{9E87CD9C-60CE-4533-85CF-85CA3A9BF26A}.Release|Win32.Build.0 = Release|Win32
- 		{0E3F2C6D-1372-48D6-BCAB-E584917C4DE3}.Debug|Win32.ActiveCfg = Debug|Win32
- 		{0E3F2C6D-1372-48D6-BCAB-E584917C4DE3}.Debug|Win32.Build.0 = Debug|Win32
- 		{0E3F2C6D-1372-48D6-BCAB-E584917C4DE3}.Release|Win32.ActiveCfg = Release|Win32
- 	EndGlobalSection
- 	GlobalSection(SolutionProperties) = preSolution
- 		HideSolutionNode = FALSE
- 	EndGlobalSection
- EndGlobal
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/vs2005/wpasvc/wpasvc.vcproj wpa_view/wpa_suppl/vs2005/wpasvc/wpasvc.vcproj
*** wpa_supplicant-0.5.7/vs2005/wpasvc/wpasvc.vcproj	Mon Aug 28 07:18:08 2006
--- wpa_view/wpa_suppl/vs2005/wpasvc/wpasvc.vcproj	Thu Jan  1 02:00:00 1970
***************
*** 1,361 ****
- <?xml version="1.0" encoding="Windows-1252"?>
- <VisualStudioProject
- 	ProjectType="Visual C++"
- 	Version="8.00"
- 	Name="wpasvc"
- 	ProjectGUID="{E2A4A85F-CA77-406D-8ABF-63EF94545ACC}"
- 	RootNamespace="wpasvc"
- 	Keyword="Win32Proj"
- 	>
- 	<Platforms>
- 		<Platform
- 			Name="Win32"
- 		/>
- 	</Platforms>
- 	<ToolFiles>
- 	</ToolFiles>
- 	<Configurations>
- 		<Configuration
- 			Name="Debug|Win32"
- 			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
- 			IntermediateDirectory="$(ConfigurationName)"
- 			ConfigurationType="1"
- 			CharacterSet="0"
- 			>
- 			<Tool
- 				Name="VCPreBuildEventTool"
- 			/>
- 			<Tool
- 				Name="VCCustomBuildTool"
- 			/>
- 			<Tool
- 				Name="VCXMLDataGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCWebServiceProxyGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCMIDLTool"
- 			/>
- 			<Tool
- 				Name="VCCLCompilerTool"
- 				Optimization="0"
- 				AdditionalIncludeDirectories="C:\dev\WpdPack\include;C:\dev\openssl\include"
- 				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS"
- 				MinimalRebuild="true"
- 				BasicRuntimeChecks="3"
- 				RuntimeLibrary="3"
- 				UsePrecompiledHeader="0"
- 				WarningLevel="3"
- 				Detect64BitPortabilityProblems="true"
- 				DebugInformationFormat="4"
- 				DisableSpecificWarnings="4244;4267;4311"
- 			/>
- 			<Tool
- 				Name="VCManagedResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCPreLinkEventTool"
- 			/>
- 			<Tool
- 				Name="VCLinkerTool"
- 				AdditionalDependencies="wbemuuid.lib ws2_32.lib Crypt32.lib Winscard.lib Packet.lib wpcap.lib libeay32MT.lib ssleay32Mt.lib"
- 				LinkIncremental="2"
- 				AdditionalLibraryDirectories="C:\dev\WpdPack\lib;C:\dev\openssl\lib"
- 				GenerateDebugInformation="true"
- 				SubSystem="1"
- 				TargetMachine="1"
- 			/>
- 			<Tool
- 				Name="VCALinkTool"
- 			/>
- 			<Tool
- 				Name="VCManifestTool"
- 			/>
- 			<Tool
- 				Name="VCXDCMakeTool"
- 			/>
- 			<Tool
- 				Name="VCBscMakeTool"
- 			/>
- 			<Tool
- 				Name="VCFxCopTool"
- 			/>
- 			<Tool
- 				Name="VCAppVerifierTool"
- 			/>
- 			<Tool
- 				Name="VCWebDeploymentTool"
- 			/>
- 			<Tool
- 				Name="VCPostBuildEventTool"
- 			/>
- 		</Configuration>
- 		<Configuration
- 			Name="Release|Win32"
- 			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
- 			IntermediateDirectory="$(ConfigurationName)"
- 			ConfigurationType="1"
- 			CharacterSet="0"
- 			WholeProgramOptimization="1"
- 			>
- 			<Tool
- 				Name="VCPreBuildEventTool"
- 			/>
- 			<Tool
- 				Name="VCCustomBuildTool"
- 			/>
- 			<Tool
- 				Name="VCXMLDataGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCWebServiceProxyGeneratorTool"
- 			/>
- 			<Tool
- 				Name="VCMIDLTool"
- 			/>
- 			<Tool
- 				Name="VCCLCompilerTool"
- 				AdditionalIncludeDirectories="C:\dev\WpdPack\include;C:\dev\openssl\include"
- 				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;CONFIG_WIN32_DEFAULTS"
- 				RuntimeLibrary="2"
- 				UsePrecompiledHeader="0"
- 				WarningLevel="3"
- 				Detect64BitPortabilityProblems="true"
- 				DebugInformationFormat="3"
- 				DisableSpecificWarnings="4244;4267;4311"
- 			/>
- 			<Tool
- 				Name="VCManagedResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCResourceCompilerTool"
- 			/>
- 			<Tool
- 				Name="VCPreLinkEventTool"
- 			/>
- 			<Tool
- 				Name="VCLinkerTool"
- 				AdditionalDependencies="wbemuuid.lib ws2_32.lib Crypt32.lib Winscard.lib Packet.lib wpcap.lib libeay32MT.lib ssleay32Mt.lib"
- 				LinkIncremental="1"
- 				AdditionalLibraryDirectories="C:\dev\WpdPack\lib;C:\dev\openssl\lib"
- 				GenerateDebugInformation="true"
- 				SubSystem="1"
- 				OptimizeReferences="2"
- 				EnableCOMDATFolding="2"
- 				TargetMachine="1"
- 			/>
- 			<Tool
- 				Name="VCALinkTool"
- 			/>
- 			<Tool
- 				Name="VCManifestTool"
- 			/>
- 			<Tool
- 				Name="VCXDCMakeTool"
- 			/>
- 			<Tool
- 				Name="VCBscMakeTool"
- 			/>
- 			<Tool
- 				Name="VCFxCopTool"
- 			/>
- 			<Tool
- 				Name="VCAppVerifierTool"
- 			/>
- 			<Tool
- 				Name="VCWebDeploymentTool"
- 			/>
- 			<Tool
- 				Name="VCPostBuildEventTool"
- 			/>
- 		</Configuration>
- 	</Configurations>
- 	<References>
- 	</References>
- 	<Files>
- 		<Filter
- 			Name="Source Files"
- 			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
- 			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
- 			>
- 			<File
- 				RelativePath="..\..\aes_wrap.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\common.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\config.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\config_winreg.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\crypto.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\ctrl_iface.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\ctrl_iface_named_pipe.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\driver_ndis.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\driver_ndis_.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\drivers.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_gtc.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_leap.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_md5.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_methods.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_mschapv2.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_otp.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_peap.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_tls.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_tls_common.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_tlv.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eap_ttls.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eapol_sm.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\eloop_win.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\events.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\l2_packet_winpcap.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\main_winsvc.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\md4.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\md5.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\ms_funcs.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\ndis_events.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\os_win32.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\pcsc_funcs.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\pmksa_cache.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\preauth.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\rc4.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\sha1.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\tls_openssl.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\wpa.c"
- 				>
- 			</File>
- 			<File
- 				RelativePath="..\..\wpa_supplicant.c"
- 				>
- 			</File>
- 		</Filter>
- 		<Filter
- 			Name="Header Files"
- 			Filter="h;hpp;hxx;hm;inl;inc;xsd"
- 			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
- 			>
- 		</Filter>
- 		<Filter
- 			Name="Resource Files"
- 			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
- 			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
- 			>
- 		</Filter>
- 	</Files>
- 	<Globals>
- 	</Globals>
- </VisualStudioProject>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/win_example.reg wpa_view/wpa_suppl/win_example.reg
*** wpa_supplicant-0.5.7/win_example.reg	Sun Aug 27 02:22:02 2006
--- wpa_view/wpa_suppl/win_example.reg	Thu Jan  1 02:00:00 1970
***************
*** 1,32 ****
- REGEDIT4
- 
- [HKEY_LOCAL_MACHINE\SOFTWARE\wpa_supplicant]
- "debug_level"=dword:00000000
- "debug_show_keys"=dword:00000001
- "debug_use_file"=dword:00000000
- 
- [HKEY_LOCAL_MACHINE\SOFTWARE\wpa_supplicant\configs]
- 
- [HKEY_LOCAL_MACHINE\SOFTWARE\wpa_supplicant\configs\test]
- "ap_scan"=dword:00000002
- 
- [HKEY_LOCAL_MACHINE\SOFTWARE\wpa_supplicant\configs\test\blobs]
- "testblob"=hex:01,02,03,04,05
- 
- [HKEY_LOCAL_MACHINE\SOFTWARE\wpa_supplicant\configs\test\networks]
- 
- [HKEY_LOCAL_MACHINE\SOFTWARE\wpa_supplicant\configs\test\networks\0000]
- "ssid"="\"example network\""
- "key_mgmt"="WPA-PSK"
- "psk"="\"secret password\""
- "pairwise"="CCMP"
- "group"="CCMP"
- "proto"="WPA"
- 
- [HKEY_LOCAL_MACHINE\SOFTWARE\wpa_supplicant\interfaces]
- 
- [HKEY_LOCAL_MACHINE\SOFTWARE\wpa_supplicant\interfaces\0000]
- "adapter"="{A7627643-C310-49E5-BD89-7E77709C04AB}"
- "config"="test"
- "ctrl_interface"=""
- 
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa.c wpa_view/wpa_suppl/wpa.c
*** wpa_supplicant-0.5.7/wpa.c	Wed Dec 27 05:55:17 2006
--- wpa_view/wpa_suppl/wpa.c	Wed Jun  9 13:30:52 2010
***************
*** 666,673 ****
  	os_memcpy(hdr->oui, WPA_OUI_TYPE, WPA_SELECTOR_LEN);
  	WPA_PUT_LE16(hdr->version, WPA_VERSION);
  	pos = (u8 *) (hdr + 1);
! 
! 	if (group_cipher == WPA_CIPHER_CCMP) {
  		os_memcpy(pos, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN);
  	} else if (group_cipher == WPA_CIPHER_TKIP) {
  		os_memcpy(pos, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN);
--- 666,675 ----
  	os_memcpy(hdr->oui, WPA_OUI_TYPE, WPA_SELECTOR_LEN);
  	WPA_PUT_LE16(hdr->version, WPA_VERSION);
  	pos = (u8 *) (hdr + 1);
!     
!     if (group_cipher == (WPA_CIPHER_CCMP | WPA_CIPHER_TKIP)) { // TI for Mix Mode
!         os_memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
! 	} else if (group_cipher == WPA_CIPHER_CCMP) {
  		os_memcpy(pos, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN);
  	} else if (group_cipher == WPA_CIPHER_TKIP) {
  		os_memcpy(pos, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN);
***************
*** 744,750 ****
  	WPA_PUT_LE16(hdr->version, RSN_VERSION);
  	pos = (u8 *) (hdr + 1);
  
! 	if (group_cipher == WPA_CIPHER_CCMP) {
  		os_memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
  	} else if (group_cipher == WPA_CIPHER_TKIP) {
  		os_memcpy(pos, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN);
--- 746,754 ----
  	WPA_PUT_LE16(hdr->version, RSN_VERSION);
  	pos = (u8 *) (hdr + 1);
  
!     if (group_cipher == (WPA_CIPHER_CCMP | WPA_CIPHER_TKIP)) {
!         os_memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
! 	}else if (group_cipher == WPA_CIPHER_CCMP) {
  		os_memcpy(pos, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN);
  	} else if (group_cipher == WPA_CIPHER_TKIP) {
  		os_memcpy(pos, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN);
***************
*** 1651,1656 ****
--- 1655,1669 ----
  	int ret = 0;
  
  	switch (group_cipher) {
+     case (WPA_CIPHER_TKIP | WPA_CIPHER_CCMP):
+            if (keylen != 32 && keylen != 16) {
+ 			ret = -1;
+ 			break;
+ 		}
+ 		*key_rsc_len = 6;
+ 		*alg = WPA_ALG_TKIP | WPA_ALG_CCMP;
+ 		break;
+ 
  	case WPA_CIPHER_CCMP:
  		if (keylen != 16 || maxkeylen < 16) {
  			ret = -1;
***************
*** 2178,2186 ****
  			  (u8 *) &error, sizeof(error));
  
  	if (peer) {
! 		wpa_printf(MSG_DEBUG, "RSN: Sending EAPOL-Key SMK Error (peer "
! 			   MACSTR " mui %d error_type %d)",
! 			   MAC2STR(peer), mui, error_type);
  	} else {
  		wpa_printf(MSG_DEBUG, "RSN: Sending EAPOL-Key SMK Error "
  			   "(mui %d error_type %d)", mui, error_type);
--- 2191,2199 ----
  			  (u8 *) &error, sizeof(error));
  
  	if (peer) {
! 	wpa_printf(MSG_DEBUG, "RSN: Sending EAPOL-Key SMK Error (peer "
! 		   MACSTR " mui %d error_type %d)",
! 		   MAC2STR(peer), mui, error_type);
  	} else {
  		wpa_printf(MSG_DEBUG, "RSN: Sending EAPOL-Key SMK Error "
  			   "(mui %d error_type %d)", mui, error_type);
diff -BNcr wpa_supplicant-0.5.7/wpa_gui/.cvsignore wpa_view/wpa_suppl/wpa_gui/.cvsignore
*** wpa_supplicant-0.5.7/wpa_gui/.cvsignore	Thu May 19 05:24:52 2005
--- wpa_view/wpa_suppl/wpa_gui/.cvsignore	Thu Jan  1 02:00:00 1970
***************
*** 1,5 ****
- .moc
- .obj
- .ui
- Makefile
- wpa_gui
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui/eventhistory.ui wpa_view/wpa_suppl/wpa_gui/eventhistory.ui
*** wpa_supplicant-0.5.7/wpa_gui/eventhistory.ui	Mon May 23 05:40:07 2005
--- wpa_view/wpa_suppl/wpa_gui/eventhistory.ui	Thu Jan  1 02:00:00 1970
***************
*** 1,125 ****
- <!DOCTYPE UI><UI version="3.3" stdsetdef="1">
- <class>EventHistory</class>
- <widget class="QDialog">
-     <property name="name">
-         <cstring>EventHistory</cstring>
-     </property>
-     <property name="geometry">
-         <rect>
-             <x>0</x>
-             <y>0</y>
-             <width>533</width>
-             <height>285</height>
-         </rect>
-     </property>
-     <property name="caption">
-         <string>Event history</string>
-     </property>
-     <vbox>
-         <property name="name">
-             <cstring>unnamed</cstring>
-         </property>
-         <widget class="QListView">
-             <column>
-                 <property name="text">
-                     <string>Timestamp</string>
-                 </property>
-                 <property name="clickable">
-                     <bool>true</bool>
-                 </property>
-                 <property name="resizable">
-                     <bool>true</bool>
-                 </property>
-             </column>
-             <column>
-                 <property name="text">
-                     <string>Message</string>
-                 </property>
-                 <property name="clickable">
-                     <bool>true</bool>
-                 </property>
-                 <property name="resizable">
-                     <bool>true</bool>
-                 </property>
-             </column>
-             <property name="name">
-                 <cstring>eventListView</cstring>
-             </property>
-             <property name="sizePolicy">
-                 <sizepolicy>
-                     <hsizetype>7</hsizetype>
-                     <vsizetype>7</vsizetype>
-                     <horstretch>0</horstretch>
-                     <verstretch>0</verstretch>
-                 </sizepolicy>
-             </property>
-             <property name="resizePolicy">
-                 <enum>Manual</enum>
-             </property>
-             <property name="selectionMode">
-                 <enum>NoSelection</enum>
-             </property>
-             <property name="resizeMode">
-                 <enum>LastColumn</enum>
-             </property>
-         </widget>
-         <widget class="QLayoutWidget">
-             <property name="name">
-                 <cstring>layout30</cstring>
-             </property>
-             <hbox>
-                 <property name="name">
-                     <cstring>unnamed</cstring>
-                 </property>
-                 <spacer>
-                     <property name="name">
-                         <cstring>spacer3</cstring>
-                     </property>
-                     <property name="orientation">
-                         <enum>Horizontal</enum>
-                     </property>
-                     <property name="sizeType">
-                         <enum>Expanding</enum>
-                     </property>
-                     <property name="sizeHint">
-                         <size>
-                             <width>20</width>
-                             <height>20</height>
-                         </size>
-                     </property>
-                 </spacer>
-                 <widget class="QPushButton">
-                     <property name="name">
-                         <cstring>closeButton</cstring>
-                     </property>
-                     <property name="text">
-                         <string>Close</string>
-                     </property>
-                 </widget>
-             </hbox>
-         </widget>
-     </vbox>
- </widget>
- <connections>
-     <connection>
-         <sender>closeButton</sender>
-         <signal>clicked()</signal>
-         <receiver>EventHistory</receiver>
-         <slot>close()</slot>
-     </connection>
- </connections>
- <includes>
-     <include location="local" impldecl="in declaration">wpamsg.h</include>
-     <include location="local" impldecl="in implementation">eventhistory.ui.h</include>
- </includes>
- <slots>
-     <slot>addEvents( WpaMsgList msgs )</slot>
-     <slot>addEvent( WpaMsg msg )</slot>
- </slots>
- <functions>
-     <function access="private" specifier="non virtual">init()</function>
-     <function access="private" specifier="non virtual">destroy()</function>
- </functions>
- <pixmapinproject/>
- <layoutdefaults spacing="6" margin="11"/>
- </UI>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui/eventhistory.ui.h wpa_view/wpa_suppl/wpa_gui/eventhistory.ui.h
*** wpa_supplicant-0.5.7/wpa_gui/eventhistory.ui.h	Sun Aug 27 18:39:23 2006
--- wpa_view/wpa_suppl/wpa_gui/eventhistory.ui.h	Thu Jan  1 02:00:00 1970
***************
*** 1,41 ****
- /****************************************************************************
- ** ui.h extension file, included from the uic-generated form implementation.
- **
- ** If you want to add, delete, or rename functions or slots, use
- ** Qt Designer to update this file, preserving your code.
- **
- ** You should not define a constructor or destructor in this file.
- ** Instead, write your code in functions called init() and destroy().
- ** These will automatically be called by the form's constructor and
- ** destructor.
- *****************************************************************************/
- 
- void EventHistory::init()
- {
- }
- 
- 
- void EventHistory::destroy()
- {
- }
- 
- 
- void EventHistory::addEvents(WpaMsgList msgs)
- {
-     WpaMsgList::iterator it;
-     for (it = msgs.begin(); it != msgs.end(); it++) {
- 	addEvent(*it);
-     }
- }
- 
- 
- void EventHistory::addEvent(WpaMsg msg)
- {
-     Q3ListViewItem *item;
-     item = new Q3ListViewItem(eventListView,
- 			     msg.getTimestamp().toString("yyyy-MM-dd hh:mm:ss.zzz"),
- 			     msg.getMsg());
-     if (item == NULL)
- 	return;
-     eventListView->setSelected(item, false);
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui/main.cpp wpa_view/wpa_suppl/wpa_gui/main.cpp
*** wpa_supplicant-0.5.7/wpa_gui/main.cpp	Sat Jul 23 20:28:54 2005
--- wpa_view/wpa_suppl/wpa_gui/main.cpp	Thu Jan  1 02:00:00 1970
***************
*** 1,30 ****
- #ifdef CONFIG_NATIVE_WINDOWS
- #include <winsock.h>
- #endif /* CONFIG_NATIVE_WINDOWS */
- #include <qapplication.h>
- #include "wpagui.h"
- 
- int main( int argc, char ** argv )
- {
-     QApplication a( argc, argv );
-     WpaGui w;
-     int ret;
- 
- #ifdef CONFIG_NATIVE_WINDOWS
-     WSADATA wsaData;
-     if (WSAStartup(MAKEWORD(2, 0), &wsaData)) {
- 	printf("Could not find a usable WinSock.dll\n");
- 	return -1;
-     }
- #endif /* CONFIG_NATIVE_WINDOWS */
- 
-     w.show();
-     a.connect( &a, SIGNAL( lastWindowClosed() ), &a, SLOT( quit() ) );
-     ret = a.exec();
- 
- #ifdef CONFIG_NATIVE_WINDOWS
-     WSACleanup();
- #endif /* CONFIG_NATIVE_WINDOWS */
- 
-     return ret;
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui/networkconfig.ui wpa_view/wpa_suppl/wpa_gui/networkconfig.ui
*** wpa_supplicant-0.5.7/wpa_gui/networkconfig.ui	Sun Nov 20 05:05:46 2005
--- wpa_view/wpa_suppl/wpa_gui/networkconfig.ui	Thu Jan  1 02:00:00 1970
***************
*** 1,455 ****
- <!DOCTYPE UI><UI version="3.3" stdsetdef="1">
- <class>NetworkConfig</class>
- <widget class="QDialog">
-     <property name="name">
-         <cstring>NetworkConfig</cstring>
-     </property>
-     <property name="geometry">
-         <rect>
-             <x>0</x>
-             <y>0</y>
-             <width>380</width>
-             <height>413</height>
-         </rect>
-     </property>
-     <property name="caption">
-         <string>NetworkConfig</string>
-     </property>
-     <grid>
-         <property name="name">
-             <cstring>unnamed</cstring>
-         </property>
-         <widget class="QPushButton" row="1" column="3">
-             <property name="name">
-                 <cstring>cancelButton</cstring>
-             </property>
-             <property name="text">
-                 <string>Cancel</string>
-             </property>
-         </widget>
-         <widget class="QFrame" row="0" column="0" rowspan="1" colspan="4">
-             <property name="name">
-                 <cstring>frame9</cstring>
-             </property>
-             <property name="frameShape">
-                 <enum>StyledPanel</enum>
-             </property>
-             <property name="frameShadow">
-                 <enum>Raised</enum>
-             </property>
-             <grid>
-                 <property name="name">
-                     <cstring>unnamed</cstring>
-                 </property>
-                 <widget class="QLabel" row="0" column="0">
-                     <property name="name">
-                         <cstring>textLabel1</cstring>
-                     </property>
-                     <property name="text">
-                         <string>SSID</string>
-                     </property>
-                 </widget>
-                 <widget class="QLineEdit" row="0" column="1">
-                     <property name="name">
-                         <cstring>ssidEdit</cstring>
-                     </property>
-                     <property name="text">
-                         <string></string>
-                     </property>
-                     <property name="toolTip" stdset="0">
-                         <string>Network name (Service Set IDentifier)</string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="1" column="0">
-                     <property name="name">
-                         <cstring>textLabel2</cstring>
-                     </property>
-                     <property name="text">
-                         <string>Authentication</string>
-                     </property>
-                 </widget>
-                 <widget class="QComboBox" row="1" column="1">
-                     <item>
-                         <property name="text">
-                             <string>Plaintext or static WEP</string>
-                         </property>
-                     </item>
-                     <item>
-                         <property name="text">
-                             <string>IEEE 802.1X</string>
-                         </property>
-                     </item>
-                     <item>
-                         <property name="text">
-                             <string>WPA-Personal (PSK)</string>
-                         </property>
-                     </item>
-                     <item>
-                         <property name="text">
-                             <string>WPA-Enterprise (EAP)</string>
-                         </property>
-                     </item>
-                     <item>
-                         <property name="text">
-                             <string>WPA2-Personal (PSK)</string>
-                         </property>
-                     </item>
-                     <item>
-                         <property name="text">
-                             <string>WPA2-Enterprise (EAP)</string>
-                         </property>
-                     </item>
-                     <property name="name">
-                         <cstring>authSelect</cstring>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="2" column="0">
-                     <property name="name">
-                         <cstring>textLabel3</cstring>
-                     </property>
-                     <property name="text">
-                         <string>Encryption</string>
-                     </property>
-                 </widget>
-                 <widget class="QComboBox" row="2" column="1">
-                     <item>
-                         <property name="text">
-                             <string>None</string>
-                         </property>
-                     </item>
-                     <item>
-                         <property name="text">
-                             <string>WEP</string>
-                         </property>
-                     </item>
-                     <item>
-                         <property name="text">
-                             <string>TKIP</string>
-                         </property>
-                     </item>
-                     <item>
-                         <property name="text">
-                             <string>CCMP</string>
-                         </property>
-                     </item>
-                     <property name="name">
-                         <cstring>encrSelect</cstring>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="3" column="0">
-                     <property name="name">
-                         <cstring>textLabel4</cstring>
-                     </property>
-                     <property name="text">
-                         <string>PSK</string>
-                     </property>
-                 </widget>
-                 <widget class="QLineEdit" row="3" column="1">
-                     <property name="name">
-                         <cstring>pskEdit</cstring>
-                     </property>
-                     <property name="enabled">
-                         <bool>false</bool>
-                     </property>
-                     <property name="echoMode">
-                         <enum>Password</enum>
-                     </property>
-                     <property name="toolTip" stdset="0">
-                         <string>WPA/WPA2 pre-shared key or passphrase</string>
-                     </property>
-                     <property name="whatsThis" stdset="0">
-                         <string></string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="4" column="0">
-                     <property name="name">
-                         <cstring>textLabel5</cstring>
-                     </property>
-                     <property name="text">
-                         <string>EAP method</string>
-                     </property>
-                 </widget>
-                 <widget class="QComboBox" row="4" column="1">
-                     <property name="name">
-                         <cstring>eapSelect</cstring>
-                     </property>
-                     <property name="enabled">
-                         <bool>false</bool>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="5" column="0">
-                     <property name="name">
-                         <cstring>textLabel6</cstring>
-                     </property>
-                     <property name="text">
-                         <string>Identity</string>
-                     </property>
-                 </widget>
-                 <widget class="QLineEdit" row="5" column="1">
-                     <property name="name">
-                         <cstring>identityEdit</cstring>
-                     </property>
-                     <property name="enabled">
-                         <bool>false</bool>
-                     </property>
-                     <property name="toolTip" stdset="0">
-                         <string>Username/Identity for EAP methods</string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="6" column="0">
-                     <property name="name">
-                         <cstring>textLabel7</cstring>
-                     </property>
-                     <property name="text">
-                         <string>Password</string>
-                     </property>
-                 </widget>
-                 <widget class="QLineEdit" row="6" column="1">
-                     <property name="name">
-                         <cstring>passwordEdit</cstring>
-                     </property>
-                     <property name="enabled">
-                         <bool>false</bool>
-                     </property>
-                     <property name="echoMode">
-                         <enum>Password</enum>
-                     </property>
-                     <property name="toolTip" stdset="0">
-                         <string>Password for EAP methods</string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="7" column="0">
-                     <property name="name">
-                         <cstring>textLabel1_2</cstring>
-                     </property>
-                     <property name="text">
-                         <string>CA certificate</string>
-                     </property>
-                 </widget>
-                 <widget class="QLineEdit" row="7" column="1">
-                     <property name="name">
-                         <cstring>cacertEdit</cstring>
-                     </property>
-                     <property name="enabled">
-                         <bool>false</bool>
-                     </property>
-                 </widget>
-                 <widget class="QButtonGroup" row="8" column="0" rowspan="1" colspan="2">
-                     <property name="name">
-                         <cstring>buttonGroup1</cstring>
-                     </property>
-                     <property name="enabled">
-                         <bool>true</bool>
-                     </property>
-                     <property name="title">
-                         <string>WEP keys</string>
-                     </property>
-                     <grid>
-                         <property name="name">
-                             <cstring>unnamed</cstring>
-                         </property>
-                         <widget class="QRadioButton" row="0" column="0">
-                             <property name="name">
-                                 <cstring>wep0Radio</cstring>
-                             </property>
-                             <property name="enabled">
-                                 <bool>false</bool>
-                             </property>
-                             <property name="text">
-                                 <string>key 0</string>
-                             </property>
-                         </widget>
-                         <widget class="QRadioButton" row="1" column="0">
-                             <property name="name">
-                                 <cstring>wep1Radio</cstring>
-                             </property>
-                             <property name="enabled">
-                                 <bool>false</bool>
-                             </property>
-                             <property name="text">
-                                 <string>key 1</string>
-                             </property>
-                         </widget>
-                         <widget class="QRadioButton" row="3" column="0">
-                             <property name="name">
-                                 <cstring>wep3Radio</cstring>
-                             </property>
-                             <property name="enabled">
-                                 <bool>false</bool>
-                             </property>
-                             <property name="text">
-                                 <string>key 3</string>
-                             </property>
-                         </widget>
-                         <widget class="QRadioButton" row="2" column="0">
-                             <property name="name">
-                                 <cstring>wep2Radio</cstring>
-                             </property>
-                             <property name="enabled">
-                                 <bool>false</bool>
-                             </property>
-                             <property name="text">
-                                 <string>key 2</string>
-                             </property>
-                         </widget>
-                         <widget class="QLineEdit" row="0" column="1">
-                             <property name="name">
-                                 <cstring>wep0Edit</cstring>
-                             </property>
-                             <property name="enabled">
-                                 <bool>false</bool>
-                             </property>
-                         </widget>
-                         <widget class="QLineEdit" row="1" column="1">
-                             <property name="name">
-                                 <cstring>wep1Edit</cstring>
-                             </property>
-                             <property name="enabled">
-                                 <bool>false</bool>
-                             </property>
-                         </widget>
-                         <widget class="QLineEdit" row="2" column="1">
-                             <property name="name">
-                                 <cstring>wep2Edit</cstring>
-                             </property>
-                             <property name="enabled">
-                                 <bool>false</bool>
-                             </property>
-                         </widget>
-                         <widget class="QLineEdit" row="3" column="1">
-                             <property name="name">
-                                 <cstring>wep3Edit</cstring>
-                             </property>
-                             <property name="enabled">
-                                 <bool>false</bool>
-                             </property>
-                         </widget>
-                     </grid>
-                 </widget>
-             </grid>
-         </widget>
-         <spacer row="1" column="0">
-             <property name="name">
-                 <cstring>spacer5</cstring>
-             </property>
-             <property name="orientation">
-                 <enum>Horizontal</enum>
-             </property>
-             <property name="sizeType">
-                 <enum>Expanding</enum>
-             </property>
-             <property name="sizeHint">
-                 <size>
-                     <width>130</width>
-                     <height>20</height>
-                 </size>
-             </property>
-         </spacer>
-         <widget class="QPushButton" row="1" column="1">
-             <property name="name">
-                 <cstring>addButton</cstring>
-             </property>
-             <property name="text">
-                 <string>Add</string>
-             </property>
-         </widget>
-         <widget class="QPushButton" row="1" column="2">
-             <property name="name">
-                 <cstring>removeButton</cstring>
-             </property>
-             <property name="enabled">
-                 <bool>false</bool>
-             </property>
-             <property name="text">
-                 <string>Remove</string>
-             </property>
-         </widget>
-     </grid>
- </widget>
- <connections>
-     <connection>
-         <sender>authSelect</sender>
-         <signal>activated(int)</signal>
-         <receiver>NetworkConfig</receiver>
-         <slot>authChanged(int)</slot>
-     </connection>
-     <connection>
-         <sender>cancelButton</sender>
-         <signal>clicked()</signal>
-         <receiver>NetworkConfig</receiver>
-         <slot>close()</slot>
-     </connection>
-     <connection>
-         <sender>addButton</sender>
-         <signal>clicked()</signal>
-         <receiver>NetworkConfig</receiver>
-         <slot>addNetwork()</slot>
-     </connection>
-     <connection>
-         <sender>encrSelect</sender>
-         <signal>activated(const QString&amp;)</signal>
-         <receiver>NetworkConfig</receiver>
-         <slot>encrChanged(const QString&amp;)</slot>
-     </connection>
-     <connection>
-         <sender>removeButton</sender>
-         <signal>clicked()</signal>
-         <receiver>NetworkConfig</receiver>
-         <slot>removeNetwork()</slot>
-     </connection>
- </connections>
- <tabstops>
-     <tabstop>ssidEdit</tabstop>
-     <tabstop>authSelect</tabstop>
-     <tabstop>encrSelect</tabstop>
-     <tabstop>pskEdit</tabstop>
-     <tabstop>eapSelect</tabstop>
-     <tabstop>identityEdit</tabstop>
-     <tabstop>passwordEdit</tabstop>
-     <tabstop>cacertEdit</tabstop>
-     <tabstop>wep0Radio</tabstop>
-     <tabstop>wep1Radio</tabstop>
-     <tabstop>wep2Radio</tabstop>
-     <tabstop>wep3Radio</tabstop>
-     <tabstop>wep0Edit</tabstop>
-     <tabstop>wep1Edit</tabstop>
-     <tabstop>wep2Edit</tabstop>
-     <tabstop>wep3Edit</tabstop>
-     <tabstop>addButton</tabstop>
-     <tabstop>removeButton</tabstop>
-     <tabstop>cancelButton</tabstop>
- </tabstops>
- <includes>
-     <include location="global" impldecl="in declaration">qlistview.h</include>
-     <include location="global" impldecl="in implementation">qmessagebox.h</include>
-     <include location="local" impldecl="in implementation">wpagui.h</include>
-     <include location="local" impldecl="in implementation">networkconfig.ui.h</include>
- </includes>
- <forwards>
-     <forward>class WpaGui;</forward>
- </forwards>
- <variables>
-     <variable access="private">WpaGui *wpagui;</variable>
-     <variable access="private">int edit_network_id;</variable>
-     <variable access="private">bool new_network;</variable>
- </variables>
- <slots>
-     <slot>authChanged( int sel )</slot>
-     <slot>addNetwork()</slot>
-     <slot>encrChanged( const QString &amp; sel )</slot>
-     <slot>writeWepKey( int network_id, QLineEdit * edit, int id )</slot>
-     <slot>removeNetwork()</slot>
- </slots>
- <functions>
-     <function access="private" specifier="non virtual">init()</function>
-     <function>paramsFromScanResults( QListViewItem * sel )</function>
-     <function>setWpaGui( WpaGui * _wpagui )</function>
-     <function returnType="int">setNetworkParam( int id, const char * field, const char * value, bool quote )</function>
-     <function access="private">wepEnabled( bool enabled )</function>
-     <function>paramsFromConfig( int network_id )</function>
-     <function>newNetwork()</function>
-     <function access="private">getEapCapa()</function>
- </functions>
- <pixmapinproject/>
- <layoutdefaults spacing="6" margin="11"/>
- </UI>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui/networkconfig.ui.h wpa_view/wpa_suppl/wpa_gui/networkconfig.ui.h
*** wpa_supplicant-0.5.7/wpa_gui/networkconfig.ui.h	Sun Dec 10 02:38:48 2006
--- wpa_view/wpa_suppl/wpa_gui/networkconfig.ui.h	Thu Jan  1 02:00:00 1970
***************
*** 1,537 ****
- /****************************************************************************
- ** ui.h extension file, included from the uic-generated form implementation.
- **
- ** If you want to add, delete, or rename functions or slots, use
- ** Qt Designer to update this file, preserving your code.
- **
- ** You should not define a constructor or destructor in this file.
- ** Instead, write your code in functions called init() and destroy().
- ** These will automatically be called by the form's constructor and
- ** destructor.
- *****************************************************************************/
- 
- 
- enum {
-     AUTH_NONE = 0,
-     AUTH_IEEE8021X = 1,
-     AUTH_WPA_PSK = 2,
-     AUTH_WPA_EAP = 3,
-     AUTH_WPA2_PSK = 4,
-     AUTH_WPA2_EAP = 5
- };
- 
- #define WPA_GUI_KEY_DATA "[key is configured]"
- 
- void NetworkConfig::init()
- {
-     wpagui = NULL;
-     new_network = false;
- }
- 
- void NetworkConfig::paramsFromScanResults(Q3ListViewItem *sel)
- {
-     new_network = true;
- 
-     /* SSID BSSID frequency signal flags */
-     setCaption(sel->text(0));
-     ssidEdit->setText(sel->text(0));
-     
-     QString flags = sel->text(4);
-     int auth, encr = 0;
-     if (flags.find("[WPA2-EAP") >= 0)
- 	auth = AUTH_WPA2_EAP;
-     else if (flags.find("[WPA-EAP") >= 0)
- 	auth = AUTH_WPA_EAP;
-     else if (flags.find("[WPA2-PSK") >= 0)
- 	auth = AUTH_WPA2_PSK;
-     else if (flags.find("[WPA-PSK") >= 0)
- 	auth = AUTH_WPA_PSK;
-     else
- 	auth = AUTH_NONE;
-     
-     if (flags.find("-CCMP") >= 0)
- 	encr = 1;
-     else if (flags.find("-TKIP") >= 0)
- 	encr = 0;
-     else if (flags.find("WEP") >= 0)
- 	encr = 1;
-     else
- 	encr = 0;
-  
-     authSelect->setCurrentItem(auth);
-     authChanged(auth);
-     encrSelect->setCurrentItem(encr);
- 
-     getEapCapa();
- }
- 
- 
- void NetworkConfig::authChanged(int sel)
- {
-     pskEdit->setEnabled(sel == AUTH_WPA_PSK || sel == AUTH_WPA2_PSK);
-     bool eap = sel == AUTH_IEEE8021X || sel == AUTH_WPA_EAP ||
- 	       sel == AUTH_WPA2_EAP;
-     eapSelect->setEnabled(eap);
-     identityEdit->setEnabled(eap);
-     passwordEdit->setEnabled(eap);
-     cacertEdit->setEnabled(eap);
-    
-     while (encrSelect->count())
- 	encrSelect->removeItem(0);
-     
-     if (sel == AUTH_NONE || sel == AUTH_IEEE8021X) {
- 	encrSelect->insertItem("None");
- 	encrSelect->insertItem("WEP");
- 	encrSelect->setCurrentItem(sel == AUTH_NONE ? 0 : 1);
-     } else {
- 	encrSelect->insertItem("TKIP");
- 	encrSelect->insertItem("CCMP");
- 	encrSelect->setCurrentItem((sel == AUTH_WPA2_PSK ||
- 				    sel == AUTH_WPA2_EAP) ? 1 : 0);
-     }
-     
-     wepEnabled(sel == AUTH_IEEE8021X);
- }
- 
- 
- void NetworkConfig::addNetwork()
- {
-     char reply[10], cmd[256];
-     size_t reply_len;
-     int id;
-     int psklen = pskEdit->text().length();
-     int auth = authSelect->currentItem();
- 
-     if (auth == AUTH_WPA_PSK || auth == AUTH_WPA2_PSK) {
- 	if (psklen < 8 || psklen > 64) {
- 	    QMessageBox::warning(this, "wpa_gui", "WPA-PSK requires a passphrase "
- 				 "of 8 to 63 characters\n"
- 				 "or 64 hex digit PSK");
- 	    return;
- 	}
-     }
-         
-     if (wpagui == NULL)
- 	return;
-     
-     memset(reply, 0, sizeof(reply));
-     reply_len = sizeof(reply) - 1;
-     
-     if (new_network) {
- 	wpagui->ctrlRequest("ADD_NETWORK", reply, &reply_len);
- 	if (reply[0] == 'F') {
- 	    QMessageBox::warning(this, "wpa_gui", "Failed to add network to wpa_supplicant\n"
- 				 "configuration.");
- 	    return;
- 	}
- 	id = atoi(reply);
-     } else {
- 	id = edit_network_id;
-     }
- 
-     setNetworkParam(id, "ssid", ssidEdit->text().ascii(), true);
-     
-     char *key_mgmt = NULL, *proto = NULL, *pairwise = NULL;
-     switch (auth) {
-     case AUTH_NONE:
- 	key_mgmt = "NONE";
- 	break;
-     case AUTH_IEEE8021X:
- 	key_mgmt = "IEEE8021X";
- 	break;
-     case AUTH_WPA_PSK:
- 	key_mgmt = "WPA-PSK";
- 	proto = "WPA";
- 	break;
-     case AUTH_WPA_EAP:
- 	key_mgmt = "WPA-EAP";
- 	proto = "WPA";
- 	break;
-     case AUTH_WPA2_PSK:
- 	key_mgmt = "WPA-PSK";
- 	proto = "WPA2";
- 	break;
-     case AUTH_WPA2_EAP:
- 	key_mgmt = "WPA-EAP";
- 	proto = "WPA2";
- 	break;
-     }
-     
-     if (auth == AUTH_WPA_PSK || auth == AUTH_WPA_EAP ||
- 	auth == AUTH_WPA2_PSK || auth == AUTH_WPA2_EAP) {
- 	int encr = encrSelect->currentItem();
- 	if (encr == 0)
- 	    pairwise = "TKIP";
- 	else
- 	    pairwise = "CCMP";
-     }
-     
-     if (proto)
- 	setNetworkParam(id, "proto", proto, false);
-     if (key_mgmt)
- 	setNetworkParam(id, "key_mgmt", key_mgmt, false);
-     if (pairwise) {
- 	setNetworkParam(id, "pairwise", pairwise, false);
- 	setNetworkParam(id, "group", "TKIP CCMP WEP104 WEP40", false);
-     }
-     if (pskEdit->isEnabled() &&
- 	strcmp(passwordEdit->text().ascii(), WPA_GUI_KEY_DATA) != 0)
- 	setNetworkParam(id, "psk", pskEdit->text().ascii(), psklen != 64);
-     if (eapSelect->isEnabled())
- 	setNetworkParam(id, "eap", eapSelect->currentText().ascii(), false);
-     if (identityEdit->isEnabled())
- 	setNetworkParam(id, "identity", identityEdit->text().ascii(), true);
-     if (passwordEdit->isEnabled() &&
- 	strcmp(passwordEdit->text().ascii(), WPA_GUI_KEY_DATA) != 0)
- 	setNetworkParam(id, "password", passwordEdit->text().ascii(), true);
-     if (cacertEdit->isEnabled())
- 	setNetworkParam(id, "ca_cert", cacertEdit->text().ascii(), true);
-     writeWepKey(id, wep0Edit, 0);
-     writeWepKey(id, wep1Edit, 1);
-     writeWepKey(id, wep2Edit, 2);
-     writeWepKey(id, wep3Edit, 3);
-   
-     if (wep0Radio->isEnabled() && wep0Radio->isChecked())
- 	setNetworkParam(id, "wep_tx_keyidx", "0", false);
-     else if (wep1Radio->isEnabled() && wep1Radio->isChecked())
- 	setNetworkParam(id, "wep_tx_keyidx", "1", false);
-     else if (wep2Radio->isEnabled() && wep2Radio->isChecked())
- 	setNetworkParam(id, "wep_tx_keyidx", "2", false);
-     else if (wep3Radio->isEnabled() && wep3Radio->isChecked())
- 	setNetworkParam(id, "wep_tx_keyidx", "3", false);
- 
-     snprintf(cmd, sizeof(cmd), "ENABLE_NETWORK %d", id);
-     reply_len = sizeof(reply);
-     wpagui->ctrlRequest(cmd, reply, &reply_len);
-     if (strncmp(reply, "OK", 2) != 0) {
- 	QMessageBox::warning(this, "wpa_gui", "Failed to enable network in wpa_supplicant\n"
- 			     "configuration.");
- 	/* Network was added, so continue anyway */
-     }
-     wpagui->triggerUpdate();
-     wpagui->ctrlRequest("SAVE_CONFIG", reply, &reply_len);
- 
-     close();
- }
- 
- 
- void NetworkConfig::setWpaGui( WpaGui *_wpagui )
- {
-     wpagui = _wpagui;
- }
- 
- 
- int NetworkConfig::setNetworkParam(int id, const char *field, const char *value, bool quote)
- {
-     char reply[10], cmd[256];
-     size_t reply_len;
-     snprintf(cmd, sizeof(cmd), "SET_NETWORK %d %s %s%s%s",
- 	     id, field, quote ? "\"" : "", value, quote ? "\"" : "");
-     reply_len = sizeof(reply);
-     wpagui->ctrlRequest(cmd, reply, &reply_len);
-     return strncmp(reply, "OK", 2) == 0 ? 0 : -1;
- }
- 
- 
- void NetworkConfig::encrChanged( const QString &sel )
- {
-     wepEnabled(sel.find("WEP") == 0);
- }
- 
- 
- void NetworkConfig::wepEnabled( bool enabled )
- {
-     wep0Edit->setEnabled(enabled);
-     wep1Edit->setEnabled(enabled);
-     wep2Edit->setEnabled(enabled);
-     wep3Edit->setEnabled(enabled);
-     wep0Radio->setEnabled(enabled);
-     wep1Radio->setEnabled(enabled);
-     wep2Radio->setEnabled(enabled);
-     wep3Radio->setEnabled(enabled);
- }
- 
- 
- void NetworkConfig::writeWepKey( int network_id, QLineEdit *edit, int id )
- {
-     char buf[10];
-     bool hex;
-     const char *txt, *pos;
-     size_t len;
-   
-     if (!edit->isEnabled() || edit->text().isEmpty())
- 	return;
-     
-     /*
-         * Assume hex key if only hex characters are present and length matches
-        * with 40, 104, or 128-bit key
-        */
-     txt = edit->text().ascii();
-     if (strcmp(txt, WPA_GUI_KEY_DATA) == 0)
- 	return;
-     len = strlen(txt);
-     if (len == 0)
- 	return;
-     pos = txt;
-     hex = true;
-     while (*pos) {
- 	if (!((*pos >= '0' && *pos <= '9') || (*pos >= 'a' && *pos <= 'f') ||
- 	      (*pos >= 'A' && *pos <= 'F'))) {
- 	    hex = false;
- 	    break;
- 	}
- 	pos++;
-     }
-     if (hex && len != 10 && len != 26 && len != 32)
- 	hex = false;
-     snprintf(buf, sizeof(buf), "wep_key%d", id);
-     setNetworkParam(network_id, buf, txt, !hex);
- }
- 
- 
- static int key_value_isset(const char *reply, size_t reply_len)
- {
-     return reply_len > 0 && (reply_len < 4 || memcmp(reply, "FAIL", 4) != 0);
- }
- 
- 
- void NetworkConfig::paramsFromConfig( int network_id )
- {
-     int i, res;
- 
-     edit_network_id = network_id;
-     getEapCapa();
-     
-     char reply[1024], cmd[256], *pos;
-     size_t reply_len;
-     
-     snprintf(cmd, sizeof(cmd), "GET_NETWORK %d ssid", network_id);
-     reply_len = sizeof(reply) - 1;
-     if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0 && reply_len >= 2 &&
- 	reply[0] == '"') {
- 	reply[reply_len] = '\0';
- 	pos = strchr(reply + 1, '"');
- 	if (pos)
- 	    *pos = '\0';
- 	ssidEdit->setText(reply + 1);
-     }
-     
-     snprintf(cmd, sizeof(cmd), "GET_NETWORK %d proto", network_id);
-     reply_len = sizeof(reply) - 1;
-     int wpa = 0;
-     if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0) {
- 	reply[reply_len] = '\0';
- 	if (strstr(reply, "RSN") || strstr(reply, "WPA2"))
- 	    wpa = 2;
- 	else if (strstr(reply, "WPA"))
- 	    wpa = 1;
-     }
- 
-     int auth = AUTH_NONE, encr = 0;
-     snprintf(cmd, sizeof(cmd), "GET_NETWORK %d key_mgmt", network_id);
-     reply_len = sizeof(reply) - 1;
-     if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0) {
- 	reply[reply_len] = '\0';
- 	if (strstr(reply, "WPA-EAP"))
- 	    auth = wpa & 2 ? AUTH_WPA2_EAP : AUTH_WPA_EAP;
- 	else if (strstr(reply, "WPA-PSK"))
- 	    auth = wpa & 2 ? AUTH_WPA2_PSK : AUTH_WPA_PSK;
- 	else if (strstr(reply, "IEEE8021X")) {
- 	    auth = AUTH_IEEE8021X;
- 	    encr = 1;
- 	}
-     }
- 
-     snprintf(cmd, sizeof(cmd), "GET_NETWORK %d pairwise", network_id);
-     reply_len = sizeof(reply) - 1;
-     if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0) {
- 	reply[reply_len] = '\0';
- 	if (strstr(reply, "CCMP"))
- 	    encr = 1;
- 	else if (strstr(reply, "TKIP"))
- 	    encr = 0;
- 	else if (strstr(reply, "WEP"))
- 	    encr = 1;
- 	else
- 	    encr = 0;
-     }
- 
-     snprintf(cmd, sizeof(cmd), "GET_NETWORK %d psk", network_id);
-     reply_len = sizeof(reply) - 1;
-     res = wpagui->ctrlRequest(cmd, reply, &reply_len);
-     if (res >= 0 && reply_len >= 2 && reply[0] == '"') {
- 	reply[reply_len] = '\0';
- 	pos = strchr(reply + 1, '"');
- 	if (pos)
- 	    *pos = '\0';
- 	pskEdit->setText(reply + 1);
-     } else if (res >= 0 && key_value_isset(reply, reply_len)) {
- 	pskEdit->setText(WPA_GUI_KEY_DATA);
-     }
- 
-     snprintf(cmd, sizeof(cmd), "GET_NETWORK %d identity", network_id);
-     reply_len = sizeof(reply) - 1;
-     if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0 && reply_len >= 2 &&
- 	reply[0] == '"') {
- 	reply[reply_len] = '\0';
- 	pos = strchr(reply + 1, '"');
- 	if (pos)
- 	    *pos = '\0';
- 	identityEdit->setText(reply + 1);
-     }
- 
-     snprintf(cmd, sizeof(cmd), "GET_NETWORK %d password", network_id);
-     reply_len = sizeof(reply) - 1;
-     res = wpagui->ctrlRequest(cmd, reply, &reply_len);
-     if (res >= 0 && reply_len >= 2 &&
- 	reply[0] == '"') {
- 	reply[reply_len] = '\0';
- 	pos = strchr(reply + 1, '"');
- 	if (pos)
- 	    *pos = '\0';
- 	passwordEdit->setText(reply + 1);
-     } else if (res >= 0 && key_value_isset(reply, reply_len)) {
- 	passwordEdit->setText(WPA_GUI_KEY_DATA);
-     }
- 
-     snprintf(cmd, sizeof(cmd), "GET_NETWORK %d ca_cert", network_id);
-     reply_len = sizeof(reply) - 1;
-     if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0 && reply_len >= 2 &&
- 	reply[0] == '"') {
- 	reply[reply_len] = '\0';
- 	pos = strchr(reply + 1, '"');
- 	if (pos)
- 	    *pos = '\0';
- 	cacertEdit->setText(reply + 1);
-     }
- 
-     snprintf(cmd, sizeof(cmd), "GET_NETWORK %d eap", network_id);
-     reply_len = sizeof(reply) - 1;
-     if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0 && reply_len >= 1) {
- 	reply[reply_len] = '\0';
- 	for (i = 0; i < eapSelect->count(); i++) {
- 	    if (eapSelect->text(i).compare(reply) == 0) {
- 		eapSelect->setCurrentItem(i);
- 		break;
- 	    }
- 	}
-     }
- 
-     for (i = 0; i < 4; i++) {
- 	QLineEdit *wepEdit;
- 	switch (i) {
- 	default:
- 	case 0:
- 	    wepEdit = wep0Edit;
- 	    break;
- 	case 1:
- 	    wepEdit = wep1Edit;
- 	    break;
- 	case 2:
- 	    wepEdit = wep2Edit;
- 	    break;
- 	case 3:
- 	    wepEdit = wep3Edit;
- 	    break;
- 	}
- 	snprintf(cmd, sizeof(cmd), "GET_NETWORK %d wep_key%d", network_id, i);
- 	reply_len = sizeof(reply) - 1;
- 	res = wpagui->ctrlRequest(cmd, reply, &reply_len);
- 	if (res >= 0 && reply_len >= 2 && reply[0] == '"') {
- 	    reply[reply_len] = '\0';
- 	    pos = strchr(reply + 1, '"');
- 	    if (pos)
- 		*pos = '\0';
- 	    if (auth == AUTH_NONE || auth == AUTH_IEEE8021X)
- 		encr = 1;
- 
- 	    wepEdit->setText(reply + 1);
- 	} else if (res >= 0 && key_value_isset(reply, reply_len)) {
- 	    if (auth == AUTH_NONE || auth == AUTH_IEEE8021X)
- 		encr = 1;
- 	    wepEdit->setText(WPA_GUI_KEY_DATA);
- 	}
-     }
- 
-     snprintf(cmd, sizeof(cmd), "GET_NETWORK %d wep_tx_keyidx", network_id);
-     reply_len = sizeof(reply) - 1;
-     if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0 && reply_len >= 1) {
- 	reply[reply_len] = '\0';
- 	switch (atoi(reply)) {
- 	case 0:
- 	    wep0Radio->setChecked(true);
- 	    break;
- 	case 1:
- 	    wep1Radio->setChecked(true);
- 	    break;
- 	case 2:
- 	    wep2Radio->setChecked(true);
- 	    break;
- 	case 3:
- 	    wep3Radio->setChecked(true);
- 	    break;
- 	}
-     }
- 
-     authSelect->setCurrentItem(auth);
-     authChanged(auth);
-     encrSelect->setCurrentItem(encr);
-     if (auth == AUTH_NONE || auth == AUTH_IEEE8021X)
- 	wepEnabled(encr == 1);
- 
-     removeButton->setEnabled(true);
-     addButton->setText("Save");
- }
- 
- 
- void NetworkConfig::removeNetwork()
- {
-     char reply[10], cmd[256];
-     size_t reply_len;
-     
-     if (QMessageBox::information(this, "wpa_gui",
- 				 "This will permanently remove the network\n"
- 				 "from the configuration. Do you really want\n"
- 				 "to remove this network?", "Yes", "No") != 0)
- 	return;
-     
-     snprintf(cmd, sizeof(cmd), "REMOVE_NETWORK %d", edit_network_id);
-     reply_len = sizeof(reply);
-     wpagui->ctrlRequest(cmd, reply, &reply_len);
-     if (strncmp(reply, "OK", 2) != 0) {
- 	QMessageBox::warning(this, "wpa_gui",
- 			     "Failed to remove network from wpa_supplicant\n"
- 			     "configuration.");
-     } else {
- 	wpagui->triggerUpdate();
- 	wpagui->ctrlRequest("SAVE_CONFIG", reply, &reply_len);
-     }
- 
-     close();
- }
- 
- 
- void NetworkConfig::newNetwork()
- {
-     new_network = true;
-     getEapCapa();
- }
- 
- 
- void NetworkConfig::getEapCapa()
- {
-     char reply[256];
-     size_t reply_len;
-     
-     if (wpagui == NULL)
- 	return;
- 
-     reply_len = sizeof(reply) - 1;
-     if (wpagui->ctrlRequest("GET_CAPABILITY eap", reply, &reply_len) < 0)
- 	return;
-     reply[reply_len] = '\0';
-     
-     QString res(reply);
-     QStringList types = QStringList::split(QChar(' '), res);
-     eapSelect->insertStringList(types);
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui/scanresults.ui wpa_view/wpa_suppl/wpa_gui/scanresults.ui
*** wpa_supplicant-0.5.7/wpa_gui/scanresults.ui	Sun Aug 21 07:34:52 2005
--- wpa_view/wpa_suppl/wpa_gui/scanresults.ui	Thu Jan  1 02:00:00 1970
***************
*** 1,179 ****
- <!DOCTYPE UI><UI version="3.3" stdsetdef="1">
- <class>ScanResults</class>
- <widget class="QDialog">
-     <property name="name">
-         <cstring>ScanResults</cstring>
-     </property>
-     <property name="geometry">
-         <rect>
-             <x>0</x>
-             <y>0</y>
-             <width>452</width>
-             <height>225</height>
-         </rect>
-     </property>
-     <property name="caption">
-         <string>Scan results</string>
-     </property>
-     <vbox>
-         <property name="name">
-             <cstring>unnamed</cstring>
-         </property>
-         <widget class="QListView">
-             <column>
-                 <property name="text">
-                     <string>SSID</string>
-                 </property>
-                 <property name="clickable">
-                     <bool>true</bool>
-                 </property>
-                 <property name="resizable">
-                     <bool>true</bool>
-                 </property>
-             </column>
-             <column>
-                 <property name="text">
-                     <string>BSSID</string>
-                 </property>
-                 <property name="clickable">
-                     <bool>true</bool>
-                 </property>
-                 <property name="resizable">
-                     <bool>true</bool>
-                 </property>
-             </column>
-             <column>
-                 <property name="text">
-                     <string>frequency</string>
-                 </property>
-                 <property name="clickable">
-                     <bool>true</bool>
-                 </property>
-                 <property name="resizable">
-                     <bool>true</bool>
-                 </property>
-             </column>
-             <column>
-                 <property name="text">
-                     <string>signal</string>
-                 </property>
-                 <property name="clickable">
-                     <bool>true</bool>
-                 </property>
-                 <property name="resizable">
-                     <bool>true</bool>
-                 </property>
-             </column>
-             <column>
-                 <property name="text">
-                     <string>flags</string>
-                 </property>
-                 <property name="clickable">
-                     <bool>true</bool>
-                 </property>
-                 <property name="resizable">
-                     <bool>true</bool>
-                 </property>
-             </column>
-             <property name="name">
-                 <cstring>scanResultsView</cstring>
-             </property>
-             <property name="frameShape">
-                 <enum>StyledPanel</enum>
-             </property>
-             <property name="frameShadow">
-                 <enum>Sunken</enum>
-             </property>
-         </widget>
-         <widget class="QLayoutWidget">
-             <property name="name">
-                 <cstring>layout24</cstring>
-             </property>
-             <hbox>
-                 <property name="name">
-                     <cstring>unnamed</cstring>
-                 </property>
-                 <spacer>
-                     <property name="name">
-                         <cstring>spacer6</cstring>
-                     </property>
-                     <property name="orientation">
-                         <enum>Horizontal</enum>
-                     </property>
-                     <property name="sizeType">
-                         <enum>Expanding</enum>
-                     </property>
-                     <property name="sizeHint">
-                         <size>
-                             <width>50</width>
-                             <height>20</height>
-                         </size>
-                     </property>
-                 </spacer>
-                 <widget class="QPushButton">
-                     <property name="name">
-                         <cstring>scanButton</cstring>
-                     </property>
-                     <property name="text">
-                         <string>Scan</string>
-                     </property>
-                 </widget>
-                 <widget class="QPushButton">
-                     <property name="name">
-                         <cstring>closeButton</cstring>
-                     </property>
-                     <property name="text">
-                         <string>Close</string>
-                     </property>
-                 </widget>
-             </hbox>
-         </widget>
-     </vbox>
- </widget>
- <connections>
-     <connection>
-         <sender>closeButton</sender>
-         <signal>clicked()</signal>
-         <receiver>ScanResults</receiver>
-         <slot>close()</slot>
-     </connection>
-     <connection>
-         <sender>scanButton</sender>
-         <signal>clicked()</signal>
-         <receiver>ScanResults</receiver>
-         <slot>scanRequest()</slot>
-     </connection>
-     <connection>
-         <sender>scanResultsView</sender>
-         <signal>doubleClicked(QListViewItem*)</signal>
-         <receiver>ScanResults</receiver>
-         <slot>bssSelected(QListViewItem*)</slot>
-     </connection>
- </connections>
- <includes>
-     <include location="local" impldecl="in implementation">wpa_ctrl.h</include>
-     <include location="local" impldecl="in implementation">wpagui.h</include>
-     <include location="local" impldecl="in implementation">networkconfig.h</include>
-     <include location="local" impldecl="in implementation">scanresults.ui.h</include>
- </includes>
- <forwards>
-     <forward>class WpaGui;</forward>
- </forwards>
- <variables>
-     <variable access="private">WpaGui *wpagui;</variable>
-     <variable access="private">QTimer *timer;</variable>
- </variables>
- <slots>
-     <slot>setWpaGui( WpaGui * _wpagui )</slot>
-     <slot>updateResults()</slot>
-     <slot>scanRequest()</slot>
-     <slot>getResults()</slot>
-     <slot>bssSelected( QListViewItem * sel )</slot>
- </slots>
- <functions>
-     <function access="private" specifier="non virtual">init()</function>
-     <function access="private" specifier="non virtual">destroy()</function>
- </functions>
- <pixmapinproject/>
- <layoutdefaults spacing="6" margin="11"/>
- </UI>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui/scanresults.ui.h wpa_view/wpa_suppl/wpa_gui/scanresults.ui.h
*** wpa_supplicant-0.5.7/wpa_gui/scanresults.ui.h	Sun Aug 27 18:39:23 2006
--- wpa_view/wpa_suppl/wpa_gui/scanresults.ui.h	Thu Jan  1 02:00:00 1970
***************
*** 1,101 ****
- /****************************************************************************
- ** ui.h extension file, included from the uic-generated form implementation.
- **
- ** If you want to add, delete, or rename functions or slots, use
- ** Qt Designer to update this file, preserving your code.
- **
- ** You should not define a constructor or destructor in this file.
- ** Instead, write your code in functions called init() and destroy().
- ** These will automatically be called by the form's constructor and
- ** destructor.
- *****************************************************************************/
- 
- void ScanResults::init()
- {
-     wpagui = NULL;
- }
- 
- 
- void ScanResults::destroy()
- {
-     delete timer;
- }
- 
- 
- void ScanResults::setWpaGui(WpaGui *_wpagui)
- {
-     wpagui = _wpagui;
-     updateResults();
-     
-     timer = new QTimer(this);
-     connect(timer, SIGNAL(timeout()), SLOT(getResults()));
-     timer->start(10000, FALSE);
- }
- 
- 
- void ScanResults::updateResults()
- {
-     char reply[8192];
-     size_t reply_len;
-     
-     if (wpagui == NULL)
- 	return;
- 
-     reply_len = sizeof(reply) - 1;
-     if (wpagui->ctrlRequest("SCAN_RESULTS", reply, &reply_len) < 0)
- 	return;
-     reply[reply_len] = '\0';
- 
-     scanResultsView->clear();
-     
-     QString res(reply);
-     QStringList lines = QStringList::split(QChar('\n'), res);
-     bool first = true;
-     for (QStringList::Iterator it = lines.begin(); it != lines.end(); it++) {
- 	if (first) {
- 	    first = false;
- 	    continue;
- 	}
- 	
- 	QStringList cols = QStringList::split(QChar('\t'), *it, true);
- 	QString ssid, bssid, freq, signal, flags;
- 	bssid = cols.count() > 0 ? cols[0] : "";
- 	freq = cols.count() > 1 ? cols[1] : "";
- 	signal = cols.count() > 2 ? cols[2] : "";
- 	flags = cols.count() > 3 ? cols[3] : "";
- 	ssid = cols.count() > 4 ? cols[4] : "";
- 	new Q3ListViewItem(scanResultsView, ssid, bssid, freq, signal, flags);
-     }
- }
- 
- 
- void ScanResults::scanRequest()
- {
-     char reply[10];
-     size_t reply_len = sizeof(reply);
-     
-     if (wpagui == NULL)
- 	return;
-     
-     wpagui->ctrlRequest("SCAN", reply, &reply_len);
- }
- 
- 
- void ScanResults::getResults()
- {
-     updateResults();
- }
- 
- 
- 
- 
- void ScanResults::bssSelected( Q3ListViewItem * sel )
- {
-     NetworkConfig *nc = new NetworkConfig();
-     if (nc == NULL)
- 	return;
-     nc->setWpaGui(wpagui);
-     nc->paramsFromScanResults(sel);
-     nc->show();
-     nc->exec();
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui/setup-mingw-cross-compiling wpa_view/wpa_suppl/wpa_gui/setup-mingw-cross-compiling
*** wpa_supplicant-0.5.7/wpa_gui/setup-mingw-cross-compiling	Mon Aug 28 06:53:42 2006
--- wpa_view/wpa_suppl/wpa_gui/setup-mingw-cross-compiling	Thu Jan  1 02:00:00 1970
***************
*** 1,11 ****
- #!/bin/sh
- 
- # qmake seems to be forcing include and lib paths from the original build
- # and I have no idea how to change these. For now, just override the
- # directories in the Makefile.Release file after qmake run.
- 
- qmake -spec /q/jm/qt4-win/4.0.0/mkspecs/win32-g++ wpa_gui.pro -o Makefile
- cat Makefile.Release |
-     sed s%qt4/lib%qt4-win/4.0.0/lib%g |
-     sed s%qt4/include%qt4-win/4.0.0/include%g > tmp.Makefile.Release &&
- mv -f tmp.Makefile.Release Makefile.Release
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui/userdatarequest.ui wpa_view/wpa_suppl/wpa_gui/userdatarequest.ui
*** wpa_supplicant-0.5.7/wpa_gui/userdatarequest.ui	Sat Nov 19 18:07:17 2005
--- wpa_view/wpa_suppl/wpa_gui/userdatarequest.ui	Thu Jan  1 02:00:00 1970
***************
*** 1,163 ****
- <!DOCTYPE UI><UI version="3.3" stdsetdef="1">
- <class>UserDataRequest</class>
- <widget class="QDialog">
-     <property name="name">
-         <cstring>UserDataRequest</cstring>
-     </property>
-     <property name="geometry">
-         <rect>
-             <x>0</x>
-             <y>0</y>
-             <width>216</width>
-             <height>103</height>
-         </rect>
-     </property>
-     <property name="caption">
-         <string>Authentication credentials required</string>
-     </property>
-     <property name="sizeGripEnabled">
-         <bool>true</bool>
-     </property>
-     <vbox>
-         <property name="name">
-             <cstring>unnamed</cstring>
-         </property>
-         <widget class="QLabel">
-             <property name="name">
-                 <cstring>queryInfo</cstring>
-             </property>
-             <property name="text">
-                 <string></string>
-             </property>
-         </widget>
-         <widget class="QLayoutWidget">
-             <property name="name">
-                 <cstring>layout28</cstring>
-             </property>
-             <hbox>
-                 <property name="name">
-                     <cstring>unnamed</cstring>
-                 </property>
-                 <widget class="QLabel">
-                     <property name="name">
-                         <cstring>queryField</cstring>
-                     </property>
-                     <property name="text">
-                         <string></string>
-                     </property>
-                 </widget>
-                 <widget class="QLineEdit">
-                     <property name="name">
-                         <cstring>queryEdit</cstring>
-                     </property>
-                     <property name="enabled">
-                         <bool>true</bool>
-                     </property>
-                     <property name="echoMode">
-                         <enum>Password</enum>
-                     </property>
-                 </widget>
-             </hbox>
-         </widget>
-         <widget class="QLayoutWidget">
-             <property name="name">
-                 <cstring>layout27</cstring>
-             </property>
-             <hbox>
-                 <property name="name">
-                     <cstring>unnamed</cstring>
-                 </property>
-                 <spacer>
-                     <property name="name">
-                         <cstring>spacer4</cstring>
-                     </property>
-                     <property name="orientation">
-                         <enum>Horizontal</enum>
-                     </property>
-                     <property name="sizeType">
-                         <enum>Expanding</enum>
-                     </property>
-                     <property name="sizeHint">
-                         <size>
-                             <width>20</width>
-                             <height>20</height>
-                         </size>
-                     </property>
-                 </spacer>
-                 <widget class="QPushButton">
-                     <property name="name">
-                         <cstring>buttonOk</cstring>
-                     </property>
-                     <property name="text">
-                         <string>&amp;OK</string>
-                     </property>
-                     <property name="accel">
-                         <string></string>
-                     </property>
-                     <property name="autoDefault">
-                         <bool>true</bool>
-                     </property>
-                     <property name="default">
-                         <bool>true</bool>
-                     </property>
-                 </widget>
-                 <widget class="QPushButton">
-                     <property name="name">
-                         <cstring>buttonCancel</cstring>
-                     </property>
-                     <property name="text">
-                         <string>&amp;Cancel</string>
-                     </property>
-                     <property name="accel">
-                         <string></string>
-                     </property>
-                     <property name="autoDefault">
-                         <bool>true</bool>
-                     </property>
-                 </widget>
-             </hbox>
-         </widget>
-     </vbox>
- </widget>
- <connections>
-     <connection>
-         <sender>buttonOk</sender>
-         <signal>clicked()</signal>
-         <receiver>UserDataRequest</receiver>
-         <slot>sendReply()</slot>
-     </connection>
-     <connection>
-         <sender>buttonCancel</sender>
-         <signal>clicked()</signal>
-         <receiver>UserDataRequest</receiver>
-         <slot>reject()</slot>
-     </connection>
-     <connection>
-         <sender>queryEdit</sender>
-         <signal>returnPressed()</signal>
-         <receiver>UserDataRequest</receiver>
-         <slot>sendReply()</slot>
-     </connection>
- </connections>
- <includes>
-     <include location="local" impldecl="in implementation">wpa_ctrl.h</include>
-     <include location="local" impldecl="in implementation">wpagui.h</include>
-     <include location="local" impldecl="in implementation">userdatarequest.ui.h</include>
- </includes>
- <forwards>
-     <forward>class WpaGui;</forward>
- </forwards>
- <variables>
-     <variable access="private">WpaGui *wpagui;</variable>
-     <variable access="private">int networkid;</variable>
-     <variable access="private">QString field;</variable>
- </variables>
- <slots>
-     <slot>sendReply()</slot>
- </slots>
- <functions>
-     <function specifier="non virtual" returnType="int">setParams( WpaGui * _wpagui, const char * reqMsg )</function>
- </functions>
- <pixmapinproject/>
- <layoutdefaults spacing="6" margin="11"/>
- </UI>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui/userdatarequest.ui.h wpa_view/wpa_suppl/wpa_gui/userdatarequest.ui.h
*** wpa_supplicant-0.5.7/wpa_gui/userdatarequest.ui.h	Sun Jun  5 19:19:57 2005
--- wpa_view/wpa_suppl/wpa_gui/userdatarequest.ui.h	Thu Jan  1 02:00:00 1970
***************
*** 1,70 ****
- /****************************************************************************
- ** ui.h extension file, included from the uic-generated form implementation.
- **
- ** If you want to add, delete, or rename functions or slots, use
- ** Qt Designer to update this file, preserving your code.
- **
- ** You should not define a constructor or destructor in this file.
- ** Instead, write your code in functions called init() and destroy().
- ** These will automatically be called by the form's constructor and
- ** destructor.
- *****************************************************************************/
- 
- int UserDataRequest::setParams(WpaGui *_wpagui, const char *reqMsg)
- {
-     char *tmp, *pos, *pos2;
-     wpagui = _wpagui;
-     tmp = strdup(reqMsg);
-     if (tmp == NULL)
- 	return -1;
-     pos = strchr(tmp, '-');
-     if (pos == NULL) {
- 	free(tmp);
- 	return -1;
-     }
-     *pos++ = '\0';
-     field = tmp;
-     pos2 = strchr(pos, ':');
-     if (pos2 == NULL) {
- 	free(tmp);
- 	return -1;
-     }
-     *pos2++ = '\0';
-     
-     networkid = atoi(pos);
-     queryInfo->setText(pos2);
-     if (strcmp(tmp, "PASSWORD") == 0) {
- 	queryField->setText("Password: ");
- 	queryEdit->setEchoMode(QLineEdit::Password);
-     } else if (strcmp(tmp, "NEW_PASSWORD") == 0) {
- 	queryField->setText("New password: ");
-  	queryEdit->setEchoMode(QLineEdit::Password);
-     } else if (strcmp(tmp, "IDENTITY") == 0)
- 	queryField->setText("Identity: ");
-     else if (strcmp(tmp, "PASSPHRASE") == 0) {
- 	queryField->setText("Private key passphrase: ");
-  	queryEdit->setEchoMode(QLineEdit::Password);
-     } else
- 	queryField->setText(field + ":");
-     free(tmp);
-     
-     return 0;
- }
- 
- 
- void UserDataRequest::sendReply()
- {
-     char reply[10];
-     size_t reply_len = sizeof(reply);
-     
-     if (wpagui == NULL) {
- 	reject();
- 	return;
-     }
-     
-     QString cmd = QString(WPA_CTRL_RSP) + field + '-' +
- 		  QString::number(networkid) + ':' +
- 		  queryEdit->text();
-     wpagui->ctrlRequest(cmd.ascii(), reply, &reply_len);
-     accept();
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui/wpa_gui.pro wpa_view/wpa_suppl/wpa_gui/wpa_gui.pro
*** wpa_supplicant-0.5.7/wpa_gui/wpa_gui.pro	Sun Aug 27 18:39:23 2006
--- wpa_view/wpa_suppl/wpa_gui/wpa_gui.pro	Thu Jan  1 02:00:00 1970
***************
*** 1,47 ****
- TEMPLATE	= app
- LANGUAGE	= C++
- 
- CONFIG	+= qt warn_on release
- 
- DEFINES += CONFIG_CTRL_IFACE
- 
- win32 {
-   LIBS += -lws2_32 -static
-   DEFINES += CONFIG_NATIVE_WINDOWS CONFIG_CTRL_IFACE_NAMED_PIPE
- } else:win32-g++ {
-   # cross compilation to win32
-   LIBS += -lws2_32 -static
-   DEFINES += CONFIG_NATIVE_WINDOWS CONFIG_CTRL_IFACE_NAMED_PIPE
- } else {
-   DEFINES += CONFIG_CTRL_IFACE_UNIX
- }
- 
- INCLUDEPATH	+= . .. ../../hostapd
- 
- HEADERS	+= wpamsg.h
- 
- SOURCES	+= main.cpp \
- 	../wpa_ctrl.c
- 
- FORMS	= wpagui.ui \
- 	eventhistory.ui \
- 	scanresults.ui \
- 	userdatarequest.ui \
- 	networkconfig.ui
- 
- 
- unix {
-   UI_DIR = .ui
-   MOC_DIR = .moc
-   OBJECTS_DIR = .obj
- }
- 
- qtver = $$[QT_VERSION]
- isEmpty( qtver ) {
- 	message(Compiling for Qt 3.x)
- 	DEFINES += Q3ListViewItem=QListViewItem
- } else {
- 	message(Compiling for Qt $$qtver)
- 	QT += qt3support
- 	CONFIG += uic3
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui/wpagui.ui wpa_view/wpa_suppl/wpa_gui/wpagui.ui
*** wpa_supplicant-0.5.7/wpa_gui/wpagui.ui	Mon Aug  7 04:15:24 2006
--- wpa_view/wpa_suppl/wpa_gui/wpagui.ui	Thu Jan  1 02:00:00 1970
***************
*** 1,471 ****
- <!DOCTYPE UI><UI version="3.3" stdsetdef="1">
- <class>WpaGui</class>
- <widget class="QMainWindow">
-     <property name="name">
-         <cstring>WpaGui</cstring>
-     </property>
-     <property name="geometry">
-         <rect>
-             <x>0</x>
-             <y>0</y>
-             <width>279</width>
-             <height>308</height>
-         </rect>
-     </property>
-     <property name="caption">
-         <string>wpa_gui</string>
-     </property>
-     <grid>
-         <property name="name">
-             <cstring>unnamed</cstring>
-         </property>
-         <widget class="QLabel" row="0" column="0" rowspan="1" colspan="2">
-             <property name="name">
-                 <cstring>textLabel16</cstring>
-             </property>
-             <property name="text">
-                 <string>Adapter:</string>
-             </property>
-         </widget>
-         <widget class="QComboBox" row="0" column="2" rowspan="1" colspan="2">
-             <property name="name">
-                 <cstring>adapterSelect</cstring>
-             </property>
-         </widget>
-         <widget class="QLabel" row="1" column="0" rowspan="1" colspan="2">
-             <property name="name">
-                 <cstring>textLabel8</cstring>
-             </property>
-             <property name="text">
-                 <string>Network:</string>
-             </property>
-         </widget>
-         <widget class="QComboBox" row="1" column="2" rowspan="1" colspan="2">
-             <property name="name">
-                 <cstring>networkSelect</cstring>
-             </property>
-         </widget>
-         <widget class="QFrame" row="2" column="0" rowspan="1" colspan="4">
-             <property name="name">
-                 <cstring>frame3</cstring>
-             </property>
-             <property name="frameShape">
-                 <enum>StyledPanel</enum>
-             </property>
-             <property name="frameShadow">
-                 <enum>Raised</enum>
-             </property>
-             <grid>
-                 <property name="name">
-                     <cstring>unnamed</cstring>
-                 </property>
-                 <widget class="QLabel" row="0" column="0">
-                     <property name="name">
-                         <cstring>textLabel1</cstring>
-                     </property>
-                     <property name="text">
-                         <string>Status:</string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="1" column="0">
-                     <property name="name">
-                         <cstring>textLabel2</cstring>
-                     </property>
-                     <property name="text">
-                         <string>Last message:</string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="2" column="0">
-                     <property name="name">
-                         <cstring>textLabel3</cstring>
-                     </property>
-                     <property name="text">
-                         <string>Authentication:</string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="3" column="0">
-                     <property name="name">
-                         <cstring>textLabel4</cstring>
-                     </property>
-                     <property name="text">
-                         <string>Encryption:</string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="4" column="0">
-                     <property name="name">
-                         <cstring>textLabel5</cstring>
-                     </property>
-                     <property name="text">
-                         <string>SSID:</string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="5" column="0">
-                     <property name="name">
-                         <cstring>textLabel6</cstring>
-                     </property>
-                     <property name="text">
-                         <string>BSSID:</string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="6" column="0">
-                     <property name="name">
-                         <cstring>textLabel7</cstring>
-                     </property>
-                     <property name="text">
-                         <string>IP address:</string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="0" column="1">
-                     <property name="name">
-                         <cstring>textStatus</cstring>
-                     </property>
-                     <property name="text">
-                         <string></string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="1" column="1" rowspan="1" colspan="3">
-                     <property name="name">
-                         <cstring>textLastMessage</cstring>
-                     </property>
-                     <property name="text">
-                         <string></string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="2" column="1">
-                     <property name="name">
-                         <cstring>textAuthentication</cstring>
-                     </property>
-                     <property name="text">
-                         <string></string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="3" column="1">
-                     <property name="name">
-                         <cstring>textEncryption</cstring>
-                     </property>
-                     <property name="text">
-                         <string></string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="4" column="1">
-                     <property name="name">
-                         <cstring>textSsid</cstring>
-                     </property>
-                     <property name="text">
-                         <string></string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="5" column="1">
-                     <property name="name">
-                         <cstring>textBssid</cstring>
-                     </property>
-                     <property name="text">
-                         <string></string>
-                     </property>
-                 </widget>
-                 <widget class="QLabel" row="6" column="1">
-                     <property name="name">
-                         <cstring>textIpAddress</cstring>
-                     </property>
-                     <property name="text">
-                         <string></string>
-                     </property>
-                 </widget>
-             </grid>
-         </widget>
-         <spacer row="3" column="0">
-             <property name="name">
-                 <cstring>spacer7</cstring>
-             </property>
-             <property name="orientation">
-                 <enum>Horizontal</enum>
-             </property>
-             <property name="sizeType">
-                 <enum>Expanding</enum>
-             </property>
-             <property name="sizeHint">
-                 <size>
-                     <width>16</width>
-                     <height>16</height>
-                 </size>
-             </property>
-         </spacer>
-         <widget class="QPushButton" row="3" column="1">
-             <property name="name">
-                 <cstring>connectButton</cstring>
-             </property>
-             <property name="text">
-                 <string>Connect</string>
-             </property>
-         </widget>
-         <widget class="QPushButton" row="3" column="2">
-             <property name="name">
-                 <cstring>disconnectButton</cstring>
-             </property>
-             <property name="text">
-                 <string>Disconnect</string>
-             </property>
-         </widget>
-         <widget class="QPushButton" row="3" column="3">
-             <property name="name">
-                 <cstring>scanButton</cstring>
-             </property>
-             <property name="text">
-                 <string>Scan</string>
-             </property>
-         </widget>
-     </grid>
- </widget>
- <menubar>
-     <property name="name">
-         <cstring>MenuBar</cstring>
-     </property>
-     <item text="&amp;File" name="fileMenu">
-         <separator/>
-         <action name="fileEventHistoryAction"/>
-         <action name="fileAdd_NetworkAction"/>
-         <action name="fileEdit_networkAction"/>
-         <separator/>
-         <action name="fileExitAction"/>
-     </item>
-     <item text="&amp;Help" name="helpMenu">
-         <action name="helpContentsAction"/>
-         <action name="helpIndexAction"/>
-         <separator/>
-         <action name="helpAboutAction"/>
-     </item>
- </menubar>
- <toolbars>
- </toolbars>
- <actions>
-     <action>
-         <property name="name">
-             <cstring>fileExitAction</cstring>
-         </property>
-         <property name="text">
-             <string>Exit</string>
-         </property>
-         <property name="menuText">
-             <string>E&amp;xit</string>
-         </property>
-         <property name="accel">
-             <string>Ctrl+Q</string>
-         </property>
-     </action>
-     <action>
-         <property name="name">
-             <cstring>helpContentsAction</cstring>
-         </property>
-         <property name="enabled">
-             <bool>false</bool>
-         </property>
-         <property name="text">
-             <string>Contents</string>
-         </property>
-         <property name="menuText">
-             <string>&amp;Contents...</string>
-         </property>
-         <property name="accel">
-             <string></string>
-         </property>
-     </action>
-     <action>
-         <property name="name">
-             <cstring>helpIndexAction</cstring>
-         </property>
-         <property name="enabled">
-             <bool>false</bool>
-         </property>
-         <property name="text">
-             <string>Index</string>
-         </property>
-         <property name="menuText">
-             <string>&amp;Index...</string>
-         </property>
-         <property name="accel">
-             <string></string>
-         </property>
-     </action>
-     <action>
-         <property name="name">
-             <cstring>helpAboutAction</cstring>
-         </property>
-         <property name="text">
-             <string>About</string>
-         </property>
-         <property name="menuText">
-             <string>&amp;About</string>
-         </property>
-         <property name="accel">
-             <string></string>
-         </property>
-     </action>
-     <action>
-         <property name="name">
-             <cstring>fileEventHistoryAction</cstring>
-         </property>
-         <property name="text">
-             <string>Event History</string>
-         </property>
-         <property name="menuText">
-             <string>Event &amp;History</string>
-         </property>
-     </action>
-     <action>
-         <property name="name">
-             <cstring>fileAdd_NetworkAction</cstring>
-         </property>
-         <property name="text">
-             <string>Add Network</string>
-         </property>
-         <property name="menuText">
-             <string>&amp;Add Network</string>
-         </property>
-     </action>
-     <action>
-         <property name="name">
-             <cstring>fileEdit_networkAction</cstring>
-         </property>
-         <property name="text">
-             <string>Edit Network</string>
-         </property>
-         <property name="menuText">
-             <string>&amp;Edit Network</string>
-         </property>
-     </action>
- </actions>
- <connections>
-     <connection>
-         <sender>helpIndexAction</sender>
-         <signal>activated()</signal>
-         <receiver>WpaGui</receiver>
-         <slot>helpIndex()</slot>
-     </connection>
-     <connection>
-         <sender>helpContentsAction</sender>
-         <signal>activated()</signal>
-         <receiver>WpaGui</receiver>
-         <slot>helpContents()</slot>
-     </connection>
-     <connection>
-         <sender>helpAboutAction</sender>
-         <signal>activated()</signal>
-         <receiver>WpaGui</receiver>
-         <slot>helpAbout()</slot>
-     </connection>
-     <connection>
-         <sender>fileExitAction</sender>
-         <signal>activated()</signal>
-         <receiver>WpaGui</receiver>
-         <slot>close()</slot>
-     </connection>
-     <connection>
-         <sender>disconnectButton</sender>
-         <signal>clicked()</signal>
-         <receiver>WpaGui</receiver>
-         <slot>disconnect()</slot>
-     </connection>
-     <connection>
-         <sender>scanButton</sender>
-         <signal>clicked()</signal>
-         <receiver>WpaGui</receiver>
-         <slot>scan()</slot>
-     </connection>
-     <connection>
-         <sender>connectButton</sender>
-         <signal>clicked()</signal>
-         <receiver>WpaGui</receiver>
-         <slot>connectB()</slot>
-     </connection>
-     <connection>
-         <sender>fileEventHistoryAction</sender>
-         <signal>activated()</signal>
-         <receiver>WpaGui</receiver>
-         <slot>eventHistory()</slot>
-     </connection>
-     <connection>
-         <sender>networkSelect</sender>
-         <signal>activated(const QString&amp;)</signal>
-         <receiver>WpaGui</receiver>
-         <slot>selectNetwork(const QString&amp;)</slot>
-     </connection>
-     <connection>
-         <sender>fileEdit_networkAction</sender>
-         <signal>activated()</signal>
-         <receiver>WpaGui</receiver>
-         <slot>editNetwork()</slot>
-     </connection>
-     <connection>
-         <sender>fileAdd_NetworkAction</sender>
-         <signal>activated()</signal>
-         <receiver>WpaGui</receiver>
-         <slot>addNetwork()</slot>
-     </connection>
-     <connection>
-         <sender>adapterSelect</sender>
-         <signal>activated(const QString&amp;)</signal>
-         <receiver>WpaGui</receiver>
-         <slot>selectAdapter(const QString&amp;)</slot>
-     </connection>
- </connections>
- <includes>
-     <include location="global" impldecl="in declaration">qtimer.h</include>
-     <include location="global" impldecl="in declaration">qsocketnotifier.h</include>
-     <include location="local" impldecl="in declaration">wpamsg.h</include>
-     <include location="local" impldecl="in declaration">eventhistory.h</include>
-     <include location="local" impldecl="in declaration">scanresults.h</include>
-     <include location="local" impldecl="in implementation">wpa_ctrl.h</include>
-     <include location="global" impldecl="in implementation">dirent.h</include>
-     <include location="global" impldecl="in implementation">qmessagebox.h</include>
-     <include location="global" impldecl="in implementation">qapplication.h</include>
-     <include location="local" impldecl="in implementation">userdatarequest.h</include>
-     <include location="local" impldecl="in implementation">networkconfig.h</include>
-     <include location="local" impldecl="in implementation">wpagui.ui.h</include>
- </includes>
- <forwards>
-     <forward>class UserDataRequest;</forward>
- </forwards>
- <variables>
-     <variable access="private">ScanResults *scanres;</variable>
-     <variable access="private">bool networkMayHaveChanged;</variable>
-     <variable access="private">char *ctrl_iface;</variable>
-     <variable access="private">EventHistory *eh;</variable>
-     <variable access="private">struct wpa_ctrl *ctrl_conn;</variable>
-     <variable access="private">QSocketNotifier *msgNotifier;</variable>
-     <variable access="private">QTimer *timer;</variable>
-     <variable access="private">int pingsToStatusUpdate;</variable>
-     <variable access="private">WpaMsgList msgs;</variable>
-     <variable access="private">char *ctrl_iface_dir;</variable>
-     <variable access="private">struct wpa_ctrl *monitor_conn;</variable>
-     <variable access="private">UserDataRequest *udr;</variable>
- </variables>
- <slots>
-     <slot>parse_argv()</slot>
-     <slot>updateStatus()</slot>
-     <slot>updateNetworks()</slot>
-     <slot>helpIndex()</slot>
-     <slot>helpContents()</slot>
-     <slot>helpAbout()</slot>
-     <slot>disconnect()</slot>
-     <slot>scan()</slot>
-     <slot>eventHistory()</slot>
-     <slot>ping()</slot>
-     <slot>processMsg( char * msg )</slot>
-     <slot>processCtrlReq( const char * req )</slot>
-     <slot>receiveMsgs()</slot>
-     <slot>connectB()</slot>
-     <slot>selectNetwork( const QString &amp; sel )</slot>
-     <slot>editNetwork()</slot>
-     <slot>addNetwork()</slot>
-     <slot>selectAdapter( const QString &amp; sel )</slot>
- </slots>
- <functions>
-     <function access="private" specifier="non virtual">init()</function>
-     <function access="private" specifier="non virtual">destroy()</function>
-     <function access="private" specifier="non virtual" returnType="int">openCtrlConnection( const char * ifname )</function>
-     <function returnType="int">ctrlRequest( const char * cmd, char * buf, size_t * buflen )</function>
-     <function>triggerUpdate()</function>
- </functions>
- <pixmapinproject/>
- <layoutdefaults spacing="6" margin="11"/>
- </UI>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui/wpagui.ui.h wpa_view/wpa_suppl/wpa_gui/wpagui.ui.h
*** wpa_supplicant-0.5.7/wpa_gui/wpagui.ui.h	Sat Aug 26 06:29:27 2006
--- wpa_view/wpa_suppl/wpa_gui/wpagui.ui.h	Thu Jan  1 02:00:00 1970
***************
*** 1,731 ****
- /****************************************************************************
- ** ui.h extension file, included from the uic-generated form implementation.
- **
- ** If you want to add, delete, or rename functions or slots, use
- ** Qt Designer to update this file, preserving your code.
- **
- ** You should not define a constructor or destructor in this file.
- ** Instead, write your code in functions called init() and destroy().
- ** These will automatically be called by the form's constructor and
- ** destructor.
- *****************************************************************************/
- 
- 
- #ifdef __MINGW32__
- /* Need to get getopt() */
- #include <unistd.h>
- #endif
- 
- 
- void WpaGui::init()
- {
-     eh = NULL;
-     scanres = NULL;
-     udr = NULL;
-     ctrl_iface = NULL;
-     ctrl_conn = NULL;
-     monitor_conn = NULL;
-     msgNotifier = NULL;
-     ctrl_iface_dir = strdup("/var/run/wpa_supplicant");
-     
-     parse_argv();
- 
-     textStatus->setText("connecting to wpa_supplicant");
-     timer = new QTimer(this);
-     connect(timer, SIGNAL(timeout()), SLOT(ping()));
-     timer->start(1000, FALSE);
-     
-     if (openCtrlConnection(ctrl_iface) < 0) {
- 	printf("Failed to open control connection to wpa_supplicant.\n");
-     }
-     
-     updateStatus();
-     networkMayHaveChanged = true;
-     updateNetworks();
- }
- 
- 
- void WpaGui::destroy()
- {
-     delete msgNotifier;
- 
-     if (monitor_conn) {
- 	wpa_ctrl_detach(monitor_conn);
- 	wpa_ctrl_close(monitor_conn);
- 	monitor_conn = NULL;
-     }
-     if (ctrl_conn) {
- 	wpa_ctrl_close(ctrl_conn);
- 	ctrl_conn = NULL;
-     }
-     
-     if (eh) {
- 	eh->close();
- 	delete eh;
- 	eh = NULL;
-     }
-     
-     if (scanres) {
- 	scanres->close();
- 	delete scanres;
- 	scanres = NULL;
-     }
-     
-     if (udr) {
- 	udr->close();
- 	delete udr;
- 	udr = NULL;
-     }
-     
-     free(ctrl_iface);
-     ctrl_iface = NULL;
-     
-     free(ctrl_iface_dir);
-     ctrl_iface_dir = NULL;
- }
- 
- 
- void WpaGui::parse_argv()
- {
-     int c;
-     for (;;) {
- 	c = getopt(qApp->argc(), qApp->argv(), "i:p:");
- 	if (c < 0)
- 	    break;
- 	switch (c) {
- 	case 'i':
- 	    free(ctrl_iface);
- 	    ctrl_iface = strdup(optarg);
- 	    break;
- 	case 'p':
- 	    free(ctrl_iface_dir);
- 	    ctrl_iface_dir = strdup(optarg);
- 	    break;
- 	}
-     }
- }
- 
- 
- int WpaGui::openCtrlConnection(const char *ifname)
- {
-     char *cfile;
-     int flen;
-     char buf[2048], *pos, *pos2;
-     size_t len;
- 
-     if (ifname) {
- 	if (ifname != ctrl_iface) {
- 	    free(ctrl_iface);
- 	    ctrl_iface = strdup(ifname);
- 	}
-     } else {
- #ifdef CONFIG_CTRL_IFACE_UDP
- 	free(ctrl_iface);
- 	ctrl_iface = strdup("udp");
- #endif /* CONFIG_CTRL_IFACE_UDP */
- #ifdef CONFIG_CTRL_IFACE_UNIX
- 	struct dirent *dent;
- 	DIR *dir = opendir(ctrl_iface_dir);
- 	free(ctrl_iface);
- 	ctrl_iface = NULL;
- 	if (dir) {
- 	    while ((dent = readdir(dir))) {
- #ifdef _DIRENT_HAVE_D_TYPE
- 		/* Skip the file if it is not a socket.
- 		 * Also accept DT_UNKNOWN (0) in case
- 		 * the C library or underlying file
- 		 * system does not support d_type. */
- 		if (dent->d_type != DT_SOCK &&
- 		    dent->d_type != DT_UNKNOWN)
- 		    continue;
- #endif /* _DIRENT_HAVE_D_TYPE */
- 
- 		if (strcmp(dent->d_name, ".") == 0 ||
- 		    strcmp(dent->d_name, "..") == 0)
- 		    continue;
- 		printf("Selected interface '%s'\n", dent->d_name);
- 		ctrl_iface = strdup(dent->d_name);
- 		break;
- 	    }
- 	    closedir(dir);
- 	}
- #endif /* CONFIG_CTRL_IFACE_UNIX */
- #ifdef CONFIG_CTRL_IFACE_NAMED_PIPE
- 	struct wpa_ctrl *ctrl;
- 	int ret;
- 
- 	free(ctrl_iface);
- 	ctrl_iface = NULL;
- 
- 	ctrl = wpa_ctrl_open(NULL);
- 	if (ctrl) {
- 	    len = sizeof(buf) - 1;
- 	    ret = wpa_ctrl_request(ctrl, "INTERFACES", 10, buf, &len, NULL);
- 	    if (ret >= 0) {
- 		buf[len] = '\0';
- 		pos = strchr(buf, '\n');
- 		if (pos)
- 		    *pos = '\0';
- 		ctrl_iface = strdup(buf);
- 	    }
- 	    wpa_ctrl_close(ctrl);
- 	}
- #endif /* CONFIG_CTRL_IFACE_NAMED_PIPE */
-     }
-     
-     if (ctrl_iface == NULL)
- 	return -1;
- 
- #ifdef CONFIG_CTRL_IFACE_UNIX
-     flen = strlen(ctrl_iface_dir) + strlen(ctrl_iface) + 2;
-     cfile = (char *) malloc(flen);
-     if (cfile == NULL)
- 	return -1;
-     snprintf(cfile, flen, "%s/%s", ctrl_iface_dir, ctrl_iface);
- #else /* CONFIG_CTRL_IFACE_UNIX */
-     flen = strlen(ctrl_iface) + 1;
-     cfile = (char *) malloc(flen);
-     if (cfile == NULL)
- 	return -1;
-     snprintf(cfile, flen, "%s", ctrl_iface);
- #endif /* CONFIG_CTRL_IFACE_UNIX */
- 
-     if (ctrl_conn) {
- 	wpa_ctrl_close(ctrl_conn);
- 	ctrl_conn = NULL;
-     }
- 
-     if (monitor_conn) {
- 	delete msgNotifier;
- 	msgNotifier = NULL;
- 	wpa_ctrl_detach(monitor_conn);
- 	wpa_ctrl_close(monitor_conn);
- 	monitor_conn = NULL;
-     }
- 
-     printf("Trying to connect to '%s'\n", cfile);
-     ctrl_conn = wpa_ctrl_open(cfile);
-     if (ctrl_conn == NULL) {
- 	free(cfile);
- 	return -1;
-     }
-     monitor_conn = wpa_ctrl_open(cfile);
-     free(cfile);
-     if (monitor_conn == NULL) {
- 	wpa_ctrl_close(ctrl_conn);
- 	return -1;
-     }
-     if (wpa_ctrl_attach(monitor_conn)) {
- 	printf("Failed to attach to wpa_supplicant\n");
- 	wpa_ctrl_close(monitor_conn);
- 	monitor_conn = NULL;
- 	wpa_ctrl_close(ctrl_conn);
- 	ctrl_conn = NULL;
- 	return -1;
-     }
- 
- #if defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
-     msgNotifier = new QSocketNotifier(wpa_ctrl_get_fd(monitor_conn),
- 				      QSocketNotifier::Read, this);
-     connect(msgNotifier, SIGNAL(activated(int)), SLOT(receiveMsgs()));
- #endif
- 
-     adapterSelect->clear();
-     adapterSelect->insertItem(ctrl_iface);
-     adapterSelect->setCurrentItem(0);
- 
-     len = sizeof(buf) - 1;
-     if (wpa_ctrl_request(ctrl_conn, "INTERFACES", 10, buf, &len, NULL) >= 0) {
- 	buf[len] = '\0';
- 	pos = buf;
- 	while (*pos) {
- 		pos2 = strchr(pos, '\n');
- 		if (pos2)
- 			*pos2 = '\0';
- 		if (strcmp(pos, ctrl_iface) != 0)
- 			adapterSelect->insertItem(pos);
- 		if (pos2)
- 			pos = pos2 + 1;
- 		else
- 			break;
- 	}
-     }
- 
-     return 0;
- }
- 
- 
- static void wpa_gui_msg_cb(char *msg, size_t)
- {
-     /* This should not happen anymore since two control connections are used. */
-     printf("missed message: %s\n", msg);
- }
- 
- 
- int WpaGui::ctrlRequest(const char *cmd, char *buf, size_t *buflen)
- {
-     int ret;
-     
-     if (ctrl_conn == NULL)
- 	return -3;
-     ret = wpa_ctrl_request(ctrl_conn, cmd, strlen(cmd), buf, buflen,
- 			   wpa_gui_msg_cb);
-     if (ret == -2) {
- 	printf("'%s' command timed out.\n", cmd);
-     } else if (ret < 0) {
- 	printf("'%s' command failed.\n", cmd);
-     }
-     
-     return ret;
- }
- 
- 
- void WpaGui::updateStatus()
- {
-     char buf[2048], *start, *end, *pos;
-     size_t len;
- 
-     pingsToStatusUpdate = 10;
- 
-     len = sizeof(buf) - 1;
-     if (ctrl_conn == NULL || ctrlRequest("STATUS", buf, &len) < 0) {
- 	textStatus->setText("Could not get status from wpa_supplicant");
- 	textAuthentication->clear();
- 	textEncryption->clear();
- 	textSsid->clear();
- 	textBssid->clear();
- 	textIpAddress->clear();
- 	return;
-     }
-     
-     buf[len] = '\0';
-     
-     bool auth_updated = false, ssid_updated = false;
-     bool bssid_updated = false, ipaddr_updated = false;
-     bool status_updated = false;
-     char *pairwise_cipher = NULL, *group_cipher = NULL;
-     
-     start = buf;
-     while (*start) {
- 	bool last = false;
- 	end = strchr(start, '\n');
- 	if (end == NULL) {
- 	    last = true;
- 	    end = start;
- 	    while (end[0] && end[1])
- 		end++;
- 	}
- 	*end = '\0';
- 	
- 	pos = strchr(start, '=');
- 	if (pos) {
- 	    *pos++ = '\0';
- 	    if (strcmp(start, "bssid") == 0) {
- 		bssid_updated = true;
- 		textBssid->setText(pos);
- 	    } else if (strcmp(start, "ssid") == 0) {
- 		ssid_updated = true;
- 		textSsid->setText(pos);
- 	    } else if (strcmp(start, "ip_address") == 0) {
- 		ipaddr_updated = true;
- 		textIpAddress->setText(pos);
- 	    } else if (strcmp(start, "wpa_state") == 0) {
- 		status_updated = true;
- 		textStatus->setText(pos);
- 	    } else if (strcmp(start, "key_mgmt") == 0) {
- 		auth_updated = true;
- 		textAuthentication->setText(pos);
- 		/* TODO: could add EAP status to this */
- 	    } else if (strcmp(start, "pairwise_cipher") == 0) {
- 		pairwise_cipher = pos;
- 	    } else if (strcmp(start, "group_cipher") == 0) {
- 		group_cipher = pos;
- 	    }
- 	}
- 	
- 	if (last)
- 	    break;
- 	start = end + 1;
-     }
-     
-     if (pairwise_cipher || group_cipher) {
- 	QString encr;
- 	if (pairwise_cipher && group_cipher &&
- 	    strcmp(pairwise_cipher, group_cipher) != 0) {
- 	    encr.append(pairwise_cipher);
- 	    encr.append(" + ");
- 	    encr.append(group_cipher);
- 	} else if (pairwise_cipher) {
- 	    encr.append(pairwise_cipher);
- 	} else if (group_cipher) {
- 	    encr.append(group_cipher);
- 	    encr.append(" [group key only]");
- 	} else {
- 	    encr.append("?");
- 	}
- 	textEncryption->setText(encr);
-     } else
- 	textEncryption->clear();
- 
-     if (!status_updated)
- 	textStatus->clear();
-     if (!auth_updated)
- 	textAuthentication->clear();
-     if (!ssid_updated)
- 	textSsid->clear();
-     if (!bssid_updated)
- 	textBssid->clear();
-     if (!ipaddr_updated)
- 	textIpAddress->clear();
- }
- 
- 
- void WpaGui::updateNetworks()
- {
-     char buf[2048], *start, *end, *id, *ssid, *bssid, *flags;
-     size_t len;
-     int first_active = -1;
-     bool selected = false;
- 
-     if (!networkMayHaveChanged)
- 	return;
- 
-     networkSelect->clear();
- 
-     if (ctrl_conn == NULL)
- 	return;
-     
-     len = sizeof(buf) - 1;
-     if (ctrlRequest("LIST_NETWORKS", buf, &len) < 0)
- 	return;
-     
-     buf[len] = '\0';
-     start = strchr(buf, '\n');
-     if (start == NULL)
- 	return;
-     start++;
- 
-     while (*start) {
- 	bool last = false;
- 	end = strchr(start, '\n');
- 	if (end == NULL) {
- 	    last = true;
- 	    end = start;
- 	    while (end[0] && end[1])
- 		end++;
- 	}
- 	*end = '\0';
- 	
- 	id = start;
- 	ssid = strchr(id, '\t');
- 	if (ssid == NULL)
- 	    break;
- 	*ssid++ = '\0';
- 	bssid = strchr(ssid, '\t');
- 	if (bssid == NULL)
- 	    break;
- 	*bssid++ = '\0';
- 	flags = strchr(bssid, '\t');
- 	if (flags == NULL)
- 	    break;
- 	*flags++ = '\0';
- 	
- 	QString network(id);
- 	network.append(": ");
- 	network.append(ssid);
- 	networkSelect->insertItem(network);
- 	
- 	if (strstr(flags, "[CURRENT]")) {
- 	    networkSelect->setCurrentItem(networkSelect->count() - 1);
- 	    selected = true;
- 	} else if (first_active < 0 && strstr(flags, "[DISABLED]") == NULL)
- 	    first_active = networkSelect->count() - 1;
- 	
- 	if (last)
- 	    break;
- 	start = end + 1;
-     }
- 
-     if (!selected && first_active >= 0)
- 	networkSelect->setCurrentItem(first_active);
- 
-     networkMayHaveChanged = false;
- }
- 
- 
- void WpaGui::helpIndex()
- {
-     printf("helpIndex\n");
- }
- 
- 
- void WpaGui::helpContents()
- {
-     printf("helpContents\n");
- }
- 
- 
- void WpaGui::helpAbout()
- {
-     QMessageBox::about(this, "wpa_gui for wpa_supplicant",
- 		       "Copyright (c) 2003-2005,\n"
- 		       "Jouni Malinen <jkmaline@cc.hut.fi>\n"
- 		       "and contributors.\n"
- 		       "\n"
- 		       "This program is free software. You can\n"
- 		       "distribute it and/or modify it under the terms of\n"
- 		       "the GNU General Public License version 2.\n"
- 		       "\n"
- 		       "Alternatively, this software may be distributed\n"
- 		       "under the terms of the BSD license.\n"
- 		       "\n"
- 		       "This product includes software developed\n"
- 		       "by the OpenSSL Project for use in the\n"
- 		       "OpenSSL Toolkit (http://www.openssl.org/)\n");
- }
- 
- 
- void WpaGui::disconnect()
- {
-     char reply[10];
-     size_t reply_len = sizeof(reply);
-     ctrlRequest("DISCONNECT", reply, &reply_len);
- }
- 
- 
- void WpaGui::scan()
- {
-     if (scanres) {
- 	scanres->close();
- 	delete scanres;
-     }
- 
-     scanres = new ScanResults();
-     if (scanres == NULL)
- 	return;
-     scanres->setWpaGui(this);
-     scanres->show();
-     scanres->exec();
- }
- 
- 
- void WpaGui::eventHistory()
- {
-     if (eh) {
- 	eh->close();
- 	delete eh;
-     }
- 
-     eh = new EventHistory();
-     if (eh == NULL)
- 	return;
-     eh->addEvents(msgs);
-     eh->show();
-     eh->exec();
- }
- 
- 
- void WpaGui::ping()
- {
-     char buf[10];
-     size_t len;
-     
- #ifdef CONFIG_CTRL_IFACE_NAMED_PIPE
-     /*
-      * QSocketNotifier cannot be used with Windows named pipes, so use a timer
-      * to check for received messages for now. This could be optimized be doing
-      * something specific to named pipes or Windows events, but it is not clear
-      * what would be the best way of doing that in Qt.
-      */
-     receiveMsgs();
- #endif /* CONFIG_CTRL_IFACE_NAMED_PIPE */
- 
-     if (scanres && !scanres->isVisible()) {
- 	delete scanres;
- 	scanres = NULL;
-     }
-     
-     if (eh && !eh->isVisible()) {
- 	delete eh;
- 	eh = NULL;
-     }
-     
-     if (udr && !udr->isVisible()) {
- 	delete udr;
- 	udr = NULL;
-     }
-     
-     len = sizeof(buf) - 1;
-     if (ctrlRequest("PING", buf, &len) < 0) {
- 	printf("PING failed - trying to reconnect\n");
- 	if (openCtrlConnection(ctrl_iface) >= 0) {
- 	    printf("Reconnected successfully\n");
- 	    pingsToStatusUpdate = 0;
- 	}
-     }
- 
-     pingsToStatusUpdate--;
-     if (pingsToStatusUpdate <= 0) {
- 	updateStatus();
- 	updateNetworks();
-     }
- }
- 
- 
- static int str_match(const char *a, const char *b)
- {
-     return strncmp(a, b, strlen(b)) == 0;
- }
- 
- 
- void WpaGui::processMsg(char *msg)
- {
-     char *pos = msg, *pos2;
-     int priority = 2;
-     
-     if (*pos == '<') {
- 	/* skip priority */
- 	pos++;
- 	priority = atoi(pos);
- 	pos = strchr(pos, '>');
- 	if (pos)
- 	    pos++;
- 	else
- 	    pos = msg;
-     }
- 
-     WpaMsg wm(pos, priority);
-     if (eh)
- 	eh->addEvent(wm);
-     msgs.append(wm);
-     while (msgs.count() > 100)
- 	msgs.pop_front();
-     
-     /* Update last message with truncated version of the event */
-     if (strncmp(pos, "CTRL-", 5) == 0) {
- 	pos2 = strchr(pos, str_match(pos, WPA_CTRL_REQ) ? ':' : ' ');
- 	if (pos2)
- 	    pos2++;
- 	else
- 	    pos2 = pos;
-     } else
- 	pos2 = pos;
-     QString lastmsg = pos2;
-     lastmsg.truncate(40);
-     textLastMessage->setText(lastmsg);
-     
-     pingsToStatusUpdate = 0;
-     networkMayHaveChanged = true;
-     
-     if (str_match(pos, WPA_CTRL_REQ))
- 	processCtrlReq(pos + strlen(WPA_CTRL_REQ));
- }
- 
- 
- void WpaGui::processCtrlReq(const char *req)
- {
-     if (udr) {
- 	udr->close();
- 	delete udr;
-     }
-     udr = new UserDataRequest();
-     if (udr == NULL)
- 	return;
-     if (udr->setParams(this, req) < 0) {
- 	delete udr;
- 	udr = NULL;
- 	return;
-     }
-     udr->show();
-     udr->exec();
- }
- 
- 
- void WpaGui::receiveMsgs()
- {
-     char buf[256];
-     size_t len;
-     
-     while (monitor_conn && wpa_ctrl_pending(monitor_conn) > 0) {
- 	len = sizeof(buf) - 1;
- 	if (wpa_ctrl_recv(monitor_conn, buf, &len) == 0) {
- 	    buf[len] = '\0';
- 	    processMsg(buf);
- 	}
-     }
- }
- 
- 
- void WpaGui::connectB()
- {
-     char reply[10];
-     size_t reply_len = sizeof(reply);
-     ctrlRequest("REASSOCIATE", reply, &reply_len);
- }
- 
- 
- void WpaGui::selectNetwork( const QString &sel )
- {
-     QString cmd(sel);
-     char reply[10];
-     size_t reply_len = sizeof(reply);
-     
-     int pos = cmd.find(':');
-     if (pos < 0) {
- 	printf("Invalid selectNetwork '%s'\n", cmd.ascii());
- 	return;
-     }
-     cmd.truncate(pos);
-     cmd.prepend("SELECT_NETWORK ");
-     ctrlRequest(cmd.ascii(), reply, &reply_len);
- }
- 
- 
- void WpaGui::editNetwork()
- {
-     QString sel(networkSelect->currentText());
-     int pos = sel.find(':');
-     if (pos < 0) {
- 	printf("Invalid selectNetwork '%s'\n", sel.ascii());
- 	return;
-     }
-     sel.truncate(pos);
-     
-     NetworkConfig *nc = new NetworkConfig();
-     if (nc == NULL)
- 	return;
-     nc->setWpaGui(this);
-     
-     nc->paramsFromConfig(sel.toInt());
-     nc->show();
-     nc->exec();
- }
- 
- 
- void WpaGui::triggerUpdate()
- {
-     updateStatus();
-     networkMayHaveChanged = true;
-     updateNetworks();
- }
- 
- 
- void WpaGui::addNetwork()
- {
-     NetworkConfig *nc = new NetworkConfig();
-     if (nc == NULL)
- 	return;
-     nc->setWpaGui(this);
-     nc->newNetwork();
-     nc->show();
-     nc->exec();
- }
- 
- 
- void WpaGui::selectAdapter( const QString & sel )
- {
-     if (openCtrlConnection(sel.ascii()) < 0)
- 	printf("Failed to open control connection to wpa_supplicant.\n");
-     updateStatus();
-     updateNetworks();
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui/wpamsg.h wpa_view/wpa_suppl/wpa_gui/wpamsg.h
*** wpa_supplicant-0.5.7/wpa_gui/wpamsg.h	Sun Aug 27 18:39:23 2006
--- wpa_view/wpa_suppl/wpa_gui/wpamsg.h	Thu Jan  1 02:00:00 1970
***************
*** 1,34 ****
- #ifndef WPAMSG_H
- #define WPAMSG_H
- 
- class WpaMsg;
- 
- #if QT_VERSION >= 0x040000
- #include <QDateTime>
- #include <QLinkedList>
- typedef QLinkedList<WpaMsg> WpaMsgList;
- #else
- #include <qdatetime.h>
- typedef QValueList<WpaMsg> WpaMsgList;
- #endif
- 
- class WpaMsg {
- public:
-     WpaMsg() {}
-     WpaMsg(const QString &_msg, int _priority = 2)
- 	: msg(_msg), priority(_priority)
-     {
- 	timestamp = QDateTime::currentDateTime();
-     }
-     
-     QString getMsg() const { return msg; }
-     int getPriority() const { return priority; }
-     QDateTime getTimestamp() const { return timestamp; }
-     
- private:
-     QString msg;
-     int priority;
-     QDateTime timestamp;
- };
- 
- #endif /* WPAMSG_H */
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/.cvsignore wpa_view/wpa_suppl/wpa_gui-qt4/.cvsignore
*** wpa_supplicant-0.5.7/wpa_gui-qt4/.cvsignore	Sat Jul 23 20:31:07 2005
--- wpa_view/wpa_suppl/wpa_gui-qt4/.cvsignore	Thu Jan  1 02:00:00 1970
***************
*** 1,5 ****
- .moc
- .obj
- .ui
- Makefile
- wpa_gui
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/eventhistory.cpp wpa_view/wpa_suppl/wpa_gui-qt4/eventhistory.cpp
*** wpa_supplicant-0.5.7/wpa_gui-qt4/eventhistory.cpp	Mon Aug 28 06:29:46 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/eventhistory.cpp	Thu Jan  1 02:00:00 1970
***************
*** 1,122 ****
- /*
-  * wpa_gui - EventHistory class
-  * Copyright (c) 2005-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #include <QHeaderView>
- 
- #include "eventhistory.h"
- 
- 
- int EventListModel::rowCount(const QModelIndex &) const
- {
- 	return msgList.count();
- }
- 
- 
- int EventListModel::columnCount(const QModelIndex &) const
- {
- 	return 2;
- }
- 
- 
- QVariant EventListModel::data(const QModelIndex &index, int role) const
- {
- 	if (!index.isValid())
- 		return QVariant();
- 
-         if (role == Qt::DisplayRole)
- 		if (index.column() == 0) {
- 			if (index.row() >= timeList.size())
- 				return QVariant();
- 			return timeList.at(index.row());
- 		} else {
- 			if (index.row() >= msgList.size())
- 				return QVariant();
- 			return msgList.at(index.row());
- 		}
-         else
- 		return QVariant();
- }
- 
- 
- QVariant EventListModel::headerData(int section, Qt::Orientation orientation,
- 				    int role) const
- {
- 	if (role != Qt::DisplayRole)
- 		return QVariant();
- 
- 	if (orientation == Qt::Horizontal) {
- 		switch (section) {
- 		case 0:
- 			return QString("Timestamp");
- 		case 1:
- 			return QString("Message");
- 		default:
- 			return QVariant();
- 		}
- 	} else
- 		return QString("%1").arg(section);
- }
- 
- 
- void EventListModel::addEvent(QString time, QString msg)
- {
- 	beginInsertRows(QModelIndex(), msgList.size(), msgList.size() + 1);
- 	timeList << time;
- 	msgList << msg;
- 	endInsertRows();
- }
- 
- 
- EventHistory::EventHistory(QWidget *parent, const char *, bool, Qt::WFlags)
- 	: QDialog(parent)
- {
- 	setupUi(this);
- 
- 	connect(closeButton, SIGNAL(clicked()), this, SLOT(close()));
- 
- 	elm = new EventListModel(parent);
- 	eventListView->setModel(elm);
- }
- 
- 
- EventHistory::~EventHistory()
- {
- 	destroy();
- 	delete elm;
- }
- 
- 
- void EventHistory::languageChange()
- {
- 	retranslateUi(this);
- }
- 
- 
- void EventHistory::addEvents(WpaMsgList msgs)
- {
- 	WpaMsgList::iterator it;
- 	for (it = msgs.begin(); it != msgs.end(); it++)
- 		addEvent(*it);
- }
- 
- 
- void EventHistory::addEvent(WpaMsg msg)
- {
- 	elm->addEvent(msg.getTimestamp().toString("yyyy-MM-dd hh:mm:ss.zzz"),
- 		      msg.getMsg());
- #if QT_VERSION >= 0x040100
- 	eventListView->resizeColumnsToContents();
- 	eventListView->resizeRowsToContents();
- #endif
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/eventhistory.h wpa_view/wpa_suppl/wpa_gui-qt4/eventhistory.h
*** wpa_supplicant-0.5.7/wpa_gui-qt4/eventhistory.h	Mon Aug 28 09:15:35 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/eventhistory.h	Thu Jan  1 02:00:00 1970
***************
*** 1,63 ****
- /*
-  * wpa_gui - EventHistory class
-  * Copyright (c) 2005-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #ifndef EVENTHISTORY_H
- #define EVENTHISTORY_H
- 
- #include <QObject>
- #include "ui_eventhistory.h"
- 
- 
- class EventListModel : public QAbstractTableModel
- {
- 	Q_OBJECT
- 
- public:
- 	EventListModel(QObject *parent = 0)
- 		: QAbstractTableModel(parent) {}
- 
-         int rowCount(const QModelIndex &parent = QModelIndex()) const;
-         int columnCount(const QModelIndex &parent = QModelIndex()) const;
-         QVariant data(const QModelIndex &index, int role) const;
-         QVariant headerData(int section, Qt::Orientation orientation,
-                             int role = Qt::DisplayRole) const;
- 	void addEvent(QString time, QString msg);
- 
- private:
- 	QStringList timeList;
- 	QStringList msgList;
- };
- 
- 
- class EventHistory : public QDialog, public Ui::EventHistory
- {
- 	Q_OBJECT
- 
- public:
- 	EventHistory(QWidget *parent = 0, const char *name = 0,
- 		     bool modal = false, Qt::WFlags fl = 0);
- 	~EventHistory();
- 
- public slots:
- 	virtual void addEvents(WpaMsgList msgs);
- 	virtual void addEvent(WpaMsg msg);
- 
- protected slots:
- 	virtual void languageChange();
- 
- private:
- 	EventListModel *elm;
- };
- 
- #endif /* EVENTHISTORY_H */
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/eventhistory.ui wpa_view/wpa_suppl/wpa_gui-qt4/eventhistory.ui
*** wpa_supplicant-0.5.7/wpa_gui-qt4/eventhistory.ui	Mon Aug 28 06:22:40 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/eventhistory.ui	Thu Jan  1 02:00:00 1970
***************
*** 1,93 ****
- <ui version="4.0" stdsetdef="1" >
-   <author></author>
-   <comment></comment>
-   <exportmacro></exportmacro>
-   <class>EventHistory</class>
-   <widget class="QDialog" name="EventHistory" >
-     <property name="geometry" >
-       <rect>
-         <x>0</x>
-         <y>0</y>
-         <width>533</width>
-         <height>285</height>
-       </rect>
-     </property>
-     <property name="windowTitle" >
-       <string>Event history</string>
-     </property>
-     <layout class="QVBoxLayout" >
-       <item>
-         <widget class="QTableView" name="eventListView" >
-           <property name="sizePolicy" >
-             <sizepolicy>
-               <hsizetype>7</hsizetype>
-               <vsizetype>7</vsizetype>
-               <horstretch>0</horstretch>
-               <verstretch>0</verstretch>
-             </sizepolicy>
-           </property>
-           <property name="selectionMode" >
-             <enum>QAbstractItemView::NoSelection</enum>
-           </property>
-           <column>
-             <property name="text" >
-               <string>Timestamp</string>
-             </property>
-             <property name="clickable" >
-               <bool>true</bool>
-             </property>
-             <property name="resizable" >
-               <bool>true</bool>
-             </property>
-           </column>
-           <column>
-             <property name="text" >
-               <string>Message</string>
-             </property>
-             <property name="clickable" >
-               <bool>true</bool>
-             </property>
-             <property name="resizable" >
-               <bool>true</bool>
-             </property>
-           </column>
-         </widget>
-       </item>
-       <item>
-         <layout class="QHBoxLayout" >
-           <property name="margin" >
-             <number>0</number>
-           </property>
-           <item>
-             <spacer name="spacer3" >
-               <property name="sizeHint" >
-                 <size>
-                   <width>20</width>
-                   <height>20</height>
-                 </size>
-               </property>
-               <property name="sizeType" >
-                 <enum>Expanding</enum>
-               </property>
-               <property name="orientation" >
-                 <enum>Horizontal</enum>
-               </property>
-             </spacer>
-           </item>
-           <item>
-             <widget class="QPushButton" name="closeButton" >
-               <property name="text" >
-                 <string>Close</string>
-               </property>
-             </widget>
-           </item>
-         </layout>
-       </item>
-     </layout>
-   </widget>
-   <layoutdefault spacing="6" margin="11" />
-   <pixmapfunction>qPixmapFromMimeSource</pixmapfunction>
-   <includes>
-     <include location="local" >wpamsg.h</include>
-   </includes>
- </ui>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/main.cpp wpa_view/wpa_suppl/wpa_gui-qt4/main.cpp
*** wpa_supplicant-0.5.7/wpa_gui-qt4/main.cpp	Sun Aug 27 22:00:11 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/main.cpp	Thu Jan  1 02:00:00 1970
***************
*** 1,44 ****
- /*
-  * wpa_gui - Application startup
-  * Copyright (c) 2005-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #ifdef CONFIG_NATIVE_WINDOWS
- #include <winsock.h>
- #endif /* CONFIG_NATIVE_WINDOWS */
- #include <QApplication>
- #include "wpagui.h"
- 
- int main(int argc, char *argv[])
- {
- 	QApplication app(argc, argv);
- 	WpaGui w;
- 	int ret;
- 
- #ifdef CONFIG_NATIVE_WINDOWS
- 	WSADATA wsaData;
- 	if (WSAStartup(MAKEWORD(2, 0), &wsaData)) {
- 		printf("Could not find a usable WinSock.dll\n");
- 		return -1;
- 	}
- #endif /* CONFIG_NATIVE_WINDOWS */
- 
- 	w.show();
- 	app.connect(&app, SIGNAL(lastWindowClosed()), &app, SLOT(quit()));
- 	ret = app.exec();
- 
- #ifdef CONFIG_NATIVE_WINDOWS
- 	WSACleanup();
- #endif /* CONFIG_NATIVE_WINDOWS */
- 
- 	return ret;
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/networkconfig.cpp wpa_view/wpa_suppl/wpa_gui-qt4/networkconfig.cpp
*** wpa_supplicant-0.5.7/wpa_gui-qt4/networkconfig.cpp	Sun Dec 10 02:38:48 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/networkconfig.cpp	Thu Jan  1 02:00:00 1970
***************
*** 1,582 ****
- /*
-  * wpa_gui - NetworkConfig class
-  * Copyright (c) 2005-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #include <QMessageBox>
- 
- #include "networkconfig.h"
- #include "wpagui.h"
- 
- enum {
-     AUTH_NONE = 0,
-     AUTH_IEEE8021X = 1,
-     AUTH_WPA_PSK = 2,
-     AUTH_WPA_EAP = 3,
-     AUTH_WPA2_PSK = 4,
-     AUTH_WPA2_EAP = 5
- };
- 
- #define WPA_GUI_KEY_DATA "[key is configured]"
- 
- 
- NetworkConfig::NetworkConfig(QWidget *parent, const char *, bool, Qt::WFlags)
- 	: QDialog(parent)
- {
- 	setupUi(this);
- 
- 	connect(authSelect, SIGNAL(activated(int)), this,
- 		SLOT(authChanged(int)));
- 	connect(cancelButton, SIGNAL(clicked()), this, SLOT(close()));
- 	connect(addButton, SIGNAL(clicked()), this, SLOT(addNetwork()));
- 	connect(encrSelect, SIGNAL(activated(const QString &)), this,
- 		SLOT(encrChanged(const QString &)));
- 	connect(removeButton, SIGNAL(clicked()), this, SLOT(removeNetwork()));
- 
- 	wpagui = NULL;
- 	new_network = false;
- }
- 
- 
- NetworkConfig::~NetworkConfig()
- {
- }
- 
- 
- void NetworkConfig::languageChange()
- {
- 	retranslateUi(this);
- }
- 
- 
- void NetworkConfig::paramsFromScanResults(Q3ListViewItem *sel)
- {
- 	new_network = true;
- 
- 	/* SSID BSSID frequency signal flags */
- 	setCaption(sel->text(0));
- 	ssidEdit->setText(sel->text(0));
- 
- 	QString flags = sel->text(4);
- 	int auth, encr = 0;
- 	if (flags.find("[WPA2-EAP") >= 0)
- 		auth = AUTH_WPA2_EAP;
- 	else if (flags.find("[WPA-EAP") >= 0)
- 		auth = AUTH_WPA_EAP;
- 	else if (flags.find("[WPA2-PSK") >= 0)
- 		auth = AUTH_WPA2_PSK;
- 	else if (flags.find("[WPA-PSK") >= 0)
- 		auth = AUTH_WPA_PSK;
- 	else
- 		auth = AUTH_NONE;
- 
- 	if (flags.find("-CCMP") >= 0)
- 		encr = 1;
- 	else if (flags.find("-TKIP") >= 0)
- 		encr = 0;
- 	else if (flags.find("WEP") >= 0)
- 		encr = 1;
- 	else
- 		encr = 0;
- 
- 	authSelect->setCurrentItem(auth);
- 	authChanged(auth);
- 	encrSelect->setCurrentItem(encr);
- 
- 	getEapCapa();
- }
- 
- 
- void NetworkConfig::authChanged(int sel)
- {
- 	pskEdit->setEnabled(sel == AUTH_WPA_PSK || sel == AUTH_WPA2_PSK);
- 	bool eap = sel == AUTH_IEEE8021X || sel == AUTH_WPA_EAP ||
- 		sel == AUTH_WPA2_EAP;
- 	eapSelect->setEnabled(eap);
- 	identityEdit->setEnabled(eap);
- 	passwordEdit->setEnabled(eap);
- 	cacertEdit->setEnabled(eap);
- 
- 	while (encrSelect->count())
- 		encrSelect->removeItem(0);
- 
- 	if (sel == AUTH_NONE || sel == AUTH_IEEE8021X) {
- 		encrSelect->insertItem("None");
- 		encrSelect->insertItem("WEP");
- 		encrSelect->setCurrentItem(sel == AUTH_NONE ? 0 : 1);
- 	} else {
- 		encrSelect->insertItem("TKIP");
- 		encrSelect->insertItem("CCMP");
- 		encrSelect->setCurrentItem((sel == AUTH_WPA2_PSK ||
- 					    sel == AUTH_WPA2_EAP) ? 1 : 0);
- 	}
- 
- 	wepEnabled(sel == AUTH_IEEE8021X);
- }
- 
- 
- void NetworkConfig::addNetwork()
- {
- 	char reply[10], cmd[256];
- 	size_t reply_len;
- 	int id;
- 	int psklen = pskEdit->text().length();
- 	int auth = authSelect->currentItem();
- 
- 	if (auth == AUTH_WPA_PSK || auth == AUTH_WPA2_PSK) {
- 		if (psklen < 8 || psklen > 64) {
- 			QMessageBox::warning(this, "wpa_gui",
- 					     "WPA-PSK requires a passphrase "
- 					     "of 8 to 63 characters\n"
- 					     "or 64 hex digit PSK");
- 			return;
- 		}
- 	}
- 
- 	if (wpagui == NULL)
- 		return;
- 
- 	memset(reply, 0, sizeof(reply));
- 	reply_len = sizeof(reply) - 1;
- 
- 	if (new_network) {
- 		wpagui->ctrlRequest("ADD_NETWORK", reply, &reply_len);
- 		if (reply[0] == 'F') {
- 			QMessageBox::warning(this, "wpa_gui", "Failed to add "
- 					     "network to wpa_supplicant\n"
- 					     "configuration.");
- 			return;
- 		}
- 		id = atoi(reply);
- 	} else
- 		id = edit_network_id;
- 
- 	setNetworkParam(id, "ssid", ssidEdit->text().ascii(), true);
- 
- 	char *key_mgmt = NULL, *proto = NULL, *pairwise = NULL;
- 	switch (auth) {
- 	case AUTH_NONE:
- 		key_mgmt = "NONE";
- 		break;
- 	case AUTH_IEEE8021X:
- 		key_mgmt = "IEEE8021X";
- 		break;
- 	case AUTH_WPA_PSK:
- 		key_mgmt = "WPA-PSK";
- 		proto = "WPA";
- 		break;
- 	case AUTH_WPA_EAP:
- 		key_mgmt = "WPA-EAP";
- 		proto = "WPA";
- 		break;
- 	case AUTH_WPA2_PSK:
- 		key_mgmt = "WPA-PSK";
- 		proto = "WPA2";
- 		break;
- 	case AUTH_WPA2_EAP:
- 		key_mgmt = "WPA-EAP";
- 		proto = "WPA2";
- 		break;
- 	}
- 
- 	if (auth == AUTH_WPA_PSK || auth == AUTH_WPA_EAP ||
- 	    auth == AUTH_WPA2_PSK || auth == AUTH_WPA2_EAP) {
- 		int encr = encrSelect->currentItem();
- 		if (encr == 0)
- 			pairwise = "TKIP";
- 		else
- 			pairwise = "CCMP";
- 	}
- 
- 	if (proto)
- 		setNetworkParam(id, "proto", proto, false);
- 	if (key_mgmt)
- 		setNetworkParam(id, "key_mgmt", key_mgmt, false);
- 	if (pairwise) {
- 		setNetworkParam(id, "pairwise", pairwise, false);
- 		setNetworkParam(id, "group", "TKIP CCMP WEP104 WEP40", false);
- 	}
- 	if (pskEdit->isEnabled() &&
- 	    strcmp(passwordEdit->text().ascii(), WPA_GUI_KEY_DATA) != 0)
- 		setNetworkParam(id, "psk", pskEdit->text().ascii(),
- 				psklen != 64);
- 	if (eapSelect->isEnabled())
- 		setNetworkParam(id, "eap", eapSelect->currentText().ascii(),
- 				false);
- 	if (identityEdit->isEnabled())
- 		setNetworkParam(id, "identity", identityEdit->text().ascii(),
- 				true);
- 	if (passwordEdit->isEnabled() &&
- 	    strcmp(passwordEdit->text().ascii(), WPA_GUI_KEY_DATA) != 0)
- 		setNetworkParam(id, "password", passwordEdit->text().ascii(),
- 				true);
- 	if (cacertEdit->isEnabled())
- 		setNetworkParam(id, "ca_cert", cacertEdit->text().ascii(),
- 				true);
- 	writeWepKey(id, wep0Edit, 0);
- 	writeWepKey(id, wep1Edit, 1);
- 	writeWepKey(id, wep2Edit, 2);
- 	writeWepKey(id, wep3Edit, 3);
- 
- 	if (wep0Radio->isEnabled() && wep0Radio->isChecked())
- 		setNetworkParam(id, "wep_tx_keyidx", "0", false);
- 	else if (wep1Radio->isEnabled() && wep1Radio->isChecked())
- 		setNetworkParam(id, "wep_tx_keyidx", "1", false);
- 	else if (wep2Radio->isEnabled() && wep2Radio->isChecked())
- 		setNetworkParam(id, "wep_tx_keyidx", "2", false);
- 	else if (wep3Radio->isEnabled() && wep3Radio->isChecked())
- 		setNetworkParam(id, "wep_tx_keyidx", "3", false);
- 
- 	snprintf(cmd, sizeof(cmd), "ENABLE_NETWORK %d", id);
- 	reply_len = sizeof(reply);
- 	wpagui->ctrlRequest(cmd, reply, &reply_len);
- 	if (strncmp(reply, "OK", 2) != 0) {
- 		QMessageBox::warning(this, "wpa_gui", "Failed to enable "
- 				     "network in wpa_supplicant\n"
- 				     "configuration.");
- 		/* Network was added, so continue anyway */
- 	}
- 	wpagui->triggerUpdate();
- 	wpagui->ctrlRequest("SAVE_CONFIG", reply, &reply_len);
- 
- 	close();
- }
- 
- 
- void NetworkConfig::setWpaGui(WpaGui *_wpagui)
- {
- 	wpagui = _wpagui;
- }
- 
- 
- int NetworkConfig::setNetworkParam(int id, const char *field,
- 				   const char *value, bool quote)
- {
- 	char reply[10], cmd[256];
- 	size_t reply_len;
- 	snprintf(cmd, sizeof(cmd), "SET_NETWORK %d %s %s%s%s",
- 		 id, field, quote ? "\"" : "", value, quote ? "\"" : "");
- 	reply_len = sizeof(reply);
- 	wpagui->ctrlRequest(cmd, reply, &reply_len);
- 	return strncmp(reply, "OK", 2) == 0 ? 0 : -1;
- }
- 
- 
- void NetworkConfig::encrChanged(const QString &sel)
- {
- 	wepEnabled(sel.find("WEP") == 0);
- }
- 
- 
- void NetworkConfig::wepEnabled(bool enabled)
- {
- 	wep0Edit->setEnabled(enabled);
- 	wep1Edit->setEnabled(enabled);
- 	wep2Edit->setEnabled(enabled);
- 	wep3Edit->setEnabled(enabled);
- 	wep0Radio->setEnabled(enabled);
- 	wep1Radio->setEnabled(enabled);
- 	wep2Radio->setEnabled(enabled);
- 	wep3Radio->setEnabled(enabled);
- }
- 
- 
- void NetworkConfig::writeWepKey(int network_id, QLineEdit *edit, int id)
- {
- 	char buf[10];
- 	bool hex;
- 	const char *txt, *pos;
- 	size_t len;
- 
- 	if (!edit->isEnabled() || edit->text().isEmpty())
- 		return;
- 
- 	/*
- 	 * Assume hex key if only hex characters are present and length matches
- 	 * with 40, 104, or 128-bit key
- 	 */
- 	txt = edit->text().ascii();
- 	if (strcmp(txt, WPA_GUI_KEY_DATA) == 0)
- 		return;
- 	len = strlen(txt);
- 	if (len == 0)
- 		return;
- 	pos = txt;
- 	hex = true;
- 	while (*pos) {
- 		if (!((*pos >= '0' && *pos <= '9') ||
- 		      (*pos >= 'a' && *pos <= 'f') ||
- 		      (*pos >= 'A' && *pos <= 'F'))) {
- 			hex = false;
- 			break;
- 		}
- 		pos++;
- 	}
- 	if (hex && len != 10 && len != 26 && len != 32)
- 		hex = false;
- 	snprintf(buf, sizeof(buf), "wep_key%d", id);
- 	setNetworkParam(network_id, buf, txt, !hex);
- }
- 
- 
- static int key_value_isset(const char *reply, size_t reply_len)
- {
-     return reply_len > 0 && (reply_len < 4 || memcmp(reply, "FAIL", 4) != 0);
- }
- 
- 
- void NetworkConfig::paramsFromConfig(int network_id)
- {
- 	int i, res;
- 
- 	edit_network_id = network_id;
- 	getEapCapa();
- 
- 	char reply[1024], cmd[256], *pos;
- 	size_t reply_len;
- 
- 	snprintf(cmd, sizeof(cmd), "GET_NETWORK %d ssid", network_id);
- 	reply_len = sizeof(reply) - 1;
- 	if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0 &&
- 	    reply_len >= 2 && reply[0] == '"') {
- 		reply[reply_len] = '\0';
- 		pos = strchr(reply + 1, '"');
- 		if (pos)
- 			*pos = '\0';
- 		ssidEdit->setText(reply + 1);
- 	}
- 
- 	snprintf(cmd, sizeof(cmd), "GET_NETWORK %d proto", network_id);
- 	reply_len = sizeof(reply) - 1;
- 	int wpa = 0;
- 	if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0) {
- 		reply[reply_len] = '\0';
- 		if (strstr(reply, "RSN") || strstr(reply, "WPA2"))
- 			wpa = 2;
- 		else if (strstr(reply, "WPA"))
- 			wpa = 1;
- 	}
- 
- 	int auth = AUTH_NONE, encr = 0;
- 	snprintf(cmd, sizeof(cmd), "GET_NETWORK %d key_mgmt", network_id);
- 	reply_len = sizeof(reply) - 1;
- 	if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0) {
- 		reply[reply_len] = '\0';
- 		if (strstr(reply, "WPA-EAP"))
- 			auth = wpa & 2 ? AUTH_WPA2_EAP : AUTH_WPA_EAP;
- 		else if (strstr(reply, "WPA-PSK"))
- 			auth = wpa & 2 ? AUTH_WPA2_PSK : AUTH_WPA_PSK;
- 		else if (strstr(reply, "IEEE8021X")) {
- 			auth = AUTH_IEEE8021X;
- 			encr = 1;
- 		}
- 	}
- 
- 	snprintf(cmd, sizeof(cmd), "GET_NETWORK %d pairwise", network_id);
- 	reply_len = sizeof(reply) - 1;
- 	if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0) {
- 		reply[reply_len] = '\0';
- 		if (strstr(reply, "CCMP"))
- 			encr = 1;
- 		else if (strstr(reply, "TKIP"))
- 			encr = 0;
- 		else if (strstr(reply, "WEP"))
- 			encr = 1;
- 		else
- 			encr = 0;
- 	}
- 
- 	snprintf(cmd, sizeof(cmd), "GET_NETWORK %d psk", network_id);
- 	reply_len = sizeof(reply) - 1;
- 	res = wpagui->ctrlRequest(cmd, reply, &reply_len);
- 	if (res >= 0 && reply_len >= 2 && reply[0] == '"') {
- 		reply[reply_len] = '\0';
- 		pos = strchr(reply + 1, '"');
- 		if (pos)
- 			*pos = '\0';
- 		pskEdit->setText(reply + 1);
- 	} else if (res >= 0 && key_value_isset(reply, reply_len)) {
- 		pskEdit->setText(WPA_GUI_KEY_DATA);
- 	}
- 
- 	snprintf(cmd, sizeof(cmd), "GET_NETWORK %d identity", network_id);
- 	reply_len = sizeof(reply) - 1;
- 	if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0 &&
- 	    reply_len >= 2 && reply[0] == '"') {
- 		reply[reply_len] = '\0';
- 		pos = strchr(reply + 1, '"');
- 		if (pos)
- 			*pos = '\0';
- 		identityEdit->setText(reply + 1);
- 	}
- 
- 	snprintf(cmd, sizeof(cmd), "GET_NETWORK %d password", network_id);
- 	reply_len = sizeof(reply) - 1;
- 	res = wpagui->ctrlRequest(cmd, reply, &reply_len);
- 	if (res >= 0 && reply_len >= 2 && reply[0] == '"') {
- 		reply[reply_len] = '\0';
- 		pos = strchr(reply + 1, '"');
- 		if (pos)
- 			*pos = '\0';
- 		passwordEdit->setText(reply + 1);
- 	} else if (res >= 0 && key_value_isset(reply, reply_len)) {
- 		passwordEdit->setText(WPA_GUI_KEY_DATA);
- 	}
- 
- 	snprintf(cmd, sizeof(cmd), "GET_NETWORK %d ca_cert", network_id);
- 	reply_len = sizeof(reply) - 1;
- 	if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0 &&
- 	    reply_len >= 2 && reply[0] == '"') {
- 		reply[reply_len] = '\0';
- 		pos = strchr(reply + 1, '"');
- 		if (pos)
- 			*pos = '\0';
- 		cacertEdit->setText(reply + 1);
- 	}
- 
- 	snprintf(cmd, sizeof(cmd), "GET_NETWORK %d eap", network_id);
- 	reply_len = sizeof(reply) - 1;
- 	if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0 &&
- 	    reply_len >= 1) {
- 		reply[reply_len] = '\0';
- 		for (i = 0; i < eapSelect->count(); i++) {
- 			if (eapSelect->text(i).compare(reply) == 0) {
- 				eapSelect->setCurrentItem(i);
- 				break;
- 			}
- 		}
- 	}
- 
- 	for (i = 0; i < 4; i++) {
- 		QLineEdit *wepEdit;
- 		switch (i) {
- 		default:
- 		case 0:
- 			wepEdit = wep0Edit;
- 			break;
- 		case 1:
- 			wepEdit = wep1Edit;
- 			break;
- 		case 2:
- 			wepEdit = wep2Edit;
- 			break;
- 		case 3:
- 			wepEdit = wep3Edit;
- 			break;
- 		}
- 		snprintf(cmd, sizeof(cmd), "GET_NETWORK %d wep_key%d",
- 			 network_id, i);
- 		reply_len = sizeof(reply) - 1;
- 		res = wpagui->ctrlRequest(cmd, reply, &reply_len);
- 		if (res >= 0 && reply_len >= 2 && reply[0] == '"') {
- 			reply[reply_len] = '\0';
- 			pos = strchr(reply + 1, '"');
- 			if (pos)
- 				*pos = '\0';
- 			if (auth == AUTH_NONE || auth == AUTH_IEEE8021X)
- 				encr = 1;
- 
- 			wepEdit->setText(reply + 1);
- 		} else if (res >= 0 && key_value_isset(reply, reply_len)) {
- 			if (auth == AUTH_NONE || auth == AUTH_IEEE8021X)
- 				encr = 1;
- 			wepEdit->setText(WPA_GUI_KEY_DATA);
- 		}
- 	}
- 
- 	snprintf(cmd, sizeof(cmd), "GET_NETWORK %d wep_tx_keyidx", network_id);
- 	reply_len = sizeof(reply) - 1;
- 	if (wpagui->ctrlRequest(cmd, reply, &reply_len) >= 0 && reply_len >= 1)
- 	{
- 		reply[reply_len] = '\0';
- 		switch (atoi(reply)) {
- 		case 0:
- 			wep0Radio->setChecked(true);
- 			break;
- 		case 1:
- 			wep1Radio->setChecked(true);
- 			break;
- 		case 2:
- 			wep2Radio->setChecked(true);
- 			break;
- 		case 3:
- 			wep3Radio->setChecked(true);
- 			break;
- 		}
- 	}
- 
- 	authSelect->setCurrentItem(auth);
- 	authChanged(auth);
- 	encrSelect->setCurrentItem(encr);
- 	if (auth == AUTH_NONE || auth == AUTH_IEEE8021X)
- 		wepEnabled(encr == 1);
- 
- 	removeButton->setEnabled(true);
- 	addButton->setText("Save");
- }
- 
- 
- void NetworkConfig::removeNetwork()
- {
- 	char reply[10], cmd[256];
- 	size_t reply_len;
- 
- 	if (QMessageBox::information(this, "wpa_gui",
- 				     "This will permanently remove the "
- 				     "network\n"
- 				     "from the configuration. Do you really "
- 				     "want\n"
- 				     "to remove this network?", "Yes", "No")
- 	    != 0)
- 		return;
- 
- 	snprintf(cmd, sizeof(cmd), "REMOVE_NETWORK %d", edit_network_id);
- 	reply_len = sizeof(reply);
- 	wpagui->ctrlRequest(cmd, reply, &reply_len);
- 	if (strncmp(reply, "OK", 2) != 0) {
- 		QMessageBox::warning(this, "wpa_gui",
- 				     "Failed to remove network from "
- 				     "wpa_supplicant\n"
- 				     "configuration.");
- 	} else {
- 		wpagui->triggerUpdate();
- 		wpagui->ctrlRequest("SAVE_CONFIG", reply, &reply_len);
- 	}
- 
- 	close();
- }
- 
- 
- void NetworkConfig::newNetwork()
- {
- 	new_network = true;
- 	getEapCapa();
- }
- 
- 
- void NetworkConfig::getEapCapa()
- {
- 	char reply[256];
- 	size_t reply_len;
- 
- 	if (wpagui == NULL)
- 		return;
- 
- 	reply_len = sizeof(reply) - 1;
- 	if (wpagui->ctrlRequest("GET_CAPABILITY eap", reply, &reply_len) < 0)
- 		return;
- 	reply[reply_len] = '\0';
- 
- 	QString res(reply);
- 	QStringList types = QStringList::split(QChar(' '), res);
- 	eapSelect->insertStringList(types);
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/networkconfig.h wpa_view/wpa_suppl/wpa_gui-qt4/networkconfig.h
*** wpa_supplicant-0.5.7/wpa_gui-qt4/networkconfig.h	Mon Aug 28 09:15:35 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/networkconfig.h	Thu Jan  1 02:00:00 1970
***************
*** 1,58 ****
- /*
-  * wpa_gui - NetworkConfig class
-  * Copyright (c) 2005-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #ifndef NETWORKCONFIG_H
- #define NETWORKCONFIG_H
- 
- #include <QObject>
- #include "ui_networkconfig.h"
- 
- class WpaGui;
- 
- class NetworkConfig : public QDialog, public Ui::NetworkConfig
- {
- 	Q_OBJECT
- 
- public:
- 	NetworkConfig(QWidget *parent = 0, const char *name = 0,
- 		      bool modal = false, Qt::WFlags fl = 0);
- 	~NetworkConfig();
- 
- 	virtual void paramsFromScanResults(Q3ListViewItem *sel);
- 	virtual void setWpaGui(WpaGui *_wpagui);
- 	virtual int setNetworkParam(int id, const char *field,
- 				    const char *value, bool quote);
- 	virtual void paramsFromConfig(int network_id);
- 	virtual void newNetwork();
- 
- public slots:
- 	virtual void authChanged(int sel);
- 	virtual void addNetwork();
- 	virtual void encrChanged(const QString &sel);
- 	virtual void writeWepKey(int network_id, QLineEdit *edit, int id);
- 	virtual void removeNetwork();
- 
- protected slots:
- 	virtual void languageChange();
- 
- private:
- 	WpaGui *wpagui;
- 	int edit_network_id;
- 	bool new_network;
- 
- 	virtual void wepEnabled(bool enabled);
- 	virtual void getEapCapa();
- };
- 
- #endif /* NETWORKCONFIG_H */
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/networkconfig.ui wpa_view/wpa_suppl/wpa_gui-qt4/networkconfig.ui
*** wpa_supplicant-0.5.7/wpa_gui-qt4/networkconfig.ui	Mon Aug 28 04:00:18 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/networkconfig.ui	Thu Jan  1 02:00:00 1970
***************
*** 1,356 ****
- <ui version="4.0" stdsetdef="1" >
-   <author></author>
-   <comment></comment>
-   <exportmacro></exportmacro>
-   <class>NetworkConfig</class>
-   <widget class="QDialog" name="NetworkConfig" >
-     <property name="geometry" >
-       <rect>
-         <x>0</x>
-         <y>0</y>
-         <width>380</width>
-         <height>413</height>
-       </rect>
-     </property>
-     <property name="windowTitle" >
-       <string>NetworkConfig</string>
-     </property>
-     <layout class="QGridLayout" >
-       <item row="1" column="3" >
-         <widget class="QPushButton" name="cancelButton" >
-           <property name="text" >
-             <string>Cancel</string>
-           </property>
-         </widget>
-       </item>
-       <item rowspan="1" row="0" column="0" colspan="4" >
-         <widget class="QFrame" name="frame9" >
-           <property name="frameShape" >
-             <enum>StyledPanel</enum>
-           </property>
-           <property name="frameShadow" >
-             <enum>Raised</enum>
-           </property>
-           <layout class="QGridLayout" >
-             <item row="0" column="0" >
-               <widget class="QLabel" name="textLabel1" >
-                 <property name="text" >
-                   <string>SSID</string>
-                 </property>
-               </widget>
-             </item>
-             <item row="0" column="1" >
-               <widget class="QLineEdit" name="ssidEdit" >
-                 <property name="text" >
-                   <string/>
-                 </property>
-                 <property name="toolTip" stdset="0" >
-                   <string>Network name (Service Set IDentifier)</string>
-                 </property>
-               </widget>
-             </item>
-             <item row="1" column="0" >
-               <widget class="QLabel" name="textLabel2" >
-                 <property name="text" >
-                   <string>Authentication</string>
-                 </property>
-               </widget>
-             </item>
-             <item row="1" column="1" >
-               <widget class="QComboBox" name="authSelect" >
-                 <item>
-                   <property name="text" >
-                     <string>Plaintext or static WEP</string>
-                   </property>
-                 </item>
-                 <item>
-                   <property name="text" >
-                     <string>IEEE 802.1X</string>
-                   </property>
-                 </item>
-                 <item>
-                   <property name="text" >
-                     <string>WPA-Personal (PSK)</string>
-                   </property>
-                 </item>
-                 <item>
-                   <property name="text" >
-                     <string>WPA-Enterprise (EAP)</string>
-                   </property>
-                 </item>
-                 <item>
-                   <property name="text" >
-                     <string>WPA2-Personal (PSK)</string>
-                   </property>
-                 </item>
-                 <item>
-                   <property name="text" >
-                     <string>WPA2-Enterprise (EAP)</string>
-                   </property>
-                 </item>
-               </widget>
-             </item>
-             <item row="2" column="0" >
-               <widget class="QLabel" name="textLabel3" >
-                 <property name="text" >
-                   <string>Encryption</string>
-                 </property>
-               </widget>
-             </item>
-             <item row="2" column="1" >
-               <widget class="QComboBox" name="encrSelect" >
-                 <item>
-                   <property name="text" >
-                     <string>None</string>
-                   </property>
-                 </item>
-                 <item>
-                   <property name="text" >
-                     <string>WEP</string>
-                   </property>
-                 </item>
-                 <item>
-                   <property name="text" >
-                     <string>TKIP</string>
-                   </property>
-                 </item>
-                 <item>
-                   <property name="text" >
-                     <string>CCMP</string>
-                   </property>
-                 </item>
-               </widget>
-             </item>
-             <item row="3" column="0" >
-               <widget class="QLabel" name="textLabel4" >
-                 <property name="text" >
-                   <string>PSK</string>
-                 </property>
-               </widget>
-             </item>
-             <item row="3" column="1" >
-               <widget class="QLineEdit" name="pskEdit" >
-                 <property name="enabled" >
-                   <bool>false</bool>
-                 </property>
-                 <property name="echoMode" >
-                   <enum>QLineEdit::Password</enum>
-                 </property>
-                 <property name="toolTip" stdset="0" >
-                   <string>WPA/WPA2 pre-shared key or passphrase</string>
-                 </property>
-                 <property name="whatsThis" stdset="0" >
-                   <string/>
-                 </property>
-               </widget>
-             </item>
-             <item row="4" column="0" >
-               <widget class="QLabel" name="textLabel5" >
-                 <property name="text" >
-                   <string>EAP method</string>
-                 </property>
-               </widget>
-             </item>
-             <item row="4" column="1" >
-               <widget class="QComboBox" name="eapSelect" >
-                 <property name="enabled" >
-                   <bool>false</bool>
-                 </property>
-               </widget>
-             </item>
-             <item row="5" column="0" >
-               <widget class="QLabel" name="textLabel6" >
-                 <property name="text" >
-                   <string>Identity</string>
-                 </property>
-               </widget>
-             </item>
-             <item row="5" column="1" >
-               <widget class="QLineEdit" name="identityEdit" >
-                 <property name="enabled" >
-                   <bool>false</bool>
-                 </property>
-                 <property name="toolTip" stdset="0" >
-                   <string>Username/Identity for EAP methods</string>
-                 </property>
-               </widget>
-             </item>
-             <item row="6" column="0" >
-               <widget class="QLabel" name="textLabel7" >
-                 <property name="text" >
-                   <string>Password</string>
-                 </property>
-               </widget>
-             </item>
-             <item row="6" column="1" >
-               <widget class="QLineEdit" name="passwordEdit" >
-                 <property name="enabled" >
-                   <bool>false</bool>
-                 </property>
-                 <property name="echoMode" >
-                   <enum>QLineEdit::Password</enum>
-                 </property>
-                 <property name="toolTip" stdset="0" >
-                   <string>Password for EAP methods</string>
-                 </property>
-               </widget>
-             </item>
-             <item row="7" column="0" >
-               <widget class="QLabel" name="textLabel1_2" >
-                 <property name="text" >
-                   <string>CA certificate</string>
-                 </property>
-               </widget>
-             </item>
-             <item row="7" column="1" >
-               <widget class="QLineEdit" name="cacertEdit" >
-                 <property name="enabled" >
-                   <bool>false</bool>
-                 </property>
-               </widget>
-             </item>
-             <item rowspan="1" row="8" column="0" colspan="2" >
-               <widget class="QGroupBox" name="buttonGroup1" >
-                 <property name="enabled" >
-                   <bool>true</bool>
-                 </property>
-                 <property name="title" >
-                   <string>WEP keys</string>
-                 </property>
-                 <layout class="QGridLayout" >
-                   <item row="0" column="0" >
-                     <widget class="QRadioButton" name="wep0Radio" >
-                       <property name="enabled" >
-                         <bool>false</bool>
-                       </property>
-                       <property name="text" >
-                         <string>key 0</string>
-                       </property>
-                     </widget>
-                   </item>
-                   <item row="1" column="0" >
-                     <widget class="QRadioButton" name="wep1Radio" >
-                       <property name="enabled" >
-                         <bool>false</bool>
-                       </property>
-                       <property name="text" >
-                         <string>key 1</string>
-                       </property>
-                     </widget>
-                   </item>
-                   <item row="3" column="0" >
-                     <widget class="QRadioButton" name="wep3Radio" >
-                       <property name="enabled" >
-                         <bool>false</bool>
-                       </property>
-                       <property name="text" >
-                         <string>key 3</string>
-                       </property>
-                     </widget>
-                   </item>
-                   <item row="2" column="0" >
-                     <widget class="QRadioButton" name="wep2Radio" >
-                       <property name="enabled" >
-                         <bool>false</bool>
-                       </property>
-                       <property name="text" >
-                         <string>key 2</string>
-                       </property>
-                     </widget>
-                   </item>
-                   <item row="0" column="1" >
-                     <widget class="QLineEdit" name="wep0Edit" >
-                       <property name="enabled" >
-                         <bool>false</bool>
-                       </property>
-                     </widget>
-                   </item>
-                   <item row="1" column="1" >
-                     <widget class="QLineEdit" name="wep1Edit" >
-                       <property name="enabled" >
-                         <bool>false</bool>
-                       </property>
-                     </widget>
-                   </item>
-                   <item row="2" column="1" >
-                     <widget class="QLineEdit" name="wep2Edit" >
-                       <property name="enabled" >
-                         <bool>false</bool>
-                       </property>
-                     </widget>
-                   </item>
-                   <item row="3" column="1" >
-                     <widget class="QLineEdit" name="wep3Edit" >
-                       <property name="enabled" >
-                         <bool>false</bool>
-                       </property>
-                     </widget>
-                   </item>
-                 </layout>
-               </widget>
-             </item>
-           </layout>
-         </widget>
-       </item>
-       <item row="1" column="0" >
-         <spacer name="spacer5" >
-           <property name="sizeHint" >
-             <size>
-               <width>130</width>
-               <height>20</height>
-             </size>
-           </property>
-           <property name="sizeType" >
-             <enum>Expanding</enum>
-           </property>
-           <property name="orientation" >
-             <enum>Horizontal</enum>
-           </property>
-         </spacer>
-       </item>
-       <item row="1" column="1" >
-         <widget class="QPushButton" name="addButton" >
-           <property name="text" >
-             <string>Add</string>
-           </property>
-         </widget>
-       </item>
-       <item row="1" column="2" >
-         <widget class="QPushButton" name="removeButton" >
-           <property name="enabled" >
-             <bool>false</bool>
-           </property>
-           <property name="text" >
-             <string>Remove</string>
-           </property>
-         </widget>
-       </item>
-     </layout>
-   </widget>
-   <layoutdefault spacing="6" margin="11" />
-   <pixmapfunction>qPixmapFromMimeSource</pixmapfunction>
-   <tabstops>
-     <tabstop>ssidEdit</tabstop>
-     <tabstop>authSelect</tabstop>
-     <tabstop>encrSelect</tabstop>
-     <tabstop>pskEdit</tabstop>
-     <tabstop>eapSelect</tabstop>
-     <tabstop>identityEdit</tabstop>
-     <tabstop>passwordEdit</tabstop>
-     <tabstop>cacertEdit</tabstop>
-     <tabstop>wep0Radio</tabstop>
-     <tabstop>wep1Radio</tabstop>
-     <tabstop>wep2Radio</tabstop>
-     <tabstop>wep3Radio</tabstop>
-     <tabstop>wep0Edit</tabstop>
-     <tabstop>wep1Edit</tabstop>
-     <tabstop>wep2Edit</tabstop>
-     <tabstop>wep3Edit</tabstop>
-     <tabstop>addButton</tabstop>
-     <tabstop>removeButton</tabstop>
-     <tabstop>cancelButton</tabstop>
-   </tabstops>
-   <includes>
-     <include location="global" >q3listview.h</include>
-   </includes>
- </ui>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/scanresults.cpp wpa_view/wpa_suppl/wpa_gui-qt4/scanresults.cpp
*** wpa_supplicant-0.5.7/wpa_gui-qt4/scanresults.cpp	Sun Aug 27 22:00:11 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/scanresults.cpp	Thu Jan  1 02:00:00 1970
***************
*** 1,124 ****
- /*
-  * wpa_gui - ScanResults class
-  * Copyright (c) 2005-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #include <QTimer>
- 
- #include "scanresults.h"
- #include "wpagui.h"
- #include "networkconfig.h"
- 
- 
- ScanResults::ScanResults(QWidget *parent, const char *, bool, Qt::WFlags)
- 	: QDialog(parent)
- {
- 	setupUi(this);
- 
- 	connect(closeButton, SIGNAL(clicked()), this, SLOT(close()));
- 	connect(scanButton, SIGNAL(clicked()), this, SLOT(scanRequest()));
- 	connect(scanResultsView, SIGNAL(doubleClicked(Q3ListViewItem *)), this,
- 		SLOT(bssSelected(Q3ListViewItem *)));
- 
- 	wpagui = NULL;
- }
- 
- 
- ScanResults::~ScanResults()
- {
- 	delete timer;
- }
- 
- 
- void ScanResults::languageChange()
- {
- 	retranslateUi(this);
- }
- 
- 
- void ScanResults::setWpaGui(WpaGui *_wpagui)
- {
- 	wpagui = _wpagui;
- 	updateResults();
-     
- 	timer = new QTimer(this);
- 	connect(timer, SIGNAL(timeout()), SLOT(getResults()));
- 	timer->start(10000, FALSE);
- }
- 
- 
- void ScanResults::updateResults()
- {
- 	char reply[8192];
- 	size_t reply_len;
-     
- 	if (wpagui == NULL)
- 		return;
- 
- 	reply_len = sizeof(reply) - 1;
- 	if (wpagui->ctrlRequest("SCAN_RESULTS", reply, &reply_len) < 0)
- 		return;
- 	reply[reply_len] = '\0';
- 
- 	scanResultsView->clear();
-     
- 	QString res(reply);
- 	QStringList lines = QStringList::split(QChar('\n'), res);
- 	bool first = true;
- 	for (QStringList::Iterator it = lines.begin(); it != lines.end(); it++)
- 	{
- 		if (first) {
- 			first = false;
- 			continue;
- 		}
- 	
- 		QStringList cols = QStringList::split(QChar('\t'), *it, true);
- 		QString ssid, bssid, freq, signal, flags;
- 		bssid = cols.count() > 0 ? cols[0] : "";
- 		freq = cols.count() > 1 ? cols[1] : "";
- 		signal = cols.count() > 2 ? cols[2] : "";
- 		flags = cols.count() > 3 ? cols[3] : "";
- 		ssid = cols.count() > 4 ? cols[4] : "";
- 		new Q3ListViewItem(scanResultsView, ssid, bssid, freq, signal,
- 				   flags);
- 	}
- }
- 
- 
- void ScanResults::scanRequest()
- {
- 	char reply[10];
- 	size_t reply_len = sizeof(reply);
-     
- 	if (wpagui == NULL)
- 		return;
-     
- 	wpagui->ctrlRequest("SCAN", reply, &reply_len);
- }
- 
- 
- void ScanResults::getResults()
- {
- 	updateResults();
- }
- 
- 
- void ScanResults::bssSelected( Q3ListViewItem * sel )
- {
- 	NetworkConfig *nc = new NetworkConfig();
- 	if (nc == NULL)
- 		return;
- 	nc->setWpaGui(wpagui);
- 	nc->paramsFromScanResults(sel);
- 	nc->show();
- 	nc->exec();
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/scanresults.h wpa_view/wpa_suppl/wpa_gui-qt4/scanresults.h
*** wpa_supplicant-0.5.7/wpa_gui-qt4/scanresults.h	Mon Aug 28 09:15:35 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/scanresults.h	Thu Jan  1 02:00:00 1970
***************
*** 1,47 ****
- /*
-  * wpa_gui - ScanResults class
-  * Copyright (c) 2005-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #ifndef SCANRESULTS_H
- #define SCANRESULTS_H
- 
- #include <QObject>
- #include "ui_scanresults.h"
- 
- class WpaGui;
- 
- class ScanResults : public QDialog, public Ui::ScanResults
- {
- 	Q_OBJECT
- 
- public:
- 	ScanResults(QWidget *parent = 0, const char *name = 0,
- 		    bool modal = false, Qt::WFlags fl = 0);
- 	~ScanResults();
- 
- public slots:
- 	virtual void setWpaGui(WpaGui *_wpagui);
- 	virtual void updateResults();
- 	virtual void scanRequest();
- 	virtual void getResults();
- 	virtual void bssSelected(Q3ListViewItem *sel);
- 
- protected slots:
- 	virtual void languageChange();
- 
- private:
- 	WpaGui *wpagui;
- 	QTimer *timer;
- };
- 
- #endif /* SCANRESULTS_H */
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/scanresults.ui wpa_view/wpa_suppl/wpa_gui-qt4/scanresults.ui
*** wpa_supplicant-0.5.7/wpa_gui-qt4/scanresults.ui	Sun Aug 27 22:00:11 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/scanresults.ui	Thu Jan  1 02:00:00 1970
***************
*** 1,125 ****
- <ui version="4.0" stdsetdef="1" >
-   <author></author>
-   <comment></comment>
-   <exportmacro></exportmacro>
-   <class>ScanResults</class>
-   <widget class="QDialog" name="ScanResults" >
-     <property name="geometry" >
-       <rect>
-         <x>0</x>
-         <y>0</y>
-         <width>452</width>
-         <height>225</height>
-       </rect>
-     </property>
-     <property name="windowTitle" >
-       <string>Scan results</string>
-     </property>
-     <layout class="QVBoxLayout" >
-       <item>
-         <widget class="Q3ListView" name="scanResultsView" >
-           <property name="frameShape" >
-             <enum>QFrame::StyledPanel</enum>
-           </property>
-           <property name="frameShadow" >
-             <enum>QFrame::Sunken</enum>
-           </property>
-           <column>
-             <property name="text" >
-               <string>SSID</string>
-             </property>
-             <property name="clickable" >
-               <bool>true</bool>
-             </property>
-             <property name="resizable" >
-               <bool>true</bool>
-             </property>
-           </column>
-           <column>
-             <property name="text" >
-               <string>BSSID</string>
-             </property>
-             <property name="clickable" >
-               <bool>true</bool>
-             </property>
-             <property name="resizable" >
-               <bool>true</bool>
-             </property>
-           </column>
-           <column>
-             <property name="text" >
-               <string>frequency</string>
-             </property>
-             <property name="clickable" >
-               <bool>true</bool>
-             </property>
-             <property name="resizable" >
-               <bool>true</bool>
-             </property>
-           </column>
-           <column>
-             <property name="text" >
-               <string>signal</string>
-             </property>
-             <property name="clickable" >
-               <bool>true</bool>
-             </property>
-             <property name="resizable" >
-               <bool>true</bool>
-             </property>
-           </column>
-           <column>
-             <property name="text" >
-               <string>flags</string>
-             </property>
-             <property name="clickable" >
-               <bool>true</bool>
-             </property>
-             <property name="resizable" >
-               <bool>true</bool>
-             </property>
-           </column>
-         </widget>
-       </item>
-       <item>
-         <layout class="QHBoxLayout" >
-           <property name="margin" >
-             <number>0</number>
-           </property>
-           <item>
-             <spacer name="spacer6" >
-               <property name="sizeHint" >
-                 <size>
-                   <width>50</width>
-                   <height>20</height>
-                 </size>
-               </property>
-               <property name="sizeType" >
-                 <enum>Expanding</enum>
-               </property>
-               <property name="orientation" >
-                 <enum>Horizontal</enum>
-               </property>
-             </spacer>
-           </item>
-           <item>
-             <widget class="QPushButton" name="scanButton" >
-               <property name="text" >
-                 <string>Scan</string>
-               </property>
-             </widget>
-           </item>
-           <item>
-             <widget class="QPushButton" name="closeButton" >
-               <property name="text" >
-                 <string>Close</string>
-               </property>
-             </widget>
-           </item>
-         </layout>
-       </item>
-     </layout>
-   </widget>
-   <layoutdefault spacing="6" margin="11" />
-   <pixmapfunction>qPixmapFromMimeSource</pixmapfunction>
- </ui>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/setup-mingw-cross-compiling wpa_view/wpa_suppl/wpa_gui-qt4/setup-mingw-cross-compiling
*** wpa_supplicant-0.5.7/wpa_gui-qt4/setup-mingw-cross-compiling	Sun Aug 21 20:56:59 2005
--- wpa_view/wpa_suppl/wpa_gui-qt4/setup-mingw-cross-compiling	Thu Jan  1 02:00:00 1970
***************
*** 1,11 ****
- #!/bin/sh
- 
- # qmake seems to be forcing include and lib paths from the original build
- # and I have no idea how to change these. For now, just override the
- # directories in the Makefile.Release file after qmake run.
- 
- qmake -spec /q/jm/qt4-win/4.0.0/mkspecs/win32-g++ wpa_gui.pro -o Makefile
- cat Makefile.Release |
-     sed s%qt4/lib%qt4-win/4.0.0/lib%g |
-     sed s%qt4/include%qt4-win/4.0.0/include%g > tmp.Makefile.Release &&
- mv -f tmp.Makefile.Release Makefile.Release
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/userdatarequest.cpp wpa_view/wpa_suppl/wpa_gui-qt4/userdatarequest.cpp
*** wpa_supplicant-0.5.7/wpa_gui-qt4/userdatarequest.cpp	Sun Aug 27 22:00:11 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/userdatarequest.cpp	Thu Jan  1 02:00:00 1970
***************
*** 1,100 ****
- /*
-  * wpa_gui - UserDataRequest class
-  * Copyright (c) 2005-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #include "userdatarequest.h"
- #include "wpagui.h"
- #include "wpa_ctrl.h"
- 
- 
- UserDataRequest::UserDataRequest(QWidget *parent, const char *, bool,
- 				 Qt::WFlags)
- 	: QDialog(parent)
- {
- 	setupUi(this);
- 
- 	connect(buttonOk, SIGNAL(clicked()), this, SLOT(sendReply()));
- 	connect(buttonCancel, SIGNAL(clicked()), this, SLOT(reject()));
- 	connect(queryEdit, SIGNAL(returnPressed()), this, SLOT(sendReply()));
- }
- 
- 
- UserDataRequest::~UserDataRequest()
- {
- }
- 
- 
- void UserDataRequest::languageChange()
- {
- 	retranslateUi(this);
- }
- 
- 
- int UserDataRequest::setParams(WpaGui *_wpagui, const char *reqMsg)
- {
- 	char *tmp, *pos, *pos2;
- 	wpagui = _wpagui;
- 	tmp = strdup(reqMsg);
- 	if (tmp == NULL)
- 		return -1;
- 	pos = strchr(tmp, '-');
- 	if (pos == NULL) {
- 		free(tmp);
- 		return -1;
- 	}
- 	*pos++ = '\0';
- 	field = tmp;
- 	pos2 = strchr(pos, ':');
- 	if (pos2 == NULL) {
- 		free(tmp);
- 		return -1;
- 	}
- 	*pos2++ = '\0';
- 
- 	networkid = atoi(pos);
- 	queryInfo->setText(pos2);
- 	if (strcmp(tmp, "PASSWORD") == 0) {
- 		queryField->setText("Password: ");
- 		queryEdit->setEchoMode(QLineEdit::Password);
- 	} else if (strcmp(tmp, "NEW_PASSWORD") == 0) {
- 		queryField->setText("New password: ");
- 		queryEdit->setEchoMode(QLineEdit::Password);
- 	} else if (strcmp(tmp, "IDENTITY") == 0)
- 		queryField->setText("Identity: ");
- 	else if (strcmp(tmp, "PASSPHRASE") == 0) {
- 		queryField->setText("Private key passphrase: ");
- 		queryEdit->setEchoMode(QLineEdit::Password);
- 	} else
- 		queryField->setText(field + ":");
- 	free(tmp);
- 
- 	return 0;
- }
- 
- 
- void UserDataRequest::sendReply()
- {
- 	char reply[10];
- 	size_t reply_len = sizeof(reply);
- 
- 	if (wpagui == NULL) {
- 		reject();
- 		return;
- 	}
- 
- 	QString cmd = QString(WPA_CTRL_RSP) + field + '-' +
- 		QString::number(networkid) + ':' +
- 		queryEdit->text();
- 	wpagui->ctrlRequest(cmd.ascii(), reply, &reply_len);
- 	accept();
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/userdatarequest.h wpa_view/wpa_suppl/wpa_gui-qt4/userdatarequest.h
*** wpa_supplicant-0.5.7/wpa_gui-qt4/userdatarequest.h	Mon Aug 28 09:15:35 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/userdatarequest.h	Thu Jan  1 02:00:00 1970
***************
*** 1,46 ****
- /*
-  * wpa_gui - UserDataRequest class
-  * Copyright (c) 2005-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #ifndef USERDATAREQUEST_H
- #define USERDATAREQUEST_H
- 
- #include <QObject>
- #include "ui_userdatarequest.h"
- 
- class WpaGui;
- 
- class UserDataRequest : public QDialog, public Ui::UserDataRequest
- {
- 	Q_OBJECT
- 
- public:
- 	UserDataRequest(QWidget *parent = 0, const char *name = 0,
- 			bool modal = false, Qt::WFlags fl = 0);
- 	~UserDataRequest();
- 
- 	int setParams(WpaGui *_wpagui, const char *reqMsg);
- 
- public slots:
- 	virtual void sendReply();
- 
- protected slots:
- 	virtual void languageChange();
- 
- private:
- 	WpaGui *wpagui;
- 	int networkid;
- 	QString field;
- };
- 
- #endif /* USERDATAREQUEST_H */
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/userdatarequest.ui wpa_view/wpa_suppl/wpa_gui-qt4/userdatarequest.ui
*** wpa_supplicant-0.5.7/wpa_gui-qt4/userdatarequest.ui	Sun Aug 27 22:00:11 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/userdatarequest.ui	Thu Jan  1 02:00:00 1970
***************
*** 1,109 ****
- <ui version="4.0" stdsetdef="1" >
-   <author></author>
-   <comment></comment>
-   <exportmacro></exportmacro>
-   <class>UserDataRequest</class>
-   <widget class="QDialog" name="UserDataRequest" >
-     <property name="geometry" >
-       <rect>
-         <x>0</x>
-         <y>0</y>
-         <width>216</width>
-         <height>103</height>
-       </rect>
-     </property>
-     <property name="windowTitle" >
-       <string>Authentication credentials required</string>
-     </property>
-     <property name="sizeGripEnabled" >
-       <bool>true</bool>
-     </property>
-     <layout class="QVBoxLayout" >
-       <item>
-         <widget class="QLabel" name="queryInfo" >
-           <property name="text" >
-             <string/>
-           </property>
-         </widget>
-       </item>
-       <item>
-         <layout class="QHBoxLayout" >
-           <property name="margin" >
-             <number>0</number>
-           </property>
-           <item>
-             <widget class="QLabel" name="queryField" >
-               <property name="text" >
-                 <string/>
-               </property>
-             </widget>
-           </item>
-           <item>
-             <widget class="QLineEdit" name="queryEdit" >
-               <property name="enabled" >
-                 <bool>true</bool>
-               </property>
-               <property name="echoMode" >
-                 <enum>QLineEdit::Password</enum>
-               </property>
-             </widget>
-           </item>
-         </layout>
-       </item>
-       <item>
-         <layout class="QHBoxLayout" >
-           <property name="margin" >
-             <number>0</number>
-           </property>
-           <item>
-             <spacer name="spacer4" >
-               <property name="sizeHint" >
-                 <size>
-                   <width>20</width>
-                   <height>20</height>
-                 </size>
-               </property>
-               <property name="sizeType" >
-                 <enum>Expanding</enum>
-               </property>
-               <property name="orientation" >
-                 <enum>Horizontal</enum>
-               </property>
-             </spacer>
-           </item>
-           <item>
-             <widget class="QPushButton" name="buttonOk" >
-               <property name="text" >
-                 <string>&amp;OK</string>
-               </property>
-               <property name="shortcut" >
-                 <string/>
-               </property>
-               <property name="autoDefault" >
-                 <bool>true</bool>
-               </property>
-               <property name="default" >
-                 <bool>true</bool>
-               </property>
-             </widget>
-           </item>
-           <item>
-             <widget class="QPushButton" name="buttonCancel" >
-               <property name="text" >
-                 <string>&amp;Cancel</string>
-               </property>
-               <property name="shortcut" >
-                 <string/>
-               </property>
-               <property name="autoDefault" >
-                 <bool>true</bool>
-               </property>
-             </widget>
-           </item>
-         </layout>
-       </item>
-     </layout>
-   </widget>
-   <layoutdefault spacing="6" margin="11" />
-   <pixmapfunction>qPixmapFromMimeSource</pixmapfunction>
- </ui>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/wpa_gui.pro wpa_view/wpa_suppl/wpa_gui-qt4/wpa_gui.pro
*** wpa_supplicant-0.5.7/wpa_gui-qt4/wpa_gui.pro	Sun Aug 27 22:00:11 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/wpa_gui.pro	Thu Jan  1 02:00:00 1970
***************
*** 1,50 ****
- TEMPLATE	= app
- LANGUAGE	= C++
- 
- CONFIG	+= qt warn_on release
- 
- DEFINES += CONFIG_CTRL_IFACE
- 
- win32 {
-   LIBS += -lws2_32 -static
-   DEFINES += CONFIG_NATIVE_WINDOWS CONFIG_CTRL_IFACE_NAMED_PIPE
- } else:win32-g++ {
-   # cross compilation to win32
-   LIBS += -lws2_32 -static
-   DEFINES += CONFIG_NATIVE_WINDOWS CONFIG_CTRL_IFACE_NAMED_PIPE
- } else {
-   DEFINES += CONFIG_CTRL_IFACE_UNIX
- }
- 
- INCLUDEPATH	+= . .. ../../hostapd
- 
- HEADERS	+= wpamsg.h \
- 	wpagui.h \
- 	eventhistory.h \
- 	scanresults.h \
- 	userdatarequest.h \
- 	networkconfig.h
- 
- SOURCES	+= main.cpp \
- 	wpagui.cpp \
- 	eventhistory.cpp \
- 	scanresults.cpp \
- 	userdatarequest.cpp \
- 	networkconfig.cpp \
- 	../wpa_ctrl.c
- 
- FORMS	= wpagui.ui \
- 	eventhistory.ui \
- 	scanresults.ui \
- 	userdatarequest.ui \
- 	networkconfig.ui
- 
- 
- unix {
-   UI_DIR = .ui
-   MOC_DIR = .moc
-   OBJECTS_DIR = .obj
- }
- 
- # TODO: remove need for Qt3 support code
- QT += qt3support
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/wpagui.cpp wpa_view/wpa_suppl/wpa_gui-qt4/wpagui.cpp
*** wpa_supplicant-0.5.7/wpa_gui-qt4/wpagui.cpp	Sun Aug 27 22:03:21 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/wpagui.cpp	Thu Jan  1 02:00:00 1970
***************
*** 1,779 ****
- /*
-  * wpa_gui - WpaGui class
-  * Copyright (c) 2005-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #ifdef __MINGW32__
- /* Need to get getopt() */
- #include <unistd.h>
- #endif
- 
- #include <QMessageBox>
- 
- #include "wpagui.h"
- #include "dirent.h"
- #include "wpa_ctrl.h"
- #include "userdatarequest.h"
- #include "networkconfig.h"
- 
- WpaGui::WpaGui(QWidget *parent, const char *, Qt::WFlags)
- 	: QMainWindow(parent)
- {
- 	setupUi(this);
- 
- 	(void) statusBar();
- 
- 	connect(helpIndexAction, SIGNAL(activated()), this, SLOT(helpIndex()));
- 	connect(helpContentsAction, SIGNAL(activated()), this,
- 		SLOT(helpContents()));
- 	connect(helpAboutAction, SIGNAL(activated()), this, SLOT(helpAbout()));
- 	connect(fileExitAction, SIGNAL(activated()), this, SLOT(close()));
- 	connect(disconnectButton, SIGNAL(clicked()), this, SLOT(disconnect()));
- 	connect(scanButton, SIGNAL(clicked()), this, SLOT(scan()));
- 	connect(connectButton, SIGNAL(clicked()), this, SLOT(connectB()));
- 	connect(fileEventHistoryAction, SIGNAL(activated()), this,
- 		SLOT(eventHistory()));
- 	connect(networkSelect, SIGNAL(activated(const QString&)), this,
- 		SLOT(selectNetwork(const QString&)));
- 	connect(fileEdit_networkAction, SIGNAL(activated()), this,
- 		SLOT(editNetwork()));
- 	connect(fileAdd_NetworkAction, SIGNAL(activated()), this,
- 		SLOT(addNetwork()));
- 	connect(adapterSelect, SIGNAL(activated(const QString&)), this,
- 		SLOT(selectAdapter(const QString&)));
- 
- 	eh = NULL;
- 	scanres = NULL;
- 	udr = NULL;
- 	ctrl_iface = NULL;
- 	ctrl_conn = NULL;
- 	monitor_conn = NULL;
- 	msgNotifier = NULL;
- 	ctrl_iface_dir = strdup("/var/run/wpa_supplicant");
- 
- 	parse_argv();
- 
- 	textStatus->setText("connecting to wpa_supplicant");
- 	timer = new QTimer(this);
- 	connect(timer, SIGNAL(timeout()), SLOT(ping()));
- 	timer->start(1000, FALSE);
- 
- 	if (openCtrlConnection(ctrl_iface) < 0) {
- 		printf("Failed to open control connection to "
- 		       "wpa_supplicant.\n");
- 	}
- 
- 	updateStatus();
- 	networkMayHaveChanged = true;
- 	updateNetworks();
- }
- 
- 
- WpaGui::~WpaGui()
- {
- 	delete msgNotifier;
- 
- 	if (monitor_conn) {
- 		wpa_ctrl_detach(monitor_conn);
- 		wpa_ctrl_close(monitor_conn);
- 		monitor_conn = NULL;
- 	}
- 	if (ctrl_conn) {
- 		wpa_ctrl_close(ctrl_conn);
- 		ctrl_conn = NULL;
- 	}
- 
- 	if (eh) {
- 		eh->close();
- 		delete eh;
- 		eh = NULL;
- 	}
- 
- 	if (scanres) {
- 		scanres->close();
- 		delete scanres;
- 		scanres = NULL;
- 	}
- 
- 	if (udr) {
- 		udr->close();
- 		delete udr;
- 		udr = NULL;
- 	}
- 
- 	free(ctrl_iface);
- 	ctrl_iface = NULL;
- 
- 	free(ctrl_iface_dir);
- 	ctrl_iface_dir = NULL;
- }
- 
- 
- void WpaGui::languageChange()
- {
- 	retranslateUi(this);
- }
- 
- 
- void WpaGui::parse_argv()
- {
- 	int c;
- 	for (;;) {
- 		c = getopt(qApp->argc(), qApp->argv(), "i:p:");
- 		if (c < 0)
- 			break;
- 		switch (c) {
- 		case 'i':
- 			free(ctrl_iface);
- 			ctrl_iface = strdup(optarg);
- 			break;
- 		case 'p':
- 			free(ctrl_iface_dir);
- 			ctrl_iface_dir = strdup(optarg);
- 			break;
- 		}
- 	}
- }
- 
- 
- int WpaGui::openCtrlConnection(const char *ifname)
- {
- 	char *cfile;
- 	int flen;
- 	char buf[2048], *pos, *pos2;
- 	size_t len;
- 
- 	if (ifname) {
- 		if (ifname != ctrl_iface) {
- 			free(ctrl_iface);
- 			ctrl_iface = strdup(ifname);
- 		}
- 	} else {
- #ifdef CONFIG_CTRL_IFACE_UDP
- 		free(ctrl_iface);
- 		ctrl_iface = strdup("udp");
- #endif /* CONFIG_CTRL_IFACE_UDP */
- #ifdef CONFIG_CTRL_IFACE_UNIX
- 		struct dirent *dent;
- 		DIR *dir = opendir(ctrl_iface_dir);
- 		free(ctrl_iface);
- 		ctrl_iface = NULL;
- 		if (dir) {
- 			while ((dent = readdir(dir))) {
- #ifdef _DIRENT_HAVE_D_TYPE
- 				/* Skip the file if it is not a socket.
- 				 * Also accept DT_UNKNOWN (0) in case
- 				 * the C library or underlying file
- 				 * system does not support d_type. */
- 				if (dent->d_type != DT_SOCK &&
- 				    dent->d_type != DT_UNKNOWN)
- 					continue;
- #endif /* _DIRENT_HAVE_D_TYPE */
- 
- 				if (strcmp(dent->d_name, ".") == 0 ||
- 				    strcmp(dent->d_name, "..") == 0)
- 					continue;
- 				printf("Selected interface '%s'\n",
- 				       dent->d_name);
- 				ctrl_iface = strdup(dent->d_name);
- 				break;
- 			}
- 			closedir(dir);
- 		}
- #endif /* CONFIG_CTRL_IFACE_UNIX */
- #ifdef CONFIG_CTRL_IFACE_NAMED_PIPE
- 		struct wpa_ctrl *ctrl;
- 		int ret;
- 
- 		free(ctrl_iface);
- 		ctrl_iface = NULL;
- 
- 		ctrl = wpa_ctrl_open(NULL);
- 		if (ctrl) {
- 			len = sizeof(buf) - 1;
- 			ret = wpa_ctrl_request(ctrl, "INTERFACES", 10, buf,
- 					       &len, NULL);
- 			if (ret >= 0) {
- 				buf[len] = '\0';
- 				pos = strchr(buf, '\n');
- 				if (pos)
- 					*pos = '\0';
- 				ctrl_iface = strdup(buf);
- 			}
- 			wpa_ctrl_close(ctrl);
- 		}
- #endif /* CONFIG_CTRL_IFACE_NAMED_PIPE */
- 	}
- 
- 	if (ctrl_iface == NULL)
- 		return -1;
- 
- #ifdef CONFIG_CTRL_IFACE_UNIX
- 	flen = strlen(ctrl_iface_dir) + strlen(ctrl_iface) + 2;
- 	cfile = (char *) malloc(flen);
- 	if (cfile == NULL)
- 		return -1;
- 	snprintf(cfile, flen, "%s/%s", ctrl_iface_dir, ctrl_iface);
- #else /* CONFIG_CTRL_IFACE_UNIX */
- 	flen = strlen(ctrl_iface) + 1;
- 	cfile = (char *) malloc(flen);
- 	if (cfile == NULL)
- 		return -1;
- 	snprintf(cfile, flen, "%s", ctrl_iface);
- #endif /* CONFIG_CTRL_IFACE_UNIX */
- 
- 	if (ctrl_conn) {
- 		wpa_ctrl_close(ctrl_conn);
- 		ctrl_conn = NULL;
- 	}
- 
- 	if (monitor_conn) {
- 		delete msgNotifier;
- 		msgNotifier = NULL;
- 		wpa_ctrl_detach(monitor_conn);
- 		wpa_ctrl_close(monitor_conn);
- 		monitor_conn = NULL;
- 	}
- 
- 	printf("Trying to connect to '%s'\n", cfile);
- 	ctrl_conn = wpa_ctrl_open(cfile);
- 	if (ctrl_conn == NULL) {
- 		free(cfile);
- 		return -1;
- 	}
- 	monitor_conn = wpa_ctrl_open(cfile);
- 	free(cfile);
- 	if (monitor_conn == NULL) {
- 		wpa_ctrl_close(ctrl_conn);
- 		return -1;
- 	}
- 	if (wpa_ctrl_attach(monitor_conn)) {
- 		printf("Failed to attach to wpa_supplicant\n");
- 		wpa_ctrl_close(monitor_conn);
- 		monitor_conn = NULL;
- 		wpa_ctrl_close(ctrl_conn);
- 		ctrl_conn = NULL;
- 		return -1;
- 	}
- 
- #if defined(CONFIG_CTRL_IFACE_UNIX) || defined(CONFIG_CTRL_IFACE_UDP)
- 	msgNotifier = new QSocketNotifier(wpa_ctrl_get_fd(monitor_conn),
- 					  QSocketNotifier::Read, this);
- 	connect(msgNotifier, SIGNAL(activated(int)), SLOT(receiveMsgs()));
- #endif
- 
- 	adapterSelect->clear();
- 	adapterSelect->insertItem(ctrl_iface);
- 	adapterSelect->setCurrentItem(0);
- 
- 	len = sizeof(buf) - 1;
- 	if (wpa_ctrl_request(ctrl_conn, "INTERFACES", 10, buf, &len, NULL) >=
- 	    0) {
- 		buf[len] = '\0';
- 		pos = buf;
- 		while (*pos) {
- 			pos2 = strchr(pos, '\n');
- 			if (pos2)
- 				*pos2 = '\0';
- 			if (strcmp(pos, ctrl_iface) != 0)
- 				adapterSelect->insertItem(pos);
- 			if (pos2)
- 				pos = pos2 + 1;
- 			else
- 				break;
- 		}
- 	}
- 
- 	return 0;
- }
- 
- 
- static void wpa_gui_msg_cb(char *msg, size_t)
- {
- 	/* This should not happen anymore since two control connections are
- 	 * used. */
- 	printf("missed message: %s\n", msg);
- }
- 
- 
- int WpaGui::ctrlRequest(const char *cmd, char *buf, size_t *buflen)
- {
- 	int ret;
- 
- 	if (ctrl_conn == NULL)
- 		return -3;
- 	ret = wpa_ctrl_request(ctrl_conn, cmd, strlen(cmd), buf, buflen,
- 			       wpa_gui_msg_cb);
- 	if (ret == -2)
- 		printf("'%s' command timed out.\n", cmd);
- 	else if (ret < 0)
- 		printf("'%s' command failed.\n", cmd);
- 
- 	return ret;
- }
- 
- 
- void WpaGui::updateStatus()
- {
- 	char buf[2048], *start, *end, *pos;
- 	size_t len;
- 
- 	pingsToStatusUpdate = 10;
- 
- 	len = sizeof(buf) - 1;
- 	if (ctrl_conn == NULL || ctrlRequest("STATUS", buf, &len) < 0) {
- 		textStatus->setText("Could not get status from "
- 				    "wpa_supplicant");
- 		textAuthentication->clear();
- 		textEncryption->clear();
- 		textSsid->clear();
- 		textBssid->clear();
- 		textIpAddress->clear();
- 		return;
- 	}
- 
- 	buf[len] = '\0';
- 
- 	bool auth_updated = false, ssid_updated = false;
- 	bool bssid_updated = false, ipaddr_updated = false;
- 	bool status_updated = false;
- 	char *pairwise_cipher = NULL, *group_cipher = NULL;
- 
- 	start = buf;
- 	while (*start) {
- 		bool last = false;
- 		end = strchr(start, '\n');
- 		if (end == NULL) {
- 			last = true;
- 			end = start;
- 			while (end[0] && end[1])
- 				end++;
- 		}
- 		*end = '\0';
- 
- 		pos = strchr(start, '=');
- 		if (pos) {
- 			*pos++ = '\0';
- 			if (strcmp(start, "bssid") == 0) {
- 				bssid_updated = true;
- 				textBssid->setText(pos);
- 			} else if (strcmp(start, "ssid") == 0) {
- 				ssid_updated = true;
- 				textSsid->setText(pos);
- 			} else if (strcmp(start, "ip_address") == 0) {
- 				ipaddr_updated = true;
- 				textIpAddress->setText(pos);
- 			} else if (strcmp(start, "wpa_state") == 0) {
- 				status_updated = true;
- 				textStatus->setText(pos);
- 			} else if (strcmp(start, "key_mgmt") == 0) {
- 				auth_updated = true;
- 				textAuthentication->setText(pos);
- 				/* TODO: could add EAP status to this */
- 			} else if (strcmp(start, "pairwise_cipher") == 0) {
- 				pairwise_cipher = pos;
- 			} else if (strcmp(start, "group_cipher") == 0) {
- 				group_cipher = pos;
- 			}
- 		}
- 
- 		if (last)
- 			break;
- 		start = end + 1;
- 	}
- 
- 	if (pairwise_cipher || group_cipher) {
- 		QString encr;
- 		if (pairwise_cipher && group_cipher &&
- 		    strcmp(pairwise_cipher, group_cipher) != 0) {
- 			encr.append(pairwise_cipher);
- 			encr.append(" + ");
- 			encr.append(group_cipher);
- 		} else if (pairwise_cipher) {
- 			encr.append(pairwise_cipher);
- 		} else if (group_cipher) {
- 			encr.append(group_cipher);
- 			encr.append(" [group key only]");
- 		} else {
- 			encr.append("?");
- 		}
- 		textEncryption->setText(encr);
- 	} else
- 		textEncryption->clear();
- 
- 	if (!status_updated)
- 		textStatus->clear();
- 	if (!auth_updated)
- 		textAuthentication->clear();
- 	if (!ssid_updated)
- 		textSsid->clear();
- 	if (!bssid_updated)
- 		textBssid->clear();
- 	if (!ipaddr_updated)
- 		textIpAddress->clear();
- }
- 
- 
- void WpaGui::updateNetworks()
- {
- 	char buf[2048], *start, *end, *id, *ssid, *bssid, *flags;
- 	size_t len;
- 	int first_active = -1;
- 	bool selected = false;
- 
- 	if (!networkMayHaveChanged)
- 		return;
- 
- 	networkSelect->clear();
- 
- 	if (ctrl_conn == NULL)
- 		return;
- 
- 	len = sizeof(buf) - 1;
- 	if (ctrlRequest("LIST_NETWORKS", buf, &len) < 0)
- 		return;
- 
- 	buf[len] = '\0';
- 	start = strchr(buf, '\n');
- 	if (start == NULL)
- 		return;
- 	start++;
- 
- 	while (*start) {
- 		bool last = false;
- 		end = strchr(start, '\n');
- 		if (end == NULL) {
- 			last = true;
- 			end = start;
- 			while (end[0] && end[1])
- 				end++;
- 		}
- 		*end = '\0';
- 
- 		id = start;
- 		ssid = strchr(id, '\t');
- 		if (ssid == NULL)
- 			break;
- 		*ssid++ = '\0';
- 		bssid = strchr(ssid, '\t');
- 		if (bssid == NULL)
- 			break;
- 		*bssid++ = '\0';
- 		flags = strchr(bssid, '\t');
- 		if (flags == NULL)
- 			break;
- 		*flags++ = '\0';
- 
- 		QString network(id);
- 		network.append(": ");
- 		network.append(ssid);
- 		networkSelect->insertItem(network);
- 
- 		if (strstr(flags, "[CURRENT]")) {
- 			networkSelect->setCurrentItem(networkSelect->count() -
- 						      1);
- 			selected = true;
- 		} else if (first_active < 0 &&
- 			   strstr(flags, "[DISABLED]") == NULL)
- 			first_active = networkSelect->count() - 1;
- 
- 		if (last)
- 			break;
- 		start = end + 1;
- 	}
- 
- 	if (!selected && first_active >= 0)
- 		networkSelect->setCurrentItem(first_active);
- 
- 	networkMayHaveChanged = false;
- }
- 
- 
- void WpaGui::helpIndex()
- {
- 	printf("helpIndex\n");
- }
- 
- 
- void WpaGui::helpContents()
- {
- 	printf("helpContents\n");
- }
- 
- 
- void WpaGui::helpAbout()
- {
- 	QMessageBox::about(this, "wpa_gui for wpa_supplicant",
- 			   "Copyright (c) 2003-2006,\n"
- 			   "Jouni Malinen <jkmaline@cc.hut.fi>\n"
- 			   "and contributors.\n"
- 			   "\n"
- 			   "This program is free software. You can\n"
- 			   "distribute it and/or modify it under the terms "
- 			   "of\n"
- 			   "the GNU General Public License version 2.\n"
- 			   "\n"
- 			   "Alternatively, this software may be distributed\n"
- 			   "under the terms of the BSD license.\n"
- 			   "\n"
- 			   "This product includes software developed\n"
- 			   "by the OpenSSL Project for use in the\n"
- 			   "OpenSSL Toolkit (http://www.openssl.org/)\n");
- }
- 
- 
- void WpaGui::disconnect()
- {
- 	char reply[10];
- 	size_t reply_len = sizeof(reply);
- 	ctrlRequest("DISCONNECT", reply, &reply_len);
- }
- 
- 
- void WpaGui::scan()
- {
- 	if (scanres) {
- 		scanres->close();
- 		delete scanres;
- 	}
- 
- 	scanres = new ScanResults();
- 	if (scanres == NULL)
- 		return;
- 	scanres->setWpaGui(this);
- 	scanres->show();
- 	scanres->exec();
- }
- 
- 
- void WpaGui::eventHistory()
- {
- 	if (eh) {
- 		eh->close();
- 		delete eh;
- 	}
- 
- 	eh = new EventHistory();
- 	if (eh == NULL)
- 		return;
- 	eh->addEvents(msgs);
- 	eh->show();
- 	eh->exec();
- }
- 
- 
- void WpaGui::ping()
- {
- 	char buf[10];
- 	size_t len;
- 
- #ifdef CONFIG_CTRL_IFACE_NAMED_PIPE
- 	/*
- 	 * QSocketNotifier cannot be used with Windows named pipes, so use a
- 	 * timer to check for received messages for now. This could be
- 	 * optimized be doing something specific to named pipes or Windows
- 	 * events, but it is not clear what would be the best way of doing that
- 	 * in Qt.
- 	 */
- 	receiveMsgs();
- #endif /* CONFIG_CTRL_IFACE_NAMED_PIPE */
- 
- 	if (scanres && !scanres->isVisible()) {
- 		delete scanres;
- 		scanres = NULL;
- 	}
- 
- 	if (eh && !eh->isVisible()) {
- 		delete eh;
- 		eh = NULL;
- 	}
- 
- 	if (udr && !udr->isVisible()) {
- 		delete udr;
- 		udr = NULL;
- 	}
- 
- 	len = sizeof(buf) - 1;
- 	if (ctrlRequest("PING", buf, &len) < 0) {
- 		printf("PING failed - trying to reconnect\n");
- 		if (openCtrlConnection(ctrl_iface) >= 0) {
- 			printf("Reconnected successfully\n");
- 			pingsToStatusUpdate = 0;
- 		}
- 	}
- 
- 	pingsToStatusUpdate--;
- 	if (pingsToStatusUpdate <= 0) {
- 		updateStatus();
- 		updateNetworks();
- 	}
- }
- 
- 
- static int str_match(const char *a, const char *b)
- {
- 	return strncmp(a, b, strlen(b)) == 0;
- }
- 
- 
- void WpaGui::processMsg(char *msg)
- {
- 	char *pos = msg, *pos2;
- 	int priority = 2;
- 
- 	if (*pos == '<') {
- 		/* skip priority */
- 		pos++;
- 		priority = atoi(pos);
- 		pos = strchr(pos, '>');
- 		if (pos)
- 			pos++;
- 		else
- 			pos = msg;
- 	}
- 
- 	WpaMsg wm(pos, priority);
- 	if (eh)
- 		eh->addEvent(wm);
- 	msgs.append(wm);
- 	while (msgs.count() > 100)
- 		msgs.pop_front();
- 
- 	/* Update last message with truncated version of the event */
- 	if (strncmp(pos, "CTRL-", 5) == 0) {
- 		pos2 = strchr(pos, str_match(pos, WPA_CTRL_REQ) ? ':' : ' ');
- 		if (pos2)
- 			pos2++;
- 		else
- 			pos2 = pos;
- 	} else
- 		pos2 = pos;
- 	QString lastmsg = pos2;
- 	lastmsg.truncate(40);
- 	textLastMessage->setText(lastmsg);
- 
- 	pingsToStatusUpdate = 0;
- 	networkMayHaveChanged = true;
- 
- 	if (str_match(pos, WPA_CTRL_REQ))
- 		processCtrlReq(pos + strlen(WPA_CTRL_REQ));
- }
- 
- 
- void WpaGui::processCtrlReq(const char *req)
- {
- 	if (udr) {
- 		udr->close();
- 		delete udr;
- 	}
- 	udr = new UserDataRequest();
- 	if (udr == NULL)
- 		return;
- 	if (udr->setParams(this, req) < 0) {
- 		delete udr;
- 		udr = NULL;
- 		return;
- 	}
- 	udr->show();
- 	udr->exec();
- }
- 
- 
- void WpaGui::receiveMsgs()
- {
- 	char buf[256];
- 	size_t len;
- 
- 	while (monitor_conn && wpa_ctrl_pending(monitor_conn) > 0) {
- 		len = sizeof(buf) - 1;
- 		if (wpa_ctrl_recv(monitor_conn, buf, &len) == 0) {
- 			buf[len] = '\0';
- 			processMsg(buf);
- 		}
- 	}
- }
- 
- 
- void WpaGui::connectB()
- {
- 	char reply[10];
- 	size_t reply_len = sizeof(reply);
- 	ctrlRequest("REASSOCIATE", reply, &reply_len);
- }
- 
- 
- void WpaGui::selectNetwork( const QString &sel )
- {
- 	QString cmd(sel);
- 	char reply[10];
- 	size_t reply_len = sizeof(reply);
- 
- 	int pos = cmd.find(':');
- 	if (pos < 0) {
- 		printf("Invalid selectNetwork '%s'\n", cmd.ascii());
- 		return;
- 	}
- 	cmd.truncate(pos);
- 	cmd.prepend("SELECT_NETWORK ");
- 	ctrlRequest(cmd.ascii(), reply, &reply_len);
- }
- 
- 
- void WpaGui::editNetwork()
- {
- 	QString sel(networkSelect->currentText());
- 	int pos = sel.find(':');
- 	if (pos < 0) {
- 		printf("Invalid selectNetwork '%s'\n", sel.ascii());
- 		return;
- 	}
- 	sel.truncate(pos);
- 
- 	NetworkConfig *nc = new NetworkConfig();
- 	if (nc == NULL)
- 		return;
- 	nc->setWpaGui(this);
- 
- 	nc->paramsFromConfig(sel.toInt());
- 	nc->show();
- 	nc->exec();
- }
- 
- 
- void WpaGui::triggerUpdate()
- {
- 	updateStatus();
- 	networkMayHaveChanged = true;
- 	updateNetworks();
- }
- 
- 
- void WpaGui::addNetwork()
- {
- 	NetworkConfig *nc = new NetworkConfig();
- 	if (nc == NULL)
- 		return;
- 	nc->setWpaGui(this);
- 	nc->newNetwork();
- 	nc->show();
- 	nc->exec();
- }
- 
- 
- void WpaGui::selectAdapter( const QString & sel )
- {
- 	if (openCtrlConnection(sel.ascii()) < 0)
- 		printf("Failed to open control connection to "
- 		       "wpa_supplicant.\n");
- 	updateStatus();
- 	updateNetworks();
- }
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/wpagui.h wpa_view/wpa_suppl/wpa_gui-qt4/wpagui.h
*** wpa_supplicant-0.5.7/wpa_gui-qt4/wpagui.h	Mon Aug 28 09:15:35 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/wpagui.h	Thu Jan  1 02:00:00 1970
***************
*** 1,76 ****
- /*
-  * wpa_gui - WpaGui class
-  * Copyright (c) 2005-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #ifndef WPAGUI_H
- #define WPAGUI_H
- 
- #include <QObject>
- #include "ui_wpagui.h"
- 
- class UserDataRequest;
- 
- 
- class WpaGui : public QMainWindow, public Ui::WpaGui
- {
- 	Q_OBJECT
- 
- public:
- 	WpaGui(QWidget *parent = 0, const char *name = 0,
- 	       Qt::WFlags fl = Qt::WType_TopLevel);
- 	~WpaGui();
- 
- 	virtual int ctrlRequest(const char *cmd, char *buf, size_t *buflen);
- 	virtual void triggerUpdate();
- 
- public slots:
- 	virtual void parse_argv();
- 	virtual void updateStatus();
- 	virtual void updateNetworks();
- 	virtual void helpIndex();
- 	virtual void helpContents();
- 	virtual void helpAbout();
- 	virtual void disconnect();
- 	virtual void scan();
- 	virtual void eventHistory();
- 	virtual void ping();
- 	virtual void processMsg(char *msg);
- 	virtual void processCtrlReq(const char *req);
- 	virtual void receiveMsgs();
- 	virtual void connectB();
- 	virtual void selectNetwork(const QString &sel);
- 	virtual void editNetwork();
- 	virtual void addNetwork();
- 	virtual void selectAdapter(const QString &sel);
- 
- protected slots:
- 	virtual void languageChange();
- 
- private:
- 	ScanResults *scanres;
- 	bool networkMayHaveChanged;
- 	char *ctrl_iface;
- 	EventHistory *eh;
- 	struct wpa_ctrl *ctrl_conn;
- 	QSocketNotifier *msgNotifier;
- 	QTimer *timer;
- 	int pingsToStatusUpdate;
- 	WpaMsgList msgs;
- 	char *ctrl_iface_dir;
- 	struct wpa_ctrl *monitor_conn;
- 	UserDataRequest *udr;
- 
- 	int openCtrlConnection(const char *ifname);
- };
- 
- #endif /* WPAGUI_H */
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/wpagui.ui wpa_view/wpa_suppl/wpa_gui-qt4/wpagui.ui
*** wpa_supplicant-0.5.7/wpa_gui-qt4/wpagui.ui	Sun Aug 27 22:06:43 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/wpagui.ui	Thu Jan  1 02:00:00 1970
***************
*** 1,318 ****
- <ui version="4.0" stdsetdef="1" >
-   <author></author>
-   <comment></comment>
-   <exportmacro></exportmacro>
-   <class>WpaGui</class>
-   <widget class="QMainWindow" name="WpaGui" >
-     <property name="geometry" >
-       <rect>
-         <x>0</x>
-         <y>0</y>
-         <width>279</width>
-         <height>308</height>
-       </rect>
-     </property>
-     <property name="windowTitle" >
-       <string>wpa_gui</string>
-     </property>
-     <widget class="QWidget" >
-       <layout class="QGridLayout" >
-         <item rowspan="1" row="0" column="0" colspan="2" >
-           <widget class="QLabel" name="textLabel16" >
-             <property name="text" >
-               <string>Adapter:</string>
-             </property>
-           </widget>
-         </item>
-         <item rowspan="1" row="0" column="2" colspan="2" >
-           <widget class="QComboBox" name="adapterSelect" />
-         </item>
-         <item rowspan="1" row="1" column="0" colspan="2" >
-           <widget class="QLabel" name="textLabel8" >
-             <property name="text" >
-               <string>Network:</string>
-             </property>
-           </widget>
-         </item>
-         <item rowspan="1" row="1" column="2" colspan="2" >
-           <widget class="QComboBox" name="networkSelect" />
-         </item>
-         <item rowspan="1" row="2" column="0" colspan="4" >
-           <widget class="QFrame" name="frame3" >
-             <property name="frameShape" >
-               <enum>StyledPanel</enum>
-             </property>
-             <property name="frameShadow" >
-               <enum>Raised</enum>
-             </property>
-             <layout class="QGridLayout" >
-               <item row="0" column="0" >
-                 <widget class="QLabel" name="textLabel1" >
-                   <property name="text" >
-                     <string>Status:</string>
-                   </property>
-                 </widget>
-               </item>
-               <item row="1" column="0" >
-                 <widget class="QLabel" name="textLabel2" >
-                   <property name="text" >
-                     <string>Last message:</string>
-                   </property>
-                 </widget>
-               </item>
-               <item row="2" column="0" >
-                 <widget class="QLabel" name="textLabel3" >
-                   <property name="text" >
-                     <string>Authentication:</string>
-                   </property>
-                 </widget>
-               </item>
-               <item row="3" column="0" >
-                 <widget class="QLabel" name="textLabel4" >
-                   <property name="text" >
-                     <string>Encryption:</string>
-                   </property>
-                 </widget>
-               </item>
-               <item row="4" column="0" >
-                 <widget class="QLabel" name="textLabel5" >
-                   <property name="text" >
-                     <string>SSID:</string>
-                   </property>
-                 </widget>
-               </item>
-               <item row="5" column="0" >
-                 <widget class="QLabel" name="textLabel6" >
-                   <property name="text" >
-                     <string>BSSID:</string>
-                   </property>
-                 </widget>
-               </item>
-               <item row="6" column="0" >
-                 <widget class="QLabel" name="textLabel7" >
-                   <property name="text" >
-                     <string>IP address:</string>
-                   </property>
-                 </widget>
-               </item>
-               <item row="0" column="1" >
-                 <widget class="QLabel" name="textStatus" >
-                   <property name="text" >
-                     <string/>
-                   </property>
-                 </widget>
-               </item>
-               <item rowspan="1" row="1" column="1" colspan="3" >
-                 <widget class="QLabel" name="textLastMessage" >
-                   <property name="text" >
-                     <string/>
-                   </property>
-                 </widget>
-               </item>
-               <item row="2" column="1" >
-                 <widget class="QLabel" name="textAuthentication" >
-                   <property name="text" >
-                     <string/>
-                   </property>
-                 </widget>
-               </item>
-               <item row="3" column="1" >
-                 <widget class="QLabel" name="textEncryption" >
-                   <property name="text" >
-                     <string/>
-                   </property>
-                 </widget>
-               </item>
-               <item row="4" column="1" >
-                 <widget class="QLabel" name="textSsid" >
-                   <property name="text" >
-                     <string/>
-                   </property>
-                 </widget>
-               </item>
-               <item row="5" column="1" >
-                 <widget class="QLabel" name="textBssid" >
-                   <property name="text" >
-                     <string/>
-                   </property>
-                 </widget>
-               </item>
-               <item row="6" column="1" >
-                 <widget class="QLabel" name="textIpAddress" >
-                   <property name="text" >
-                     <string/>
-                   </property>
-                 </widget>
-               </item>
-             </layout>
-           </widget>
-         </item>
-         <item row="3" column="0" >
-           <spacer name="spacer7" >
-             <property name="sizeHint" >
-               <size>
-                 <width>16</width>
-                 <height>16</height>
-               </size>
-             </property>
-             <property name="sizeType" >
-               <enum>Expanding</enum>
-             </property>
-             <property name="orientation" >
-               <enum>Horizontal</enum>
-             </property>
-           </spacer>
-         </item>
-         <item row="3" column="1" >
-           <widget class="QPushButton" name="connectButton" >
-             <property name="text" >
-               <string>Connect</string>
-             </property>
-           </widget>
-         </item>
-         <item row="3" column="2" >
-           <widget class="QPushButton" name="disconnectButton" >
-             <property name="text" >
-               <string>Disconnect</string>
-             </property>
-           </widget>
-         </item>
-         <item row="3" column="3" >
-           <widget class="QPushButton" name="scanButton" >
-             <property name="text" >
-               <string>Scan</string>
-             </property>
-           </widget>
-         </item>
-       </layout>
-     </widget>
-     <widget class="QMenuBar" name="MenuBar" >
-       <widget class="QMenu" name="fileMenu" >
-         <property name="title" >
-           <string>&amp;File</string>
-         </property>
-         <addaction name="separator" />
-         <addaction name="fileEventHistoryAction" />
-         <addaction name="fileAdd_NetworkAction" />
-         <addaction name="fileEdit_networkAction" />
-         <addaction name="separator" />
-         <addaction name="fileExitAction" />
-       </widget>
-       <widget class="QMenu" name="helpMenu" >
-         <property name="title" >
-           <string>&amp;Help</string>
-         </property>
-         <addaction name="helpContentsAction" />
-         <addaction name="helpIndexAction" />
-         <addaction name="separator" />
-         <addaction name="helpAboutAction" />
-       </widget>
-       <addaction name="fileMenu" />
-       <addaction name="helpMenu" />
-     </widget>
-     <action name="fileExitAction" >
-       <property name="name" >
-         <cstring>fileExitAction</cstring>
-       </property>
-       <property name="iconText" >
-         <string>Exit</string>
-       </property>
-       <property name="text" >
-         <string>E&amp;xit</string>
-       </property>
-       <property name="shortcut" >
-         <string>Ctrl+Q</string>
-       </property>
-     </action>
-     <action name="helpContentsAction" >
-       <property name="name" >
-         <cstring>helpContentsAction</cstring>
-       </property>
-       <property name="enabled" >
-         <bool>false</bool>
-       </property>
-       <property name="iconText" >
-         <string>Contents</string>
-       </property>
-       <property name="text" >
-         <string>&amp;Contents...</string>
-       </property>
-       <property name="shortcut" >
-         <string/>
-       </property>
-     </action>
-     <action name="helpIndexAction" >
-       <property name="name" >
-         <cstring>helpIndexAction</cstring>
-       </property>
-       <property name="enabled" >
-         <bool>false</bool>
-       </property>
-       <property name="iconText" >
-         <string>Index</string>
-       </property>
-       <property name="text" >
-         <string>&amp;Index...</string>
-       </property>
-       <property name="shortcut" >
-         <string/>
-       </property>
-     </action>
-     <action name="helpAboutAction" >
-       <property name="name" >
-         <cstring>helpAboutAction</cstring>
-       </property>
-       <property name="iconText" >
-         <string>About</string>
-       </property>
-       <property name="text" >
-         <string>&amp;About</string>
-       </property>
-       <property name="shortcut" >
-         <string/>
-       </property>
-     </action>
-     <action name="fileEventHistoryAction" >
-       <property name="name" >
-         <cstring>fileEventHistoryAction</cstring>
-       </property>
-       <property name="iconText" >
-         <string>Event History</string>
-       </property>
-       <property name="text" >
-         <string>Event &amp;History</string>
-       </property>
-     </action>
-     <action name="fileAdd_NetworkAction" >
-       <property name="name" >
-         <cstring>fileAdd_NetworkAction</cstring>
-       </property>
-       <property name="iconText" >
-         <string>Add Network</string>
-       </property>
-       <property name="text" >
-         <string>&amp;Add Network</string>
-       </property>
-     </action>
-     <action name="fileEdit_networkAction" >
-       <property name="name" >
-         <cstring>fileEdit_networkAction</cstring>
-       </property>
-       <property name="iconText" >
-         <string>Edit Network</string>
-       </property>
-       <property name="text" >
-         <string>&amp;Edit Network</string>
-       </property>
-     </action>
-   </widget>
-   <layoutdefault spacing="6" margin="11" />
-   <pixmapfunction>qPixmapFromMimeSource</pixmapfunction>
-   <includes>
-     <include location="global" >qtimer.h</include>
-     <include location="global" >qsocketnotifier.h</include>
-     <include location="local" >wpamsg.h</include>
-     <include location="local" >eventhistory.h</include>
-     <include location="local" >scanresults.h</include>
-   </includes>
- </ui>
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_gui-qt4/wpamsg.h wpa_view/wpa_suppl/wpa_gui-qt4/wpamsg.h
*** wpa_supplicant-0.5.7/wpa_gui-qt4/wpamsg.h	Sun Aug 27 22:00:11 2006
--- wpa_view/wpa_suppl/wpa_gui-qt4/wpamsg.h	Thu Jan  1 02:00:00 1970
***************
*** 1,42 ****
- /*
-  * wpa_gui - WpaMsg class for storing event messages
-  * Copyright (c) 2005-2006, Jouni Malinen <jkmaline@cc.hut.fi>
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * Alternatively, this software may be distributed under the terms of BSD
-  * license.
-  *
-  * See README and COPYING for more details.
-  */
- 
- #ifndef WPAMSG_H
- #define WPAMSG_H
- 
- #include <QDateTime>
- #include <QLinkedList>
- 
- class WpaMsg {
- public:
- 	WpaMsg() {}
- 	WpaMsg(const QString &_msg, int _priority = 2)
- 		: msg(_msg), priority(_priority)
- 	{
- 		timestamp = QDateTime::currentDateTime();
- 	}
- 
- 	QString getMsg() const { return msg; }
- 	int getPriority() const { return priority; }
- 	QDateTime getTimestamp() const { return timestamp; }
- 
- private:
- 	QString msg;
- 	int priority;
- 	QDateTime timestamp;
- };
- 
- typedef QLinkedList<WpaMsg> WpaMsgList;
- 
- #endif /* WPAMSG_H */
--- 0 ----
diff -BNcr wpa_supplicant-0.5.7/wpa_supplicant.c wpa_view/wpa_suppl/wpa_supplicant.c
*** wpa_supplicant-0.5.7/wpa_supplicant.c	Sun Dec 31 04:10:05 2006
--- wpa_view/wpa_suppl/wpa_supplicant.c	Wed Jun  9 13:30:55 2010
***************
*** 35,40 ****
--- 35,43 ----
  #include "pmksa_cache.h"
  #include "wpa_ctrl.h"
  #include "mlme.h"
+ #ifdef CONFIG_EAP_WSC
+ #include "wsc_supplicant.h"
+ #endif
  
  const char *wpa_supplicant_version =
  "wpa_supplicant v" VERSION_STR "\n"
***************
*** 608,614 ****
  		}
  	}
  	if (wpa_s->conf)
! 		eapol_conf.fast_reauth = wpa_s->conf->fast_reauth;
  	eapol_conf.workaround = ssid->eap_workaround;
  	eapol_conf.eap_disabled = wpa_s->key_mgmt != WPA_KEY_MGMT_IEEE8021X &&
  		wpa_s->key_mgmt != WPA_KEY_MGMT_IEEE8021X_NO_WPA;
--- 611,617 ----
  		}
  	}
  	if (wpa_s->conf)
! 	eapol_conf.fast_reauth = wpa_s->conf->fast_reauth;
  	eapol_conf.workaround = ssid->eap_workaround;
  	eapol_conf.eap_disabled = wpa_s->key_mgmt != WPA_KEY_MGMT_IEEE8021X &&
  		wpa_s->key_mgmt != WPA_KEY_MGMT_IEEE8021X_NO_WPA;
***************
*** 1220,1226 ****
  		return -1;
  
  	sel = ie.group_cipher & ssid->group_cipher;
! 	if (sel & WPA_CIPHER_CCMP) {
  		wpa_s->group_cipher = WPA_CIPHER_CCMP;
  		wpa_msg(wpa_s, MSG_DEBUG, "WPA: using GTK CCMP");
  	} else if (sel & WPA_CIPHER_TKIP) {
--- 1223,1232 ----
  		return -1;
  
  	sel = ie.group_cipher & ssid->group_cipher;
!     if ( (sel & WPA_CIPHER_CCMP)&&(sel & WPA_CIPHER_TKIP)) {//TI for Mix Mode
!         wpa_s->group_cipher = WPA_CIPHER_CCMP | WPA_CIPHER_TKIP;
!         wpa_msg(wpa_s, MSG_DEBUG, "WPA: using MIX MODE");
!     } else if (sel & WPA_CIPHER_CCMP) {
  		wpa_s->group_cipher = WPA_CIPHER_CCMP;
  		wpa_msg(wpa_s, MSG_DEBUG, "WPA: using GTK CCMP");
  	} else if (sel & WPA_CIPHER_TKIP) {
***************
*** 1345,1350 ****
--- 1351,1362 ----
  	 * previous association. */
  	wpa_sm_set_assoc_wpa_ie(wpa_s->wpa, NULL, 0);
  
+ #ifdef CONFIG_EAP_WSC
+ 	if(ssid->wsc_mode)
+ 	{
+ 		wsc_supplicant_associate(wpa_s, ssid, ssid->wsc_mode);		
+ 	}	
+ #endif
  #ifdef IEEE8021X_EAPOL
  	if (ssid->key_mgmt & WPA_KEY_MGMT_IEEE8021X_NO_WPA) {
  		if (ssid->leap) {
***************
*** 1441,1447 ****
  		/* Set the key before (and later after) association */
  		wpa_supplicant_set_wpa_none_key(wpa_s, ssid);
  	}
! 
  	wpa_drv_set_drop_unencrypted(wpa_s, use_crypt);
  	wpa_supplicant_set_state(wpa_s, WPA_ASSOCIATING);
  	os_memset(&params, 0, sizeof(params));
--- 1453,1459 ----
  		/* Set the key before (and later after) association */
  		wpa_supplicant_set_wpa_none_key(wpa_s, ssid);
  	}
! 	
  	wpa_drv_set_drop_unencrypted(wpa_s, use_crypt);
  	wpa_supplicant_set_state(wpa_s, WPA_ASSOCIATING);
  	os_memset(&params, 0, sizeof(params));
***************
*** 1453,1458 ****
--- 1465,1471 ----
  	} else {
  		params.ssid = ssid->ssid;
  		params.ssid_len = ssid->ssid_len;
+         params.bssid = ssid->bssid;
  	}
  	params.wpa_ie = wpa_ie;
  	params.wpa_ie_len = wpa_ie_len;
***************
*** 1468,1474 ****
  	}
  	params.wep_tx_keyidx = ssid->wep_tx_keyidx;
  
! #ifdef CONFIG_IEEE80211W
  	switch (ssid->ieee80211w) {
  	case NO_IEEE80211W:
  		params.mgmt_frame_protection = NO_MGMT_FRAME_PROTECTION;
--- 1481,1487 ----
  	}
  	params.wep_tx_keyidx = ssid->wep_tx_keyidx;
  
! #ifdef CONFIG_IEEE80211W		
  	switch (ssid->ieee80211w) {
  	case NO_IEEE80211W:
  		params.mgmt_frame_protection = NO_MGMT_FRAME_PROTECTION;
***************
*** 1511,1516 ****
--- 1524,1532 ----
  			timeout = 10;
  		else
  			timeout = 60;
+ #ifdef CONFIG_EAP_WSC
+ 		timeout += wsc_supplicant_associate_timeout_calc();
+ #endif
  		wpa_supplicant_req_auth_timeout(wpa_s, timeout, 0);
  	}
  
***************
*** 1553,1567 ****
  				 int reason_code)
  {
  	u8 *addr = NULL;
  	wpa_supplicant_set_state(wpa_s, WPA_DISCONNECTED);
! 	if (os_memcmp(wpa_s->bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN) != 0)
  	{
! 		if (wpa_s->use_client_mlme)
  			ieee80211_sta_disassociate(wpa_s, reason_code);
  		else
  			wpa_drv_disassociate(wpa_s, wpa_s->bssid, reason_code);
  		addr = wpa_s->bssid;
  	}
  	wpa_clear_keys(wpa_s, addr);
  	wpa_s->current_ssid = NULL;
  	wpa_sm_set_config(wpa_s->wpa, NULL);
--- 1569,1589 ----
  				 int reason_code)
  {
  	u8 *addr = NULL;
+ #ifdef CONFIG_EAP_WSC
+ 	if(wpa_s->current_ssid && wpa_s->current_ssid->wsc_mode)
+ 		wsc_supplicant_stop();
+ #endif
+     
  	wpa_supplicant_set_state(wpa_s, WPA_DISCONNECTED);
!     if (os_memcmp(wpa_s->bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN) != 0)
  	{
!         if (wpa_s->use_client_mlme)
  			ieee80211_sta_disassociate(wpa_s, reason_code);
  		else
  			wpa_drv_disassociate(wpa_s, wpa_s->bssid, reason_code);
  		addr = wpa_s->bssid;
  	}
+    
  	wpa_clear_keys(wpa_s, addr);
  	wpa_s->current_ssid = NULL;
  	wpa_sm_set_config(wpa_s->wpa, NULL);
***************
*** 1723,1739 ****
  	int res;
  	size_t ssid_len;
  	u8 bssid[ETH_ALEN];
! 
  	if (wpa_s->use_client_mlme) {
  		if (ieee80211_sta_get_ssid(wpa_s, ssid, &ssid_len)) {
! 			wpa_printf(MSG_WARNING, "Could not read SSID from "
  				   "MLME.");
  			return NULL;
  		}
  	} else {
  		res = wpa_drv_get_ssid(wpa_s, ssid);
  		if (res < 0) {
! 			wpa_printf(MSG_WARNING, "Could not read SSID from "
  				   "driver.");
  			return NULL;
  		}
--- 1745,1761 ----
  	int res;
  	size_t ssid_len;
  	u8 bssid[ETH_ALEN];
! 	
  	if (wpa_s->use_client_mlme) {
  		if (ieee80211_sta_get_ssid(wpa_s, ssid, &ssid_len)) {
!             wpa_printf(MSG_WARNING, "Could not read SSID from "
  				   "MLME.");
  			return NULL;
  		}
  	} else {
  		res = wpa_drv_get_ssid(wpa_s, ssid);
  		if (res < 0) {
!             wpa_printf(MSG_WARNING, "Could not read SSID from "
  				   "driver.");
  			return NULL;
  		}
***************
*** 1743,1749 ****
  	if (wpa_s->use_client_mlme)
  		os_memcpy(bssid, wpa_s->bssid, ETH_ALEN);
  	else if (wpa_drv_get_bssid(wpa_s, bssid) < 0) {
! 		wpa_printf(MSG_WARNING, "Could not read BSSID from driver.");
  		return NULL;
  	}
  
--- 1765,1771 ----
  	if (wpa_s->use_client_mlme)
  		os_memcpy(bssid, wpa_s->bssid, ETH_ALEN);
  	else if (wpa_drv_get_bssid(wpa_s, bssid) < 0) {
!         wpa_printf(MSG_WARNING, "Could not read BSSID from driver.");
  		return NULL;
  	}
  
***************
*** 1758,1763 ****
--- 1780,1803 ----
  		entry = entry->next;
  	}
  
+ #ifdef TI_WLAN_DRIVER
+ 	entry = wpa_s->conf->ssid;
+ 	while (entry) {
+ 		if (!entry->disabled &&
+ 		    entry->ssid_len == 0)
+ 			{
+ 				entry->ssid_len = ssid_len;
+                 entry->ssid = realloc(entry->ssid,ssid_len);
+                 if (entry->ssid == NULL) {
+                     wpa_printf(MSG_WARNING, "Could not realloc ssid entry.");
+                     return NULL;
+                 }
+ 				os_memcpy(entry->ssid, ssid, ssid_len);
+ 				return entry;
+ 			}	
+ 		entry = entry->next;
+ 	}
+ #endif
  	return NULL;
  }
  
diff -BNcr wpa_supplicant-0.5.7/wpa_supplicant.h wpa_view/wpa_suppl/wpa_supplicant.h
*** wpa_supplicant-0.5.7/wpa_supplicant.h	Sun Nov 12 02:42:00 2006
--- wpa_view/wpa_suppl/wpa_supplicant.h	Wed Jun  9 13:30:56 2010
***************
*** 123,128 ****
--- 123,137 ----
  	 */
  	EVENT_PMKID_CANDIDATE,
  
+ #ifdef CONFIG_EAP_WSC
+ 	/**
+ 	 * EVENT_WSC_PBC_OVERLAP - notfication of a PBC overlap
+ 	 *
+ 	 * This event is used to inform the WSC of the supplicant that more 
+ 	 * than on AP is in PBC mode 
+ 	 */
+ 	EVENT_WSC_PBC_OVERLAP,
+ #endif
  	/**
  	 * EVENT_STKSTART - Request STK handshake (MLME-STKSTART.request)
  	 *
diff -BNcr wpa_supplicant-0.5.7/wpa_supplicant_i.h wpa_view/wpa_suppl/wpa_supplicant_i.h
*** wpa_supplicant-0.5.7/wpa_supplicant_i.h	Sun Oct 29 20:27:49 2006
--- wpa_view/wpa_suppl/wpa_supplicant_i.h	Wed Jun  9 13:31:25 2010
***************
*** 691,694 ****
--- 691,706 ----
  	return -1;
  }
  
+ #ifdef CONFIG_EAP_WSC
+ static inline int wpa_drv_set_wsc_mode(struct wpa_supplicant *wpa_s,
+ 					  u32 WscMode,
+ 					  void* probeReqBuf,
+ 					  int probeReqBufLen)
+ {
+ 	if (wpa_s->driver->set_wsc_mode)
+ 		return wpa_s->driver->set_wsc_mode(wpa_s->drv_priv, WscMode, probeReqBuf, probeReqBufLen);
+ 	return -1;
+ }
+ #endif
+ 
  #endif /* WPA_SUPPLICANT_I_H */
diff -BNcr wpa_supplicant-0.5.7/wsc_supplicant.c wpa_view/wpa_suppl/wsc_supplicant.c
*** wpa_supplicant-0.5.7/wsc_supplicant.c	Thu Jan  1 02:00:00 1970
--- wpa_view/wpa_suppl/wsc_supplicant.c	Wed Jun  9 13:31:26 2010
***************
*** 0 ****
--- 1,528 ----
+ /*
+  * wsc_supplicant.c
+  *
+  * Copyright 2001-2009 Texas Instruments, Inc. - http://www.ti.com/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  * Alternatively, this software may be distributed under the terms of BSD
+  * license.
+  *
+  * See README and COPYING for more details.
+  */
+ 
+ #include "includes.h"
+ #include "common.h"
+ #include "bufferObj.h"
+ #include "config_ssid.h"
+ #include "wpa_supplicant.h"
+ #include "wpa_supplicant_i.h"
+ #include "eloop.h"
+ #include "wpa.h"
+ #include "config.h"
+ #include "WscTypes.h"
+ #include "wsc_supplicant.h"
+ 
+ #include "ossl_typ.h"
+ #include "rand.h"
+ 
+ 
+ #define DEF_CONFIG_VERSION					0x10
+ #define DEF_CONFIG_CONFIG_METHODS			0xc
+ #define DEF_CONFIG_UUID						"0x01010101010101010101010101010101"
+ #define DEF_CONFIG_PRIMARY_DEV_CATEGORY		1
+ #define DEF_CONFIG_PRIMARY_DEV_OUI			0x50f204
+ #define DEF_CONFIG_PRIMARY_DEV_SUB_CATEGORY	1
+ #define DEF_CONFIG_RF_BAND					1
+ #define DEF_CONFIG_AUTH_TYPE_FLAGS			0x3f
+ #define DEF_CONFIG_ENCR_TYPE_FLAGS			0x6
+ #define DEF_CONFIG_CONN_TYPE_FLAGS			0x3
+ #define DEF_CONFIG_MANUFACTURER				"Texas Instruments"
+ #define DEF_CONFIG_MODEL_NAME					"Texas Instruments 1251"
+ #define DEF_CONFIG_MODEL_NUMBER				"1251"
+ #define DEF_CONFIG_SERIAL_NUMBER				"0"
+ #define DEF_CONFIG_DEVICE_NAME				"TI Device"
+ #define DEF_CONFIG_OS_VERSION					0x80000000
+ 
+ #define ENROLLEE_ID_STRING        			"WFA-SimpleConfig-Enrollee-1-0"
+ 
+ TWscSupplicant WscSupplicantConfig;
+ 
+ static u32 wsc_supplicant_BuildProbeRequest(TWscSupplicant* pWscSupplicant, bufferObj *probeReqBuf)
+ {
+ 	u8 RequestType = 0; /* 0 - Enrollee, Info only, 1 - Enrollee, open 802.1X */
+ 	u16 AssociationState = 0; /* 0 - Not Associated */
+ 	u16 ConfigurationError = 0; /* 0 - No Error */
+ 
+ 	/* u8 version */
+ 	wsc_supplicant_SerializeField(WSC_ID_VERSION, probeReqBuf, SIZE_VERSION, &(pWscSupplicant->version));
+ 
+ 	/* u8 RequestType */
+ 	wsc_supplicant_SerializeField(WSC_ID_REQ_TYPE, probeReqBuf, SIZE_REQ_TYPE, &RequestType);
+ 
+ 	/* u16 configMethods */
+ 	wsc_supplicant_SerializeField(WSC_ID_CONFIG_METHODS, probeReqBuf, SIZE_CONFIG_METHODS, (u8 *)&(pWscSupplicant->configMethods));
+ 
+ 	/* u8 *uuid ;16B=128 bits */
+ 	wsc_supplicant_SerializeField(WSC_ID_UUID_E, probeReqBuf, SIZE_UUID, pWscSupplicant->uuidE);
+ 
+ 	/* sc_device_type_t primaryDeviceType; 8B */
+ 	wsc_supplicant_SerializeHeader(WSC_ID_PRIM_DEV_TYPE, SIZE_PRIM_DEV_TYPE, probeReqBuf);
+ 	bufferAppend(probeReqBuf, SIZE_PRIM_DEV_CAT_ID, (u8 *)&(pWscSupplicant->primaryDeviceType.category_id));
+ 	bufferAppend(probeReqBuf, SIZE_PRIM_DEV_OUI, (u8 *)&(pWscSupplicant->primaryDeviceType.oui));
+ 	bufferAppend(probeReqBuf, SIZE_PRIM_DEV_SUB_CAT_ID, (u8 *)&(pWscSupplicant->primaryDeviceType.sub_category_id));
+ 
+ 	/* u8 rfBand */
+ 	wsc_supplicant_SerializeField(WSC_ID_RF_BAND, probeReqBuf, SIZE_RF_BAND, &(pWscSupplicant->rfBand));
+ 
+ 	/* u16 assocState */
+ 	wsc_supplicant_SerializeField(WSC_ID_ASSOC_STATE, probeReqBuf, SIZE_ASSOC_STATE, (u8 *)&AssociationState);
+ 
+ 	/* u16 configError */
+ 	wsc_supplicant_SerializeField(WSC_ID_CONFIG_ERROR, probeReqBuf, SIZE_CONFIG_ERROR, (u8 *)&ConfigurationError);
+ 
+ 	/* u16 devicePasswordId */
+ 	wsc_supplicant_SerializeField(WSC_ID_DEVICE_PWD_ID, probeReqBuf, SIZE_DEVICE_PWD_ID, (u8 *)&(pWscSupplicant->devicePasswordId));
+ 
+ 	wpa_printf(MSG_INFO,"wsc_supplicant: wsc_supplicant_BuildProbeRequest: built %d byte message", bufferLength(probeReqBuf));
+ 
+ 	return OK;
+ }
+ 
+ static void wsc_supplicant_PushButtonWalktimeTimeout(void *eloop_ctx, void *timeout_ctx)
+ {
+ 	
+ 	wpa_printf(MSG_INFO,"wsc_supplicant: wsc_supplicant_PushButtonWalktimeTimeout: 2 Min.Push-Button walk-time timed out.");
+ 
+ 	wpa_supplicant_disassociate(WscSupplicantConfig.wpa_s, REASON_DEAUTH_LEAVING);
+     wpa_drv_disassociate((struct wpa_supplicant *)WscSupplicantConfig.wpa_s, ((struct wpa_supplicant*)WscSupplicantConfig.wpa_s)->bssid, REASON_DEAUTH_LEAVING);
+ 
+ }			
+ 
+  /* configure supplicant & update driver according to new mode of operation */
+ void wsc_supplicant_associate(void* h_wpa_s, void* h_ssid, u32 WscMode)
+ {
+ 	int i;		
+ 	bufferObj probeReqBuf;
+ 	struct wpa_supplicant *wpa_s = h_wpa_s;
+ 	struct wpa_ssid *ssid = h_ssid;
+ 
+ 	/* 
+ 	if the current state is WSC_STATE_SUCCESS this means that this is the second association 
+ 	in the WPS sequence and we are not supposed to start the EAP-WSC mechnaism.
+ 	*/
+ 	if(WscSupplicantConfig.smState == WSC_STATE_SUCCESS)
+ 	{
+ 		WscSupplicantConfig.smState = WSC_STATE_IDLE;
+ 		return;
+ 	}
+ 
+ 	/* 
+ 	if the current state is WSC_STATE_IDLE this means that this is a interruption of 
+ 	the current WPS session.
+ 	*/
+ 	if(WscSupplicantConfig.smState != WSC_STATE_IDLE)
+ 	{
+ 		if(WscSupplicantConfig.WscMode == WSC_MODE_PBC)
+ 		{
+ 			/* 
+ 			If Supplicant is in a process of a Simple Config handhsake and in PBC mode - 
+ 			Cancel registration to 2 Min. Walk-Time PushButton timeout
+ 			*/		
+ 			eloop_cancel_timeout(wsc_supplicant_PushButtonWalktimeTimeout, NULL, NULL);
+ 		}
+ 
+         /* update driver */
+ 		wpa_drv_set_wsc_mode(h_wpa_s,
+ 					  		WSC_MODE_OFF,
+ 					  		NULL, 
+ 					  		0);
+ 	}
+ 
+ 	wpa_printf(MSG_INFO,"wsc_supplicant: Entered wsc_supplicant_associate");
+ 	
+ 	/* init params */
+ 	WscSupplicantConfig.version = DEF_CONFIG_VERSION;
+ 	WscSupplicantConfig.configMethods = DEF_CONFIG_CONFIG_METHODS;
+ 	{
+ 		char temp[10];
+ 		char *p = DEF_CONFIG_UUID;
+     	temp[0] = '0';
+     	temp[1] = 'x';
+         
+ 		/* move past the '0x' on the first pass */
+ 		for (i = 0; i <= 15; i++)
+ 		{
+     		p += 2;
+         	strncpy(&temp[2], p, 2); 
+         	WscSupplicantConfig.uuidE[i] = (u8) (strtoul(temp, NULL, 16));    
+ 		}
+ 	}
+ 	WscSupplicantConfig.primaryDeviceType.category_id = DEF_CONFIG_PRIMARY_DEV_CATEGORY;
+ 	WscSupplicantConfig.primaryDeviceType.oui = DEF_CONFIG_PRIMARY_DEV_OUI;
+ 	WscSupplicantConfig.primaryDeviceType.sub_category_id = DEF_CONFIG_PRIMARY_DEV_SUB_CATEGORY;
+ 	WscSupplicantConfig.rfBand = DEF_CONFIG_RF_BAND;
+ 	WscSupplicantConfig.devicePasswordId = WSC_DEVICEPWDID_DEFAULT; /* Default (PIN) */
+ 
+ 	WscSupplicantConfig.authenticationTypeFlags = DEF_CONFIG_AUTH_TYPE_FLAGS;
+ 	memcpy(WscSupplicantConfig.macAddress, wpa_s->own_addr, ETH_ALEN);
+ 	WscSupplicantConfig.encryptionTypeFlags = DEF_CONFIG_ENCR_TYPE_FLAGS;
+ 	WscSupplicantConfig.connectionTypeFlags = DEF_CONFIG_CONN_TYPE_FLAGS;
+ 	WscSupplicantConfig.state = 0;
+ 	WscSupplicantConfig.assocState = 0;
+ 	WscSupplicantConfig.configError = 0;
+ 	sprintf(WscSupplicantConfig.manufacturer, "%s", DEF_CONFIG_MANUFACTURER);
+ 	sprintf(WscSupplicantConfig.modelName, "%s", DEF_CONFIG_MODEL_NAME);
+ 	sprintf(WscSupplicantConfig.modelNumber, "%s", DEF_CONFIG_MODEL_NUMBER);
+ 	sprintf(WscSupplicantConfig.serialNumber, "%s", DEF_CONFIG_SERIAL_NUMBER);
+ 	sprintf(WscSupplicantConfig.deviceName, "%s", DEF_CONFIG_DEVICE_NAME);
+ 	WscSupplicantConfig.osVersion = DEF_CONFIG_OS_VERSION;
+ 	
+ 	WscSupplicantConfig.ssid = ssid;
+ 	WscSupplicantConfig.wpa_s = wpa_s;
+ 	
+ 
+ 	switch (WscMode)
+ 	{
+ 		case WSC_MODE_PIN:
+ 			if(!ssid->wsc_pin)
+ 			{
+ 				char c_devPwd[32];
+ 				u8 devPwd[10];
+ 				u32 val;
+ 				u32 checksum;
+ 				
+ 				RAND_bytes(devPwd, LONG_PIN_LEN); 
+ 				sprintf(c_devPwd, "%08u", *(u32 *)devPwd);
+ 				
+ 				/* Compute the checksum */
+ 				c_devPwd[7] = '\0';
+ 				val = strtoul(c_devPwd, NULL, 10 );
+ 				checksum = wsc_supplicant_ComputeChecksum( val );
+ 				val = val*10 + checksum;
+ 				sprintf((char *)(WscSupplicantConfig.password), "%d", val );
+ 				WscSupplicantConfig.password[LONG_PIN_LEN] = '\0';		
+ 				wpa_printf(MSG_INFO, "Random PIN: %c-%c-%c-%c-%c-%c-%c-%c\n", 
+ 					WscSupplicantConfig.password[0], 
+ 					WscSupplicantConfig.password[1], 
+ 					WscSupplicantConfig.password[2], 
+ 					WscSupplicantConfig.password[3], 
+ 					WscSupplicantConfig.password[4], 
+ 					WscSupplicantConfig.password[5], 
+ 					WscSupplicantConfig.password[6], 
+ 					WscSupplicantConfig.password[7]);
+ 			}
+ 			else
+ 			{
+ 				strcpy((char *)(WscSupplicantConfig.password), ssid->wsc_pin);
+ 				ssid->wsc_pin[strlen(ssid->wsc_pin)] = '\0';
+ 			}	
+ 			break;
+ 
+ 		case WSC_MODE_PBC:
+ 
+ 			for (i = 0 ; i < LONG_PIN_LEN; i++)
+ 			{
+ 				WscSupplicantConfig.password[i] = '0';
+ 			}
+ 			WscSupplicantConfig.password[LONG_PIN_LEN] = '\0';
+ 
+ 			WscSupplicantConfig.configMethods |= WSC_CONFMET_PBC;
+ 			WscSupplicantConfig.devicePasswordId = WSC_DEVICEPWDID_PUSH_BTN;
+ 				
+ 			/* Register for 2 Min. Walk-Time PushButton timeout */
+             eloop_register_timeout(120, 0, wsc_supplicant_PushButtonWalktimeTimeout, NULL, NULL);
+             
+ 			break;
+ 
+ 		default:
+ 			
+ 			wpa_printf(MSG_ERROR,"wsc_supplicant: wsc_supplicant_associate: ERROR: Incompatible Simple Config Mode received in scStartEnrollee: (%d)", WscMode);
+ 			WscSupplicantConfig.smState = WSC_STATE_IDLE;
+ 	}
+ 			
+ 	bufferCreateChunk(&probeReqBuf);
+ 	wsc_supplicant_BuildProbeRequest(&WscSupplicantConfig, &probeReqBuf);
+ 
+ 	wpa_drv_set_wsc_mode(h_wpa_s,
+ 			  				WscMode,
+ 			  				bufferGetBuf(&probeReqBuf), 
+ 			  				bufferLength(&probeReqBuf));
+ 
+ 	bufferFree(&probeReqBuf);
+ 
+ 	ssid->key_mgmt = WPA_KEY_MGMT_IEEE8021X;
+ 	ssid->auth_alg = WPA_AUTH_ALG_OPEN;
+ 	ssid->proto = WPA_PROTO_WPA;
+ 	ssid->pairwise_cipher = WPA_CIPHER_TKIP;
+ 	ssid->group_cipher = WPA_CIPHER_TKIP;
+ 	ssid->identity = (u8 *) strdup(ENROLLEE_ID_STRING);
+ 	ssid->identity_len = strlen(ENROLLEE_ID_STRING);								
+ 
+ 	WscSupplicantConfig.WscMode = WscMode;	
+ 	WscSupplicantConfig.smState = WSC_STATE_ASSOC;
+ }
+ 
+ void wsc_supplicant_EapSuccess(TStaEncryptSettings* pStaEncryptSettings)
+ {
+ 	struct wpa_ssid *ssid = WscSupplicantConfig.ssid;
+ 	int i;		
+ 	/* for now we only support one credential inside M8 settings */
+ 	TTlvCredential *p_Credentials = &(pStaEncryptSettings->credential);
+ 
+ 	WscSupplicantConfig.smState = WSC_STATE_SUCCESS;
+ 
+     wpa_drv_set_wsc_mode(WscSupplicantConfig.wpa_s,
+ 	    			  	 WSC_MODE_OFF,
+ 					  	 NULL, 
+ 					  	 0);
+ 
+ 	wpa_printf (MSG_DEBUG, "wsc_supplicant: wsc_supplicant_EapSuccess: Acquired network block authType = 0x%x",p_Credentials->authType);
+ 
+ 	if ((p_Credentials->authType & WSC_AUTHTYPE_WPAPSK) || (p_Credentials->authType & WSC_AUTHTYPE_WPA2PSK) || (p_Credentials->authType & WSC_AUTHTYPE_OPEN) || (p_Credentials->authType & WSC_AUTHTYPE_SHARED))
+ 	{
+ 
+ 		ssid->mode = IEEE80211_MODE_INFRA;
+         ssid->proto = DEFAULT_PROTO;
+         ssid->key_mgmt = WPA_KEY_MGMT_NONE;
+         ssid->auth_alg = AUTH_ALG_OPEN_SYSTEM;
+         
+ 		if ((p_Credentials->authType & WSC_AUTHTYPE_WPAPSK) || (p_Credentials->authType & WSC_AUTHTYPE_WPA2PSK))
+ 		{
+ 			wpa_printf (MSG_DEBUG, "wsc_supplicant: wsc_supplicant_EapSuccess: length of nw_key = %d",p_Credentials->nwKey[DEFAULT_KEY_INDEX].length);
+ 			
+ 			if (p_Credentials->nwKey[DEFAULT_KEY_INDEX].length == 64)
+ 			{
+ 				if( 0 == hexstr2bin ((char *)(p_Credentials->nwKey[DEFAULT_KEY_INDEX].pValue), (u8 *)(&ssid->psk), (p_Credentials->nwKey[DEFAULT_KEY_INDEX].length / 2)))
+ 				{
+ 					wpa_printf (MSG_DEBUG, "wsc_supplicant: wsc_supplicant_EapSuccess: successfully converted hex string into binary data");
+ 					ssid->psk_set=1;
+ 				}
+ 				else
+ 				{
+ 					wpa_printf (MSG_ERROR, "wsc_supplicant: wsc_supplicant_EapSuccess: sorry but I couldn't convert hex string into binary data");
+ 				}
+ 			}
+ 			else if ((p_Credentials->nwKey[DEFAULT_KEY_INDEX].length < 64) && (p_Credentials->nwKey[DEFAULT_KEY_INDEX].length > 0))
+ 			{
+ 				/* put PSK */
+ 				if(ssid->passphrase)
+ 					free(ssid->passphrase);
+ 				ssid->passphrase = malloc(p_Credentials->nwKey[DEFAULT_KEY_INDEX].length+1);
+ 				strncpy(ssid->passphrase, p_Credentials->nwKey[DEFAULT_KEY_INDEX].pValue, p_Credentials->nwKey[DEFAULT_KEY_INDEX].length);
+ 				ssid->passphrase[p_Credentials->nwKey[DEFAULT_KEY_INDEX].length] = '\0';
+ 				ssid->psk_set=0;
+ 				wpa_config_update_psk(ssid);
+ 				wpa_printf (MSG_DEBUG,"wsc_supplicant: wsc_supplicant_EapSuccess: psk string (ASCII): %s",ssid->passphrase);
+ 			}
+ 		}
+         else if (p_Credentials->authType & WSC_AUTHTYPE_SHARED)
+         {
+             ssid->auth_alg = WPA_AUTH_ALG_SHARED;
+         }
+         /* In case of WEP shared or open - get WEP key and TX key index*/
+         if (p_Credentials->encrType & WSC_ENCRTYPE_WEP)
+         {
+             ssid->pairwise_cipher = WPA_CIPHER_NONE;
+             ssid->group_cipher = WPA_CIPHER_NONE;
+             ssid->wep_tx_keyidx = p_Credentials->WEP_transmit_key;
+ 
+             for (i=0; i<MAX_NETWORK_KEY_NUM; i++)
+             {
+                /* In case of ASCII encoded keys */
+                if ((p_Credentials->nwKey[DEFAULT_KEY_INDEX].length == 5) || (p_Credentials->nwKey[DEFAULT_KEY_INDEX].length == 13))
+                {
+                   /* ssid->wep_key */
+                }
+                /* In case of HEX encoded keys */
+                else if ((p_Credentials->nwKey[DEFAULT_KEY_INDEX].length == 10) || (p_Credentials->nwKey[DEFAULT_KEY_INDEX].length == 26))
+                {
+                   /* ssid->wep_key */
+                }
+                else
+                {
+                   wpa_printf (MSG_ERROR,"wsc_supplicant: wrong WEP key length");
+                }
+             }
+             
+         }
+ 
+ 		if (p_Credentials->authType & WSC_AUTHTYPE_WPAPSK)
+ 		{
+ 			ssid->key_mgmt = WPA_KEY_MGMT_PSK;
+ 			ssid->proto = WPA_PROTO_WPA;
+ 			ssid->pairwise_cipher = WPA_CIPHER_TKIP;
+ 			ssid->group_cipher = WPA_CIPHER_TKIP;	
+ 		}
+ 		else if (p_Credentials->authType & WSC_AUTHTYPE_WPA2PSK)
+ 		{
+ 			ssid->key_mgmt = WPA_KEY_MGMT_PSK;
+ 			ssid->proto = WPA_PROTO_RSN;
+ 			ssid->pairwise_cipher = WPA_CIPHER_CCMP;
+             // TI - we have no way to know that we are woking with MIX MODE , so this is the reason we configuere the group to CCMP|TKIP
+             ssid->group_cipher = WPA_CIPHER_CCMP | WPA_CIPHER_TKIP;
+        	}
+ 		else if (p_Credentials->authType & WSC_AUTHTYPE_OPEN)
+ 		{
+ 			ssid->key_mgmt = WPA_KEY_MGMT_NONE;
+         }		
+ 		
+ 		wpa_config_write(((struct wpa_supplicant*)WscSupplicantConfig.wpa_s)->confname, ((struct wpa_supplicant*)WscSupplicantConfig.wpa_s)->conf);
+ 	}
+ 	else
+ 	{
+ 		wpa_printf (MSG_ERROR, "wsc_supplicant: wsc_supplicant_EapSuccess: Invalid Authentication algotirhm...aborting...");
+ 		return;
+ 	}
+ 
+ 
+ 	ssid->disabled = 0;
+     ssid->wsc_mode = WSC_MODE_OFF;
+ 	((struct wpa_supplicant*)WscSupplicantConfig.wpa_s)->reassociate = 1;
+ 	wpa_supplicant_req_scan(WscSupplicantConfig.wpa_s, 0, 0);
+ 	
+ }
+ 
+ 
+ void wsc_supplicant_event_assoc(void* h_ssid)
+ {
+ 	if(WscSupplicantConfig.smState == WSC_STATE_ASSOC)
+ 	{		
+ 		WscSupplicantConfig.smState  = WSC_STATE_EVENT_ASSOC;
+ 		if(WscSupplicantConfig.WscMode == WSC_MODE_PBC)
+ 		{
+ 			eloop_cancel_timeout(wsc_supplicant_PushButtonWalktimeTimeout, NULL, NULL);
+ 		}
+ 	}
+ 	
+ }
+ 
+ void wsc_supplicant_event_overlap()
+ {
+ 	wpa_printf(MSG_INFO,"wsc_supplicant: wsc_supplicant_event_overlap: PBC overlapped event occured\n");
+ 
+ 	wpa_supplicant_disassociate(WscSupplicantConfig.wpa_s, REASON_DEAUTH_LEAVING);
+ 	
+ }
+ 
+ int wsc_supplicant_associate_timeout_calc(void)
+ {
+ 	if((WscSupplicantConfig.smState == WSC_STATE_ASSOC) && (WscSupplicantConfig.WscMode == WSC_MODE_PBC))
+ 		return 120; /* another 2 min of timeout */
+ 	else
+ 		return 0;
+ }
+ 
+ void wsc_supplicant_stop()
+ {
+ 	wpa_printf(MSG_INFO,"wsc_supplicant: wsc_supplicant_stop: entered function\n");
+ 	
+ 	if(WscSupplicantConfig.smState == WSC_STATE_IDLE)
+ 	{
+ 		return;
+ 	}
+ 
+    
+ 	wpa_drv_set_wsc_mode(WscSupplicantConfig.wpa_s,
+ 					  		WSC_MODE_OFF,
+ 					  		NULL, 
+ 					  		0);
+ 	
+ 	if(WscSupplicantConfig.smState == WSC_STATE_ASSOC)
+ 	{
+ 		if(WscSupplicantConfig.WscMode == WSC_MODE_PBC)
+ 		{
+ 			/* 
+ 			If Supplicant is in a process of a Simple Config handhsake and in PBC mode - 
+ 			Cancel registration to 2 Min. Walk-Time PushButton timeout
+ 			*/		
+ 			eloop_cancel_timeout(wsc_supplicant_PushButtonWalktimeTimeout, NULL, NULL);
+ 		}
+ 	}
+ 
+ 	WscSupplicantConfig.smState = WSC_STATE_IDLE;
+ 	
+ }
+ 
+ u32 wsc_supplicant_SerializeHeader(u16 type, u16 len, bufferObj *outBuf)
+ {
+ 	/* serializes the type and length.*/
+ 	u8 temp[sizeof(u32)];
+ 
+ 	/* Copy the Type */
+ 	/*convert a u_short from host to TCP/IP network byte order (which is big-endian).*/
+ 	*(u16 *)temp = htons(type);
+ 	bufferAppend(outBuf, sizeof(u16), temp);
+ 
+ 	/* Copy the Length */
+ 	/* convert a u_short from host to TCP/IP network byte order (which is big-endian).*/
+ 	*(u16 *)temp = htons(len);
+ 	bufferAppend(outBuf, sizeof(u16), temp);
+ 
+ 	return OK;
+ }
+ 
+ u32 wsc_supplicant_SerializeField(u16 type, bufferObj *outBuf, u16 len, u8 *data)
+ {
+ 	u8 *pos;
+ 
+ 	if((NULL == data) || (0 == len))
+ 	{
+ 		wpa_printf(MSG_ERROR,"wsc_supplicant: wsc_supplicant_SerializeField: serialize error - invalid empty parameter");
+ 		return NOK;
+ 	}
+     
+ 	/* Copy the Type & Length */
+ 	wsc_supplicant_SerializeHeader(type, len, outBuf);
+ 
+ 	/* Copy the Value */
+ 	pos = bufferAppend(outBuf, len, data);
+ 
+ 	/* The data has already been stored.*/
+ 	/* Now convert it to network byte order as appropriate */
+ 	if(len == sizeof(u32))
+ 	{
+ 		u32 Temp32;
+ 
+ 		memcpy(&Temp32, pos, 4);
+ 		Temp32 = htonl(Temp32);
+ 		memcpy(pos, &Temp32, 4);
+ 	}
+ 	else if(len == sizeof(u16))
+ 	{
+ 		u16 Temp16;
+ 		memcpy(&Temp16, pos, 2);
+ 		Temp16 = htons(Temp16);
+ 		memcpy(pos, &Temp16, 2);
+ 	}	
+ 
+ 	return OK;
+ }
+ 
+ TWscSupplicant* wsc_supplicant_GetWscSupplicantConfig(void)
+ {
+ 	return &WscSupplicantConfig;
+ }
+ 
+ u32 wsc_supplicant_ComputeChecksum(u32 PIN )
+ {
+     u32 accum = 0;
+ 	int digit;
+ 
+ 	PIN *= 10;
+ 	accum += 3 * ((PIN / 10000000) % 10); 
+ 	accum += 1 * ((PIN / 1000000) % 10); 
+ 	accum += 3 * ((PIN / 100000) % 10); 
+ 	accum += 1 * ((PIN / 10000) % 10); 
+ 	accum += 3 * ((PIN / 1000) % 10); 
+ 	accum += 1 * ((PIN / 100) % 10); 
+ 	accum += 3 * ((PIN / 10) % 10); 
+ 
+ 	digit = (accum % 10);
+ 	return (10 - digit) % 10;
+ }
+ 
+ 
+ 
diff -BNcr wpa_supplicant-0.5.7/wsc_supplicant.h wpa_view/wpa_suppl/wsc_supplicant.h
*** wpa_supplicant-0.5.7/wsc_supplicant.h	Thu Jan  1 02:00:00 1970
--- wpa_view/wpa_suppl/wsc_supplicant.h	Wed Jun  9 13:31:26 2010
***************
*** 0 ****
--- 1,132 ----
+ /*
+  * wsc_supplicant.h
+  *
+  * Copyright 2001-2009 Texas Instruments, Inc. - http://www.ti.com/
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  * Alternatively, this software may be distributed under the terms of BSD
+  * license.
+  *
+  * See README and COPYING for more details.
+  */
+ 
+ #ifndef WSC_SUPPLICANT_H
+ #define WSC_SUPPLICANT_H
+ 
+ #include "bufferObj.h"
+ 
+ #define WSC_STATE_IDLE		0
+ #define WSC_STATE_ASSOC		1
+ #define WSC_STATE_EVENT_ASSOC	2
+ #define WSC_STATE_SUCCESS		3
+ 
+ #define MAX_MANUFACTURER		64
+ #define MAX_MODEL_NAME			32
+ #define MAX_MODEL_NUMBER		32
+ #define MAX_SERIAL_NUMBER		32
+ #define MAX_DEVICE_NAME		32
+ #define MAX_PASSWORD_SIZE		64 /* Password is actually the PIN */
+ #define MAX_NETWORK_KEY_NUM  	4
+ #define DEFAULT_KEY_INDEX    	1
+ 
+ #define LONG_PIN_LEN			8
+ #define SHORT_PIN_LEN			4
+ 
+ typedef struct
+ {
+ 	int length;
+ 	u8* pValue;
+ } TLVPUINT8;
+ 
+ typedef struct
+ {
+ 	int length;
+ 	char* pValue;
+ } TLVPCHAR;
+ 
+ typedef struct
+ {
+     /* Required attributes */
+     u8         			nwIndex;
+     TLVPUINT8			ssid;
+     u16        			authType;
+     u16        			encrType;
+     u8      			nwKeyIndex;
+     u8      			wepTransmitKey;    
+     TLVPCHAR           	nwKey[MAX_NETWORK_KEY_NUM];    
+     TLVPUINT8         	macAddr;
+ 
+     /* Optional attributes */
+     TLVPUINT8  			eapType; /* TBD: Define this */
+     u8         			bKey_Provided_Automatically;
+     u8         			b_Is_802_1x_enabled;
+     u8         			WEP_transmit_key;
+ 
+     TLVPUINT8           eapIdentity; /* TBD: Define this */
+     u32     			keyLifetime; /* TBD: Define this */
+     void*       		vendorExt;  /* TBD: Ignore for now */
+     TLVPUINT8        	rekeyKey;
+     TLVPUINT8        	x509Cert;
+ }TTlvCredential;
+ 
+ 
+ typedef struct
+ {
+     TTlvCredential     	credential; /* this is the first credential that is delivered inside M8. In the future this can be replaced with a list of credentials */
+     TLVPCHAR          	new_pwd;
+     u16     			pwdId;
+     TLVPUINT8   		keyWrapAuth; /* reuse Authenticator data struct */
+ } TStaEncryptSettings;
+ 
+ 
+ typedef struct
+ {
+ 	u16 category_id;
+ 	u16 sub_category_id;
+ 	u32 oui; /* =0x0050F204 */	
+ } TWscSupplicant_DeviceType;
+ 
+ typedef struct
+ {
+ 	u8 		macAddress[ETH_ALEN];
+ 	u8 		version; /* (0x104A) */	
+ 	u16 	configMethods; /* (0x1008) */
+ 	u8 		uuidE[32]; /* (0x1047) */
+ 	TWscSupplicant_DeviceType primaryDeviceType; /* (0x1054) */
+ 	u8 		rfBand; /* (0x103C) */
+ 	u16		devicePasswordId; /* (0x1012) */
+ 	u16 	authenticationTypeFlags; /* (0x1004) */
+ 	u16 	encryptionTypeFlags; /* (0x1010) */
+ 	u8 		connectionTypeFlags; /* (0x100D) */
+ 	u8 		state; /* (0x1044) */
+ 	char 	manufacturer[MAX_MANUFACTURER]; /* (0x1021) */
+ 	char 	modelName[MAX_MODEL_NAME]; /* (0x1023) */
+ 	char 	modelNumber[MAX_MODEL_NUMBER]; /* (0x1024) */
+ 	char 	serialNumber[MAX_SERIAL_NUMBER]; /* (0x1042) */
+ 	char 	deviceName[MAX_DEVICE_NAME]; /* (0x1011) */
+ 	u16 	assocState; /* (0x1002) */
+ 	u16 	configError; /* (0x1009) */
+ 	u32 	osVersion; /* (0x102D) */
+ 	u8 		password[MAX_PASSWORD_SIZE]; /* This is the PIN number of the AP, although in some technologies it is changable */
+ 
+ 	void*	ssid;
+ 	void*	wpa_s;		
+ 	u32 	smState;
+ 	u32 	WscMode;
+ } TWscSupplicant;
+ 
+ void wsc_supplicant_associate(void* h_wpa_s, void* h_ssid, u32 WscMode);
+ void wsc_supplicant_EapSuccess(TStaEncryptSettings* pStaEncryptSettings);
+ void wsc_supplicant_event_assoc(void* h_ssid);
+ void wsc_supplicant_event_overlap();
+ int wsc_supplicant_associate_timeout_calc(void);
+ void wsc_supplicant_stop();
+ u32 wsc_supplicant_SerializeHeader(u16 type, u16 len, bufferObj *outBuf);
+ u32 wsc_supplicant_SerializeField(u16 type, bufferObj *outBuf, u16 len, u8 *data);
+ TWscSupplicant* wsc_supplicant_GetWscSupplicantConfig(void);
+ u32 wsc_supplicant_ComputeChecksum(u32 PIN );
+ 
+ #endif /* WSC_SUPPLICANT_H */
